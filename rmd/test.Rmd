# prepare_pseudobulk_edgeR -> 슈도벌크 내부 함수로서 잘 작동함. 엄밀히는 정확히 이건지는 모르나 슈도벌크 문서 안의 함수는 잘 작동함. (250513)

```{r}
prepare_pseudobulk_edgeR <- function(seurat_obj,
                                     assay = "SCT",
                                     slot = "counts",
                                     sample_col,
                                     cluster_col,
                                     group_col,
                                     min_count = 10,
                                     norm_method = "TMM",
                                     design_formula = NULL,
                                     verbose = TRUE) {
  
  if (!requireNamespace("Seurat", quietly = TRUE)) stop("Seurat 패키지가 필요합니다.")
  if (!requireNamespace("edgeR", quietly = TRUE)) stop("edgeR 패키지가 필요합니다.")
  if (!requireNamespace("dplyr", quietly = TRUE)) stop("dplyr 패키지가 필요합니다.")
  if (!requireNamespace("tidyr", quietly = TRUE)) stop("tidyr 패키지가 필요합니다.")
  if (!requireNamespace("tibble", quietly = TRUE)) stop("tibble 패키지가 필요합니다.")
  
  # 1. Check input columns exist in metadata
  meta_cols <- colnames(seurat_obj@meta.data)
  required_cols <- c(sample_col, cluster_col, group_col)
  if (!all(required_cols %in% meta_cols)) {
    stop("다음 컬럼이 Seurat 객체 메타데이터에 없습니다: ",
         paste(required_cols[!required_cols %in% meta_cols], collapse = ", "))
  }
  
  # Ensure group_col is a factor for reliable level ordering
  seurat_obj@meta.data[[group_col]] <- factor(seurat_obj@meta.data[[group_col]])
  
  # 2. Aggregate Expression
  if (verbose) message("1. Aggregating expression to pseudo-bulk...")
  pb <- AggregateExpression(
    seurat_obj,
    assays = assay,
    slot = slot,
    group.by = c(sample_col, cluster_col),
    return.seurat = FALSE
  )[[assay]] # Get the specific assay matrix
  
  if (nrow(pb) == 0 || ncol(pb) == 0) {
    stop("AggregateExpression 결과 pseudo-bulk 매트릭스가 비어있습니다. group.by 컬럼들을 확인하세요.")
  }
  
  # 3. Create Metadata for pseudo-bulk samples
if (verbose) message("2. Creating metadata for pseudo-bulk samples...")
col_example <- colnames(pb)[1]
# AggregateExpression은 group.by 값들을 _로 연결합니다.
# 만약 sample_col이나 cluster_col 값 자체에 _나 -가 있다면 문제가 될 수 있으나,
# 보통은 _를 구분자로 사용합니다.
sep <- "_" 

meta_pb <- tryCatch({
    tibble(pb_sample_id = colnames(pb)) %>%
        # extra="merge"는 첫번째 구분자 뒤의 모든 것을 두번째 변수(ctype)에 할당
        tidyr::separate(pb_sample_id, into = c("patient_temp", "ctype_temp"), sep = sep, extra = "merge", remove = FALSE)
}, error = function(e) {
    stop("Pseudo-bulk 컬럼 이름 ('", col_example, "')을 'patient'", sep, "'ctype' 형태로 분리할 수 없습니다. ",
         "AggregateExpression의 group.by 순서나 컬럼 내용을 확인하세요. 에러: ", e$message)
})

# ---- 디버깅을 위한 추가 출력 ----
if (verbose) {
  message("Debug: First 5 raw pb_sample_id from AggregateExpression: ", paste(head(colnames(pb), 5), collapse=", "))
  message("Debug: First 5 separated 'patient_temp': ", paste(head(meta_pb$patient_temp, 5), collapse=", "))
  message("Debug: First 5 separated 'ctype_temp': ", paste(head(meta_pb$ctype_temp, 5), collapse=", "))
}

# patient와 ctype 컬럼 값에서 앞뒤 공백 제거 및 문자형으로 확실히 변환
meta_pb <- meta_pb %>%
  mutate(
    patient = trimws(as.character(patient_temp)),
    ctype = trimws(as.character(ctype_temp))
  ) %>%
  select(-patient_temp, -ctype_temp) # 임시 컬럼 제거

# Map group information from original Seurat metadata
sample_group_map <- seurat_obj@meta.data %>%
  select(!!sym(sample_col), !!sym(group_col)) %>%
  distinct() %>%
  # 매칭을 위해 sample_col도 문자형으로 변환하고 공백 제거
  mutate(!!sym(sample_col) := trimws(as.character(!!sym(sample_col))))

# ---- 디버깅을 위한 추가 출력 ----
if (verbose) {
  message("Debug: Unique values for matching from Seurat's '", sample_col, "' (in sample_group_map, after trim/as.character): ", 
          paste(head(unique(sample_group_map[[sample_col]]), 10), collapse=", "))
  message("Debug: Unique values for matching from aggregated names 'patient' (in meta_pb, after trim/as.character): ", 
          paste(head(unique(meta_pb$patient), 10), collapse=", "))
}

# setNames를 사용하여 join 키를 동적으로 설정
# (기존 코드와 동일하나, 위에서 patient와 sample_col의 값들이 정리되었음)
join_by_col <- sample_col
names(join_by_col) <- "patient" # meta_pb의 'patient' 컬럼과 sample_group_map의 'sample_col'을 매칭

meta_pb <- meta_pb %>%
  left_join(sample_group_map, by = join_by_col)

# ---- 디버깅을 위한 추가 출력 ----
if (sum(is.na(meta_pb[[group_col]]))) {
    message("Debug: WARNING - Group mapping failed for some samples.")
    # 매칭 실패한 patient 값 확인
    failed_patients <- meta_pb %>% filter(is.na(!!sym(group_col))) %>% pull(patient) %>% unique()
    message("Debug: Patient IDs from aggregated names that failed to map: ", paste(head(failed_patients, 10), collapse=", "))
} else {
    message("Debug: Group mapping appears successful for all pseudo-bulk samples.")
}
if (verbose) {
  message("Debug: First 5 rows of meta_pb after group mapping:")
  print(head(meta_pb))
  message("Debug: Unique 'ctype' values in meta_pb: ", paste(sort(unique(meta_pb$ctype)), collapse="', '"))
}

  
  # Make sure row order of meta_pb matches column order of pb
  meta_pb <- meta_pb[match(colnames(pb), meta_pb$pb_sample_id),]
  rownames(meta_pb) <- meta_pb$pb_sample_id # Set rownames for edgeR convenience
  
  # 4. Prepare for edgeR
  if (verbose) message("3. Preparing DGEList and design matrix...")
  dge <- DGEList(counts = pb, group = meta_pb[[group_col]], samples = meta_pb)
  
  # filterByExpr 전에 그룹 정보가 올바른지 한번 더 확인
if (any(is.na(meta_pb[[group_col]]))) {
    warning("그룹 정보에 NA 값이 포함되어 있습니다. filterByExpr 및 DEG 분석에 영향을 줄 수 있습니다.")
    # NA 그룹을 가진 샘플을 제외할지, 아니면 특정 값으로 대체할지 결정 필요
    # 여기서는 NA를 가진 샘플을 dge 객체에서 제외하는 것을 고려해볼 수 있음 (또는 에러 발생)
    # valid_samples <- !is.na(meta_pb[[group_col]])
    # dge <- dge[, valid_samples]
    # meta_pb <- meta_pb[valid_samples,]
    # if(nrow(dge) == 0) stop("NA 그룹 제외 후 남은 샘플이 없습니다.")
}
# 그룹 레벨이 2개 이상인지 확인
if (length(unique(na.omit(meta_pb[[group_col]]))) < 2) {
    stop("DEG 분석을 수행하기에 그룹 레벨 수가 부족합니다 (2개 미만). 그룹 정보를 확인하세요: ",
         paste(unique(na.omit(meta_pb[[group_col]])), collapse=", "))
}
  
  # Filtering
  keep <- filterByExpr(dge, group = meta_pb[[group_col]], min.count = min_count)
  if (verbose) message("   - Filtering: Kept ", sum(keep), " out of ", nrow(dge), " genes.")
  if (sum(keep) == 0) {
    warning("filterByExpr 결과 남은 유전자가 없습니다. min.count 값을 낮추거나 데이터를 확인하세요.")
  }
  dge <- dge[keep, , keep.lib.sizes = FALSE]
  
  # Normalization
  dge <- calcNormFactors(dge, method = norm_method)
  
  # Design Matrix
  contrast_levels <- levels(meta_pb[[group_col]])
  if (is.null(design_formula)) {
    # Default design: ~ group_col (intercept + group effects)
    formula_str <- paste("~", group_col)
  } else {
    # User-provided formula string (replace 'group_col' placeholder if present)
    formula_str <- gsub("group_col", group_col, deparse(design_formula))
  }
  
  design <- tryCatch({
    model.matrix(as.formula(formula_str), data = meta_pb)
  }, error = function(e) {
    stop("디자인 매트릭스 생성 실패: ", e$message,
         "\n   Formula: ", formula_str,
         "\n   Metadata head:\n", paste(utils::capture.output(head(meta_pb)), collapse="\n"))
  })
  
  # Clean up design matrix column names (remove backticks or invalid chars)
  colnames(design) <- make.names(colnames(design))
  
  if (verbose) message("4. Preparation complete.")
  
  return(list(
    pb = pb,
    meta = meta_pb,
    dge = dge,
    design = design,
    contrast_levels = contrast_levels
  ))
}
```

# chemokines

```{r}
# 케모카인 리간드 (Chemokine Ligands)
# cmkl <- list(
#   # --- 특정 백혈구 유인 리간드 ---
#   attract_monocytes_macrophages = c("CCL2", "CCL3", "CCL4", "CCL5", "CCL7", "CCL8", "CCL13", "CXCL12"), # MCP-1, MIP-1a, MIP-1b, RANTES, MCP-3, MCP-2, MCP-4, SDF-1
#   attract_t_cells = c(
#     # 일반 T cell 유인
#     "CCL2", "CCL3", "CCL4", "CCL5", "CXCL12",
#     # Th1 세포 유인
#     "CXCL9", "CXCL10", "CXCL11", # MIG, IP-10, I-TAC
#     # Th2 세포 유인
#     "CCL17", "CCL22", # TARC, MDC
#     # Th17 세포 유인
#     "CCL20", # MIP-3a
#     # Treg 유인
#     "CCL17", "CCL22", "CCL20",
#     # 피부 귀소 T 세포 유인 (CLA+)
#     "CCL1", "CCL17", "CCL27", # I-309, TARC, CTACK
#     # 장 귀소 T 세포 유인 (CCR9+)
#     "CCL25" # TECK
#   ),
#   attract_b_cells = c("CXCL13", "CCL19", "CCL21", "CXCL12"), # BLC/BCA-1, MIP-3b/ELC, SLC/6Ckine, SDF-1
#   attract_nk_cells = c("CCL3", "CCL4", "CCL5", "CXCL8", "CXCL10", "CXCL11", "CX3CL1"), # MIP-1a, MIP-1b, RANTES, IL-8, IP-10, I-TAC, Fractalkine
#   attract_dcs = c( # 수지상 세포
#     # 미성숙 DC
#     "CCL3", "CCL4", "CCL5", "CCL20",
#     # 성숙 DC (림프절 귀소)
#     "CCL19", "CCL21" # MIP-3b/ELC, SLC/6Ckine
#   ),
#   attract_neutrophils = c("CXCL1", "CXCL2", "CXCL3", "CXCL5", "CXCL6", "CXCL8"), # GROa/KC, GROb, GROg, ENA-78, GCP-2, IL-8 (ELR+ CXCLs)
#   attract_eosinophils = c("CCL5", "CCL11", "CCL24", "CCL26"), # RANTES, Eotaxin-1, Eotaxin-2, Eotaxin-3
#   attract_basophils = c("CCL2", "CCL3", "CCL5", "CCL11"),
# 
#   # --- 항상성 및 림프 기관 관련 리간드 ---
#   homeostatic_lymphoid_organ_ligands = c(
#     "CXCL12", # 골수 (조혈모세포), 일반적 조직 항상성
#     "CXCL13", # B cell 여포
#     "CCL19", "CCL21", # T cell zone, DC 이동
#     "CCL25" # 소장, 흉선
#   ),
# 
#   # --- 뇌척수액(CSF) 구획 / 혈액뇌장벽(BBB) 통과 관련 리간드 (연구 중인 내용 포함) ---
#   # 주의: BBB 통과는 매우 복잡하며, 염증 상태에 따라 크게 달라짐
#   csf_bbb_homing_related_ligands = c(
#     "CCL2",   # 단핵구의 BBB 통과 및 CNS 염증에 중요
#     "CCL5",   # T세포 및 단핵구의 CNS 유입
#     "CXCL10", # 활성화 T세포의 CNS 유입 (특히 Th1)
#     "CXCL12", # 다양한 세포의 CNS 이동, 신경염증 및 항상성 유지에 관여
#     "CCL11",  # 호산구 CNS 침투 (일부 조건)
#     "CCL19", "CCL21" # 림프구/DC의 CNS 유입 (특히 다발성 경화증 같은 염증 상황)
#   ),
# 
#   # --- 내피세포 및 기질세포에서 주로 생산되는 리간드 ---
#   produced_by_endothelial_stromal = c(
#     "CXCL1", "CXCL8", "CCL2", "CCL5", "CXCL12", # 염증 시 이들 세포에서 많이 발현
#     "CX3CL1" # Fractalkine (내피세포에서 막결합형 또는 분비형으로 발현)
#   ),
# 
#   # --- 기타 주요 리간드 ---
#   other_key_ligands = c(
#     "CX3CL1" # Fractalkine (주로 막결합형, 단핵구/NK/T세포 유인 및 부착)
#   )
# )
# 
# # 케모카인 수용체 (Chemokine Receptors)
# cmkr <- list(
#   # --- 특정 백혈구에 주로 발현하는 수용체 ---
#   on_monocytes_macrophages = c("CCR1", "CCR2", "CCR5", "CXCR4", "CX3CR1"),
#   on_t_cells = c(
#     # 일반 T cell
#     "CCR2", "CCR5", "CXCR3", "CXCR4",
#     # Th1 세포
#     "CXCR3", "CCR5",
#     # Th2 세포
#     "CCR3", "CCR4", "CCR8",
#     # Th17 세포
#     "CCR6", "CCR4", # CCR4는 일부 Th17 아형
#     # Treg
#     "CCR4", "CCR5", "CCR6", "CCR8", "CXCR3",
#     # 피부 귀소 T 세포 (CLA+)
#     "CCR4", "CCR10",
#     # 장 귀소 T 세포
#     "CCR9", "CXCR3" # 일부 장 귀소 T세포는 CXCR3 발현
#   ),
#   on_b_cells = c("CXCR4", "CXCR5", "CCR6", "CCR7"), # CCR7은 특정 B세포 아형
#   on_nk_cells = c("CXCR1", "CXCR2", "CXCR3", "CCR2", "CCR5", "CX3CR1"),
#   on_dcs = c( # 수지상 세포
#     # 미성숙 DC
#     "CCR1", "CCR2", "CCR5", "CCR6",
#     # 성숙 DC (림프절 귀소)
#     "CCR7"
#   ),
#   on_neutrophils = c("CXCR1", "CXCR2", "CXCR4"), # CXCR4는 특정 조건에서 호중구 동원
#   on_eosinophils = c("CCR1", "CCR3"),
#   on_basophils = c("CCR1", "CCR2", "CCR3", "CXCR4"),
# 
#   # --- 항상성 및 림프 기관 관련 수용체 ---
#   homeostatic_lymphoid_organ_receptors = c(
#     "CXCR4", # 골수 귀소 및 유지
#     "CXCR5", # B cell 여포 귀소
#     "CCR7",  # T cell 및 DC의 2차 림프기관 귀소
#     "CCR9"   # 소장 귀소
#   ),
# 
#   # --- 뇌척수액(CSF) 구획 / 혈액뇌장벽(BBB) 통과 관련 수용체 (연구 중인 내용 포함) ---
#   csf_bbb_homing_related_receptors = c(
#     "CCR2",   # 단핵구의 BBB 통과 및 CNS 염증
#     "CCR5",   # T세포 및 단핵구의 CNS 유입
#     "CXCR3",  # 활성화 T세포의 CNS 유입
#     "CXCR4",  # 다양한 세포의 CNS 이동, 신경염증
#     "CCR6",   # Th17 세포의 CNS 유입 (예: EAE 모델)
#     "CX3CR1"  # 미세아교세포(microglia), 일부 순환 단핵구에 발현, CNS 항상성 및 염증
#   ),
# 
#   # --- 내피세포 및 기질세포에 발현하는 수용체 (이들 세포의 반응 유도) ---
#   on_endothelial_stromal = c(
#     "CXCR4", # 혈관신생, 세포 이동
#     "CXCR1", "CXCR2", # 혈관신생, 염증 반응 조절
#     "ACKR3"  # 이전 CXCR7, CXCL12, CXCL11과 결합, 청소 수용체, 신호 전달 가능성
#   ),
# 
#   # --- 비정형 케모카인 수용체 (Atypical Chemokine Receptors, ACKR) - 주로 청소 기능 ---
#   ackr_scavengers = c("ACKR1", "ACKR2", "ACKR3", "ACKR4") # 이전 DARC/Duffy, D6, CXCR7, CCRL1
# )
# 
# # 인테그린 (Integrins)
# integrin_list <- list(
#   # --- 주요 알파 소단위체 유전자 (ITGA) ---
#   alpha_subunits = c(
#     "ITGAL",  # L (CD11a) - part of LFA-1
#     "ITGAM",  # M (CD11b) - part of Mac-1/CR3
#     "ITGAX",  # X (CD11c) - part of p150,95/CR4
#     "ITGAD",  # D (CD11d)
#     "ITGAE",  # E (CD103) - forms heterodimer with ITGB7, mucosal lymphocytes
#     "ITGA1", "ITGA2", "ITGA3", "ITGA5", "ITGA6", "ITGA7", "ITGA8", "ITGA9", "ITGA10", "ITGA11", # Collagen, Laminin, Fibronectin receptors
#     "ITGA4",  # Part of VLA-4 (with ITGB1) and LPAM-1 (with ITGB7)
#     "ITGAV"   # Part of various receptors for Vitronectin, Fibronectin etc. (with ITGB1, ITGB3, ITGB5, ITGB6, ITGB8)
#   ),
#   # --- 주요 베타 소단위체 유전자 (ITGB) ---
#   beta_subunits = c(
#     "ITGB1",  # (CD29) - Forms VLA integrins with ITGA1-9, ITGAV
#     "ITGB2",  # (CD18) - Forms leukocyte integrins LFA-1, Mac-1, p150,95, ITGAD/ITGB2
#     "ITGB3",  # (CD61) - Forms receptors with ITGAV (vitronectin receptor) and ITGA2B (platelet glycoprotein IIb/IIIa)
#     "ITGB4",  # Forms alpha6beta4 (laminin receptor, hemidesmosomes)
#     "ITGB5",  # Forms alphaVbeta5 (vitronectin receptor)
#     "ITGB6",  # Forms alphaVbeta6 (fibronectin/TGF-beta activation)
#     "ITGB7",  # Forms LPAM-1 with ITGA4 (gut homing), and with ITGAE (mucosal T cells)
#     "ITGB8"   # Forms alphaVbeta8 (TGF-beta activation)
#   ),
#   # --- 주요 이종이합체 (Heterodimers) 예시 (리간드 결합에 중요) ---
#   # (실제 분석 시에는 각 소단위체의 발현량 조합으로 추론)
#   key_heterodimers_example_subunits = list(
#     LFA_1 = c("ITGAL", "ITGB2"),    # Ligands: ICAM1, ICAM2, ICAM3
#     Mac_1_CR3 = c("ITGAM", "ITGB2"), # Ligands: ICAM1, C3bi, Fibrinogen
#     VLA_4 = c("ITGA4", "ITGB1"),    # Ligands: VCAM1, Fibronectin (CS-1)
#     LPAM_1 = c("ITGA4", "ITGB7"),   # Ligands: MAdCAM1, VCAM1, Fibronectin
#     alphaE_beta7 = c("ITGAE", "ITGB7"), # Ligand: E-cadherin
#     alphaV_beta3 = c("ITGAV", "ITGB3") # Ligands: Vitronectin, Fibronectin, Osteopontin
#   ),
#   # --- 주요 인테그린 세포외기질 리간드 (ECM Ligands for Integrins - 단백질명) ---
#   # (유전자 발현 분석 시 해당 단백질을 코딩하는 유전자 사용)
#   ecm_ligands_genes = c(
#     "FN1",      # Fibronectin
#     "COL1A1", "COL1A2", "COL2A1", "COL3A1", "COL4A1", "COL4A2", # Collagens
#     "LAMA1", "LAMA2", "LAMA3", "LAMA4", "LAMA5", # Laminins alpha
#     "LAMB1", "LAMB2", "LAMB3", # Laminins beta
#     "LAMC1", "LAMC2", "LAMC3", # Laminins gamma
#     "VTN",      # Vitronectin
#     "TNC",      # Tenascin C
#     "SPP1"      # Osteopontin (Secreted Phosphoprotein 1)
#   ),
#   # --- 주요 인테그린 세포 표면 리간드 (Cellular Ligands for Integrins - 유전자명) ---
#   cellular_ligands_genes = c(
#     "ICAM1", "ICAM2", "ICAM3", "ICAM4", "ICAM5", # Intercellular Adhesion Molecules
#     "VCAM1",    # Vascular Cell Adhesion Molecule 1
#     "MADCAM1",  # Mucosal Addressin Cell Adhesion Molecule 1
#     "CDH1",     # E-cadherin (Cadherin 1)
#     "PECAM1"    # CD31 (Platelet Endothelial Cell Adhesion Molecule) - 인테그린 리간드는 아니지만 상호작용
#   ),
#   # --- 인테그린 활성화 및 신호 전달 관련 주요 내부 분자 (Inside-out, Outside-in signaling) ---
#   integrin_signaling_associated = c(
#     "TLN1", "TLN2", # Talin 1, 2
#     "KIND1", "KIND2", "KIND3", # Kindlin 1, 2, 3 (FERMT1, FERMT2, FERMT3)
#     "PTK2",     # FAK (Focal Adhesion Kinase)
#     "SRC",      # Src kinase
#     "ILK",      # Integrin Linked Kinase
#     "ACTN1", "ACTN4", # Alpha-actinins
#     "VCL"       # Vinculin
#   )
# )

# 사용 예시:
# print(cmkl$attract_monocytes_macrophages)
# print(cmkr$on_t_cells)
# print(integrin_list$key_heterodimers_example_subunits$LFA_1)
# print(integrin_list$cellular_ligands_genes)
```

# chemokines -> gene symbol
```{r}
# 케모카인 리간드 (Chemokine Ligands) - 공식 유전자 기호 사용
cmkl <- list(
  # --- 특정 백혈구 유인 리간드 ---
  attract_monocytes_macrophages = c("CCL2", "CCL3", "CCL4", "CCL5", "CCL7", "CCL8", "CCL13", "CXCL12"),
  attract_t_cells = c(
    # 일반 T cell 유인
    "CCL2", "CCL3", "CCL4", "CCL5", "CXCL12",
    # Th1 세포 유인
    "CXCL9", "CXCL10", "CXCL11",
    # Th2 세포 유인
    "CCL17", "CCL22",
    # Th17 세포 유인
    "CCL20",
    # Treg 유인
    "CCL17", "CCL22", "CCL20",
    # 피부 귀소 T 세포 유인 (CLA+)
    "CCL1", "CCL17", "CCL27",
    # 장 귀소 T 세포 유인 (CCR9+)
    "CCL25"
  ),
  attract_b_cells = c("CXCL13", "CCL19", "CCL21", "CXCL12"),
  attract_nk_cells = c("CCL3", "CCL4", "CCL5", "CXCL8", "CXCL10", "CXCL11", "CX3CL1"),
  attract_dcs = c( # 수지상 세포
    # 미성숙 DC
    "CCL3", "CCL4", "CCL5", "CCL20",
    # 성숙 DC (림프절 귀소)
    "CCL19", "CCL21"
  ),
  attract_neutrophils = c("CXCL1", "CXCL2", "CXCL3", "CXCL5", "CXCL6", "CXCL8"),
  attract_eosinophils = c("CCL5", "CCL11", "CCL24", "CCL26"),
  attract_basophils = c("CCL2", "CCL3", "CCL5", "CCL11"),

  # --- 항상성 및 림프 기관 관련 리간드 ---
  homeostatic_lymphoid_organ_ligands = c(
    "CXCL12",
    "CXCL13",
    "CCL19", "CCL21",
    "CCL25"
  ),

  # --- 뇌척수액(CSF) 구획 / 혈액뇌장벽(BBB) 통과 관련 리간드 ---
  csf_bbb_homing_related_ligands = c(
    "CCL2",
    "CCL5",
    "CXCL10",
    "CXCL12",
    "CCL11",
    "CCL19", "CCL21"
  ),

  # --- 내피세포 및 기질세포에서 주로 생산되는 리간드 ---
  produced_by_endothelial_stromal = c(
    "CXCL1", "CXCL8", "CCL2", "CCL5", "CXCL12",
    "CX3CL1"
  ),

  # --- 기타 주요 리간드 ---
  other_key_ligands = c(
    "CX3CL1"
  )
)

# 케모카인 수용체 (Chemokine Receptors) - 공식 유전자 기호 사용
cmkr <- list(
  # --- 특정 백혈구에 주로 발현하는 수용체 ---
  on_monocytes_macrophages = c("CCR1", "CCR2", "CCR5", "CXCR4", "CX3CR1"),
  on_t_cells = c(
    # 일반 T cell
    "CCR2", "CCR5", "CXCR3", "CXCR4",
    # Th1 세포
    "CXCR3", "CCR5",
    # Th2 세포
    "CCR3", "CCR4", "CCR8",
    # Th17 세포
    "CCR6", "CCR4",
    # Treg
    "CCR4", "CCR5", "CCR6", "CCR8", "CXCR3",
    # 피부 귀소 T 세포 (CLA+)
    "CCR4", "CCR10",
    # 장 귀소 T 세포
    "CCR9", "CXCR3"
  ),
  on_b_cells = c("CXCR4", "CXCR5", "CCR6", "CCR7"),
  on_nk_cells = c("CXCR1", "CXCR2", "CXCR3", "CCR2", "CCR5", "CX3CR1"),
  on_dcs = c( # 수지상 세포
    # 미성숙 DC
    "CCR1", "CCR2", "CCR5", "CCR6",
    # 성숙 DC (림프절 귀소)
    "CCR7"
  ),
  on_neutrophils = c("CXCR1", "CXCR2", "CXCR4"),
  on_eosinophils = c("CCR1", "CCR3"),
  on_basophils = c("CCR1", "CCR2", "CCR3", "CXCR4"),

  # --- 항상성 및 림프 기관 관련 수용체 ---
  homeostatic_lymphoid_organ_receptors = c(
    "CXCR4",
    "CXCR5",
    "CCR7",
    "CCR9"
  ),

  # --- 뇌척수액(CSF) 구획 / 혈액뇌장벽(BBB) 통과 관련 수용체 ---
  csf_bbb_homing_related_receptors = c(
    "CCR2",
    "CCR5",
    "CXCR3",
    "CXCR4",
    "CCR6",
    "CX3CR1"
  ),

  # --- 내피세포 및 기질세포에 발현하는 수용체 ---
  on_endothelial_stromal = c(
    "CXCR4",
    "CXCR1", "CXCR2",
    "ACKR3" # 이전 CXCR7
  ),

  # --- 비정형 케모카인 수용체 (Atypical Chemokine Receptors, ACKR) ---
  ackr_scavengers = c("ACKR1", "ACKR2", "ACKR3", "ACKR4") # 각각 이전 DARC/Duffy, D6, CXCR7, CCRL1
)

# 인테그린 (Integrins) - 공식 유전자 기호 사용
integrin_list <- list(
  # --- 주요 알파 소단위체 유전자 (ITGA) ---
  alpha_subunits = c(
    "ITGAL", "ITGAM", "ITGAX", "ITGAD", "ITGAE",
    "ITGA1", "ITGA2", "ITGA3", "ITGA5", "ITGA6", "ITGA7", "ITGA8", "ITGA9", "ITGA10", "ITGA11",
    "ITGA4", "ITGAV"
  ),
  # --- 주요 베타 소단위체 유전자 (ITGB) ---
  beta_subunits = c(
    "ITGB1", "ITGB2", "ITGB3", "ITGB4", "ITGB5", "ITGB6", "ITGB7", "ITGB8"
  ),
  # --- 주요 이종이합체 (Heterodimers) 예시 (구성 소단위체 유전자) ---
  key_heterodimers_example_subunits = list(
    LFA_1 = c("ITGAL", "ITGB2"),
    Mac_1_CR3 = c("ITGAM", "ITGB2"),
    VLA_4 = c("ITGA4", "ITGB1"),
    LPAM_1 = c("ITGA4", "ITGB7"),
    alphaE_beta7 = c("ITGAE", "ITGB7"),
    alphaV_beta3 = c("ITGAV", "ITGB3")
  ),
  # --- 주요 인테그린 세포외기질 리간드 (유전자명) ---
  ecm_ligands_genes = c(
    "FN1",
    "COL1A1", "COL1A2", "COL2A1", "COL3A1", "COL4A1", "COL4A2",
    "LAMA1", "LAMA2", "LAMA3", "LAMA4", "LAMA5",
    "LAMB1", "LAMB2", "LAMB3",
    "LAMC1", "LAMC2", "LAMC3",
    "VTN",
    "TNC",
    "SPP1"
  ),
  # --- 주요 인테그린 세포 표면 리간드 (유전자명) ---
  cellular_ligands_genes = c(
    "ICAM1", "ICAM2", "ICAM3", "ICAM4", "ICAM5",
    "VCAM1",
    "MADCAM1",
    "CDH1", # E-cadherin
    "PECAM1"
  ),
  # --- 인테그린 활성화 및 신호 전달 관련 주요 내부 분자 (유전자명) ---
  integrin_signaling_associated = c(
    "TLN1", "TLN2", # Talin 1, 2
    "FERMT1", "FERMT2", "FERMT3", # Kindlin 1 (KIND1), Kindlin 2 (KIND2), Kindlin 3 (KIND3)
    "PTK2",     # FAK (Focal Adhesion Kinase)
    "SRC",      # Src kinase
    "ILK",      # Integrin Linked Kinase
    "ACTN1", "ACTN4", # Alpha-actinins
    "VCL"       # Vinculin
  )
)

# 사용 예시:
# print(cmkl$attract_t_cells)
# print(cmkr$on_monocytes_macrophages)
# print(integrin_list$alpha_subunits)
```

# immune functional genes

```{r}
immune_cell_functional_gene_sets <- list(

  # =========================================================================
  # T Cells (T 림프구)
  # =========================================================================
  t_cell_functional_sets = list(

    # -------------------------------------------------------------------------
    # General T Cell Markers & Signaling (모든 T세포 공통)
    # -------------------------------------------------------------------------
    general_t_cell = list(
      lineage_markers = c("CD3D", "CD3E", "CD3G", "CD2", "CD5", "CD7", "PTPRC"), # PTPRC (CD45)
      tcr_signaling = c("TRAC", "TRBC1", "TRBC2", "CD247", # CD247 (CD3zeta)
                        "LCK", "ZAP70", "LAT", "SLP76", # SLP76 is LCP2
                        "PLCG1", "NFATC1", "NFATC2", "NFKB1", "RELA")
    ),

    # -------------------------------------------------------------------------
    # CD4+ T Cells (보조 T 림프구)
    # -------------------------------------------------------------------------
    cd4_t_cell = list(
      lineage_marker = c("CD4"),
      naive = c("CCR7", "SELL", "LEF1", "TCF7", "IL7R", "S1PR1", "CD27", "CD28", "STAT5A", "STAT5B"), # Naive markers
      activation_early = c("CD69", "CD25", # CD25 is IL2RA
                           "FOS", "JUN", "EGR1", "EGR2", # Immediate early genes
                           "NFKBIA", "ICOS", "CD40LG"), # CD40LG (CD154)
      # --- Effector Subtypes (작동 아형) ---
      effector_Th1 = c("TBX21", # T-bet
                       "IFNG", "TNF", "LTA", # Cytokines
                       "CXCR3", "CCR5", # Chemokine receptors
                       "STAT1", "STAT4", "IL12RB1", "IL12RB2", "IL18R1"),
      effector_Th2 = c("GATA3",
                       "IL4", "IL5", "IL13", "AREG", # Cytokines
                       "CCR3", "CCR4", "PTGDR2", # CRTH2 (Chemokine receptors)
                       "STAT6", "IL4R", "IL1RL1"), # IL1RL1 (ST2)
      effector_Th17 = c("RORC", # RORgammaT
                        "IL17A", "IL17F", "IL21", "IL22", "IL26", "CSF2", # Cytokines (CSF2 is GM-CSF)
                        "CCR6", "CXCR6", # Chemokine receptors
                        "STAT3", "IL23R", "IL1R1"),
      effector_Tfh = c("BCL6", "CXCR5", "PDCD1", "ICOS", "SLAMF1", "SLAMF6", # PDCD1 (PD-1)
                       "IL21", "MAF", "ASCL2", "TOX2"), # Follicular helper T cells
      effector_cytotoxic_cd4 = c( # 일부 CD4+ T세포에서 세포독성 발현
                        "GZMA", "GZMB", "GZMH", "GZMK", "PRF1", "NKG7", "GNLY"
      ),
      # --- Memory Subtypes (기억 아형) ---
      memory_Tcm = c("CCR7", "SELL", "IL7R", "CD27", "CD28", "TCF7", "LEF1", "CD62L"), # Central Memory
      memory_Tem = c("IL7R", "CD44", "S1PR1", "ITGB1", # Effector Memory
                     # Effector molecules often present at low/intermediate levels
                     "IFNG", "GZMK", "GZMA", "CXCR3", "CXCR4", "CCR5"),
      memory_Temra = c("KLRG1", "FCGR3A", "B3GAT1", # B3GAT1 (CD57)
                       "GZMA", "GZMB", "GZMH", "PRF1", "NKG7", # High cytotoxic potential
                       "ZEB2", "TBX21", "EOMES", "S1PR5"), # CD45RA+ Effector Memory
      # --- Regulatory T Cells (조절 T 림프구) ---
      Treg = c("FOXP3", "IL2RA", # IL2RA (CD25 high)
               "CTLA4", "IKZF2", # IKZF2 (Helios)
               "TNFRSF18", # GITR
               "TNFRSF4",  # OX40
               "IL10", "TGFB1", "LAG3", "TIGIT", "STAT5A", "STAT5B")
    ),

    # -------------------------------------------------------------------------
    # CD8+ T Cells (세포독성 T 림프구)
    # -------------------------------------------------------------------------
    cd8_t_cell = list(
      lineage_markers = c("CD8A", "CD8B"),
      naive = c("CCR7", "SELL", "LEF1", "TCF7", "IL7R", "S1PR1", "CD27", "CD28"),
      activation_early = c("CD69", "CD25", "CD38", "HLA-DRA", "FAS", # CD25 is IL2RA
                           "FOS", "JUN", "EGR1", "ICOS"),
      # --- Effector & Cytotoxicity (작동 및 세포 독성) ---
      effector_CTL = c("TBX21", "EOMES", "RUNX3", "ZEB2", # Transcription factors
                       "IFNG", "TNF", "LTA", # Cytokines
                       "CXCR3", "CX3CR1", "KLRD1"), # Chemokine/NK receptors
      cytotoxicity_molecules = c("GZMA", "GZMB", "GZMH", "GZMK", "GZMM", # Granzymes
                                 "PRF1",   # Perforin
                                 "FASLG",  # Fas Ligand
                                 "TNFSF10", # TRAIL
                                 "NKG7", "GNLY", # Granulysin
                                 "LAMP1"), # CD107a (degranulation marker, mRNA may not reflect surface protein well)
      # --- Memory Subtypes (기억 아형) ---
      memory_Tcm = c("CCR7", "SELL", "IL7R", "CD27", "CD28", "TCF7", "LEF1", "EOMES"), # Central Memory
      memory_Tem = c("IL7R", "CD44", "S1PR1", "ITGB1", "EOMES", "TBX21", # Effector Memory
                     "GZMK", "GZMA", "IFNG", "CXCR3", "CX3CR1", "KLRG1" # KLRG1 can be on Tem
                     ),
      memory_Temra = c("KLRG1", "FCGR3A", "B3GAT1", # B3GAT1 (CD57)
                       "GZMA", "GZMB", "GZMH", "PRF1", "NKG7", # High cytotoxic potential
                       "ZEB2", "TBX21", "EOMES", "S1PR5"), # CD45RA+ Effector Memory
      exhaustion_markers = c( # Often associated with chronic activation/memory
                       "PDCD1", "CTLA4", "LAG3", "HAVCR2", # HAVCR2 (TIM-3)
                       "TIGIT", "TOX", "ENTPD1" # ENTPD1 (CD39)
      )
    ),

    # -------------------------------------------------------------------------
    # General T Cell Proliferation & Checkpoints
    # -------------------------------------------------------------------------
    t_cell_proliferation = c("MKI67", "PCNA", "AURKA", "AURKB", "CDK1", "CCNB1", "CCNB2"),
    t_cell_checkpoint_molecules = c( # Co-stimulatory / Co-inhibitory
        "CD28", "ICOS", "CD27", "TNFRSF9", # TNFRSF9 (4-1BB)
        "CD226", # DNAM-1
        "PDCD1", "CTLA4", "LAG3", "HAVCR2", "TIGIT", "BTLA", "CD274", "PDCD1LG2" # CD274 (PD-L1), PDCD1LG2 (PD-L2)
    )
  ),

  # =========================================================================
  # B Cells (B 림프구)
  # =========================================================================
  b_cell_functional_sets = list(
    general_b_cell = list(
      lineage_markers = c("CD19", "MS4A1", # MS4A1 (CD20)
                          "CD79A", "CD79B", "PAX5", "EBF1"),
      bcr_components = c("IGHM", "IGHD", "IGHE", "IGHA1", "IGHA2", "IGHG1", "IGHG2", "IGHG3", "IGHG4",
                         "IGKC", "IGLC1", "IGLC2", "IGLC3", "JCHAIN") # JCHAIN (J chain)
    ),
    naive_b_cell = c("IGHD", "IGHM", "IL4R", "FCER2", # FCER2 (CD23)
                     "TCL1A", "CCR7", "SELL", "CD27" # CD27 typically low/negative
                     ),
    activation_b_cell = c("CD69", "CD80", "CD86", "CD40", "NFKB1", "REL", "FOS", "JUN",
                          "IRF4", "AICDA"), # Activation-Induced Cytidine Deaminase
    memory_b_cell = c("CD27", "AIM2", "BANK1", "MS4A1", # CD27 high
                      # Switched memory typically express IGHG or IGHA
                      "IGHG1", "IGHG2", "IGHG3", "IGHG4", "IGHA1", "IGHA2",
                      "TNFRSF13B", # TACI
                      "SUSD2" # May mark certain memory subsets
                      ),
    atypical_memory_b_cell = c("FCRL4", "FCRL5", "ITGAX", "ZEB2", "TBX21", "CD11C"), # CD11C is ITGAX
    plasmablast_plasma_cell = c("SDC1",   # CD138
                                "PRDM1",  # BLIMP1
                                "XBP1",   # XBP1s (spliced form active)
                                "IRF4",   # MUM1
                                "TNFRSF17", # BCMA
                                "SLAMF7", # CD319
                                "DERL3", "SSR3", "SSR4", # ER protein processing
                                "MZB1", # Marginal zone B and B1 cell specific protein
                                "IGHG1", "IGHG2", "IGHG3", "IGHG4", "IGHA1", "IGHA2", "IGKC", "IGLC2", "JCHAIN" # High Ig secretion
                                )
  ),

  # =========================================================================
  # NK Cells (자연살해 세포)
  # =========================================================================
  nk_cell_functional_sets = list(
    lineage_markers = c("NCR1", "NCR3", "NCAM1", "KLRD1", "FCGR3A", "CD244", # NCAM1 (CD56), KLRD1 (CD94), FCGR3A (CD16A)
                        "IL2RB", "IL15RA"), # Absence of CD3
    activation_nk_cell = c("CD69", "IFNG", "TNF", "XCL1", "XCL2", "CCL3", "CCL4", "CCL5",
                           "LAMP1", # Degranulation marker
                           "STAT1", "STAT4", "TBX21", "EOMES"),
    cytotoxicity_nk_cell = c("GZMA", "GZMB", "GZMH", "GZMK", "PRF1", "GNLY", "FASLG", "TNFSF10",
                             "KLRK1", # NKG2D
                             "KLRC1", "KLRC2", "KLRC3", # NKG2A, NKG2C, NKG2E
                             "KIR2DL1", "KIR2DL3", "KIR3DL1", "KIR3DL2", # Inhibitory KIRs (low expression could mean disinhibition)
                             "KIR2DS1", "KIR2DS4", "KIR3DS1", # Activating KIRs
                             "CD226", # DNAM-1
                             "FCGR3A", # CD16 (ADCC)
                             "HCST" # DAP10 (adapter for activating receptors)
                             ),
    cd56_bright_nk = c("NCAM1", # High CD56
                       "SELL", "CCR7", "IL7R", "CD27", "GATA3", "KIT", # Typically FCGR3A low
                       "IFNG", "TNF" # Strong early cytokine producers
                       ),
    cd56_dim_nk = c("FCGR3A", # High CD16
                    "CX3CR1", "KLRB1", "S1PR5", # KLRB1 (CD161)
                    "TBX21", "ZEB2",
                    "GZMB", "PRF1" # High cytotoxic potential
                    )
  ),

  # =========================================================================
  # Monocytes / Macrophages (단핵구 / 대식세포) - PBMC context
  # =========================================================================
  myeloid_functional_sets = list(
    general_monocyte_macrophage = c("CD14", "CD68", "CSF1R", "ITGAM", "ITGAX", "CD163", "MRC1"), # ITGAM (CD11b), ITGAX (CD11c), MRC1 (CD206)
    classical_monocyte_CD14pp_CD16neg = c("CD14", "CCR2", "S100A8", "S100A9", "S100A12",
                                           "LYZ", "VCAN", "FCN1", "SELL"),
    non_classical_monocyte_CD14p_CD16pp = c("FCGR3A", "CX3CR1", "TCF7L2", "HES4", "CSF1R", "ITGAL"),
    intermediate_monocyte_CD14pp_CD16p = c("CD14", "FCGR3A", "HLA-DRA", "HLA-DRB1", "HLA-DPA1", "HLA-DPB1",
                                            "CCR5", "CD86", "TNF", "IL1B"),
    # --- Activation / Polarization States (more for macrophages, but monocytes can show signatures) ---
    m1_like_activation = c("STAT1", "IRF1", "IRF5", "SOCS3",
                           "TNF", "IL1B", "IL6", "IL12A", "IL12B", "IL23A",
                           "CXCL9", "CXCL10", "CXCL11", "CCL5",
                           "NOS2", # iNOS
                           "CD80", "CD86", "CD40", "FCGR1A"), # FCGR1A (CD64)
    m2_like_activation = c("STAT6", "IRF4", "MAF", "MAFB", "KLF4", "PPAR gamma (PPARG)",
                           "IL10", "TGFB1", "CCL13", "CCL17", "CCL18", "CCL22", "CCL24",
                           "ARG1",   # Arginase 1
                           "MRC1",   # CD206 (Mannose Receptor C-Type 1)
                           "CD163",
                           "CLEC7A", # Dectin-1
                           "FOLR2"   # Folate Receptor Beta
                           ),
    phagocytosis_related = c("FCGR1A", "FCGR2A", "FCGR3A", "MARCO", "MSR1", "CD36", "TREM2", "SIRPA")
  ),

  # =========================================================================
  # Dendritic Cells (DC, 수지상세포) - PBMC context
  # =========================================================================
  dc_functional_sets = list(
    general_dc_lineage = c("ITGAX", "HLA-DRA", "HLA-DRB1", "HLA-DPA1", "HLA-DPB1", "FLT3"), # ITGAX (CD11c)
    # --- Conventional DC type 1 (cDC1) ---
    cDC1 = c("CLEC9A", "XCR1", "CADM1", "BATF3", "IRF8", "ID2",
             "WDFY4", "THBD"), # THBD (CD141)
    cDC1_function = c("IL12B", "IFNL1", "CCL5", "CXCL9", "CXCL10"), # Cross-presentation, Th1 polarization
    # --- Conventional DC type 2 (cDC2) ---
    cDC2 = c("CD1C", "FCER1A", "CLEC10A", "SIRPA", "IRF4", "CEBPB",
             "NOTCH2", "HLA-DQA1", "HLA-DQB1"), # CLEC10A (CD301)
    cDC2_function = c("IL1B", "IL6", "IL23A", "CCL17", "CCL22", "CXCL8", "AREG"), # Th2/Th17 polarization
    # --- Plasmacytoid DC (pDC) ---
    pDC = c("CLEC4C", "NRP1", # CLEC4C (CD303), NRP1 (CD304/BDCA-2)
            "LILRA4", # ILT7 (CD85g)
            "TLR7", "TLR9", "IRF7", "TCF4", # TCF4 (E2-2)
            "IL3RA", # CD123
            "GZMB" # some pDCs can express GZMB
            ),
    pDC_function = c("IFNA1", "IFNA2", "IFNB1", "IFNK", # High Type I IFN production
                     "CXCL10", "TRAIL"), # TRAIL is TNFSF10
    # --- General DC Activation ---
    dc_activation = c("CD40", "CD80", "CD83", "CD86", "CCR7", "LAMP3", # LAMP3 (DC-LAMP)
                      "IRF1", "RELB", "NFKB2", "STAT1", "SOCS1", "SOCS3",
                      "TNF", "IL6", "IL12B") # IL12B for mature cDCs
  ),

  # =========================================================================
  # General Proliferation Markers (모든 세포 유형에 적용 가능)
  # =========================================================================
  general_proliferation = c(
    "MKI67",  # Ki-67
    "PCNA",   # Proliferating Cell Nuclear Antigen
    "TOP2A",  # Topoisomerase II Alpha
    "CDK1",   # Cyclin Dependent Kinase 1
    "CCNB1", "CCNB2", # Cyclin B1, B2
    "AURKA", "AURKB"  # Aurora Kinase A, B
  )
)

# 사용 예시:
# print(immune_cell_functional_gene_sets$t_cell_functional_sets$cd4_t_cell$effector_Th1)
# print(immune_cell_functional_gene_sets$b_cell_functional_sets$plasmablast_plasma_cell)
# print(immune_cell_functional_gene_sets$nk_cell_functional_sets$cytotoxicity_nk_cell)
# print(immune_cell_functional_gene_sets$myeloid_functional_sets$m1_like_activation)
```

#2
```{r}
stress_response_rna_signatures <- list(
  # --- T Cells ---
  t_cell_damp_response_rna = c( # TLR, RAGE, P2X7R 등 DAMP 수용체 경로 활성화 시
    "NFKBIA", "TNF", "IFNG", "IL2", "IL17A", "IL2RA", # NFKBIA는 IkappaBalpha, 피드백
    "FOS", "JUN", "EGR1", "EGR2", # AP-1 및 초기 반응 유전자
    "CCL2", "CCL3", "CCL4", "CCL5", "CXCL10", # 케모카인
    "TNFRSF9", "TNFRSF18", "ICOSLG", # 공동자극/조절 분자
    "TBX21", "GATA3", "RORC", "FOXP3", # 아형 결정 전사인자 (만성 자극 시 변화)
    "MYD88", "TICAM1", "IRF1", "IRF4", "IRF5" # 신호 전달 어댑터 및 IRF (발현 증가 가능)
  ),
  t_cell_hypoxia_response_rna = c( # HIF-1alpha, HIF-2alpha 경로 활성화 시
    "HIF1A", "EPAS1", # HIF1A/EPAS1 mRNA 자체도 일부 조건에서 증가 가능
    "SLC2A1", "SLC2A3", "PGK1", "LDHA", "ENO1", # 해당과정 효소
    "VEGFA", "ADM", # 혈관신생/보호 인자
    "CXCR4", "CCL20", # 케모카인 수용체 및 리간드
    "FOXP3", "RORC", # Treg/Th17 분화 관련 (HIF 의존적 증가)
    "BNIP3", "BNIP3L", # 미토파지/세포사멸
    "IL1B", "IL10" # 사이토카인 (일부 조건)
  ),
  t_cell_oxidative_stress_response_rna = c( # Nrf2, AP-1, NF-kB 등 경로 활성화 시
    "HMOX1", "SOD1", "SOD2", "CAT", "GCLC", "GSR", "TXN", "PRDX1", # 항산화 효소
    "NFE2L2", # Nrf2 (피드백으로 자체 발현 증가 가능)
    "FOS", "JUN", "ATF3", "ATF4", # AP-1 및 스트레스 반응 전사인자
    "NFKBIA", "TNF", "IL6", # 염증 반응
    "CDKN1A", # p21 (세포 주기 정지)
    "GADD45A", "GADD45B", # DNA 손상 반응
    "FOXO1", "FOXO3" # 전사 인자 (mRNA 레벨 변화 가능)
  ),

  # --- B Cells ---
  b_cell_damp_response_rna = c( # 주로 TLR7/9 경로 활성화 시
    "NFKBIA", "TNF", "IL6", "IL10", "IFNA1", "IFNB1", # 사이토카인 (IFNs는 pDC 유사 반응 시)
    "CD69", "CD80", "CD86", "ICOSLG", # 활성화 및 공동자극 분자
    "FOS", "JUN", "EGR1",
    "IRF4", "IRF5", "IRF7", "MYD88", "TLR7", "TLR9", # 신호 전달 및 전사인자 (발현 증가 가능)
    "AICDA", # AID (항체 유전자 변이)
    "XBP1", "PRDM1", "ERN1", # 형질세포 분화 관련 (만성/강한 자극)
    "CCL3", "CCL4", "CXCL10" # 케모카인
  ),
  b_cell_hypoxia_response_rna = c(
    "HIF1A", "EPAS1",
    "SLC2A1", "PGK1", "LDHA", # 해당과정
    "VEGFA", "CXCR4",
    "XBP1", "PRDM1", # 형질세포 생존/기능
    "BNIP3"
  ),
  b_cell_oxidative_stress_response_rna = c(
    "HMOX1", "SOD1", "SOD2", "GCLC", "GSR", "TXNRD1",
    "NFE2L2",
    "FOS", "JUN", "ATF4",
    "NFKBIA", "IL6",
    "CDKN1A",
    "FOXO1"
  ),

  # --- NK Cells ---
  nk_cell_damp_response_rna = c( # TLRs 및 사이토카인 수용체 경로 활성화 시
    "IFNG", "TNF", "CSF2", "XCL1", "CCL3", "CCL4", "CCL5", # 사이토카인/케모카인
    "CD69", "ICOSLG", "TNFSF10", # TNFSF10 (TRAIL)
    "GZMB", "PRF1", "GNLY", "FASLG", # 세포독성 분자 (전사 증가)
    "TBX21", "EOMES", "IRF1", "IRF8", "STAT1", "STAT4", # 전사인자 (발현 증가 또는 표적)
    "MYD88", "TLR2", "TLR7", "TLR9" # 신호 전달 (발현 증가 가능)
  ),
  nk_cell_hypoxia_response_rna = c(
    "HIF1A", "EPAS1",
    "SLC2A1", "LDHA", "VEGFA",
    "CXCR4", "CXCL12", # CXCL12은 HIF1A 표적
    "GZMB", "PRF1", # 저산소증에 의해 조절될 수 있음 (맥락 의존적)
    "BNIP3"
  ),
  nk_cell_oxidative_stress_response_rna = c(
    "HMOX1", "SOD2", "TXN",
    "NFE2L2",
    "FOS", "JUN", "ATF3",
    "NFKBIA", "IFNG", # 산화 스트레스가 IFNG 생산 조절
    "CDKN1A"
  ),

  # --- Monocytes/Macrophages ---
  mono_macro_damp_response_rna = c( # TLRs, NLRs, RLRs, RAGE 등 다양한 PRR 경로
    "TNF", "IL1B", "IL6", "IL10", "IL12B", "IL18", "IFNB1", "CSF1", "CSF2", # 사이토카인 (매우 다양)
    "CCL2", "CCL3", "CCL4", "CCL5", "CXCL1", "CXCL2", "CXCL8", "CXCL9", "CXCL10", # 케모카인 (매우 다양)
    "CD40", "CD80", "CD86", "ICOSLG", "TNFSF9", # 공동자극/조절
    "NFKBIA", "FOS", "JUN", "EGR1", "ATF3",
    "IRF1", "IRF5", "IRF7", "IRF8",
    "MYD88", "TICAM1", "NLRP3", "PYCARD", "CASP1", # 신호 전달/인플라마좀 (발현 증가 가능)
    "PTGS2", # COX2
    "IDO1", "SOCS1", "SOCS3" # 면역 조절/피드백
  ),
  mono_macro_hypoxia_response_rna = c(
    "HIF1A", "EPAS1",
    "SLC2A1", "LDHA", "PGK1", "PFKFB3", # 해당과정
    "VEGFA", "ADM", "ANGPTL4",
    "CCL2", "CXCL8", "CXCR4",
    "IL1B", "TNF", # HIF1A에 의해 유도
    "NOS2", "ARG1", # M1/M2 분극화 관련 (NOS2는 iNOS)
    "BNIP3", "DDIT4", # DDIT4 (REDD1)
    "EGLN1", "EGLN3" # PHD2, PHD3 (HIF 조절 인자, 피드백 가능)
  ),
  mono_macro_oxidative_stress_response_rna = c(
    "HMOX1", "SOD2", "CAT", "GPX1", "GSR", "GCLC", "TXNIP",
    "NFE2L2",
    "FOS", "JUN", "ATF3", "ATF4", "MAF",
    "NFKBIA", "IL1B", "TNF", "IL6",
    "PTGS2",
    "CDKN1A",
    "CYBB", "NCF1", "NCF2" # NOX 복합체 구성요소 (ROS 생산 관련, 발현 조절 가능성)
  ),

  # --- Dendritic Cells ---
  dc_damp_response_rna = c( # PRR 경로 (cDC1, cDC2, pDC 아형에 따라 패턴 다름)
    # 공통적 또는 cDC1/cDC2
    "TNF", "IL1B", "IL6", "IL12B", "IL23A", # 사이토카인
    "CCL3", "CCL4", "CCL5", "CCL17", "CCL22", "CXCL9", "CXCL10", # 케모카인
    "CD40", "CD80", "CD83", "CD86", "ICOSLG", "TNFSF4", # 공동자극/성숙 마커 (TNFSF4는 OX40L)
    "CCR7", "LAMP3", # 성숙/이동
    "NFKBIA", "RELB", "FOS", "JUN", "EGR1",
    "IRF1", "IRF4", "IRF8",
    "MYD88", "TICAM1", "TLR2", "TLR3", "TLR4",
    # pDC 특이적 (TLR7/9 활성화 시)
    "IFNA1", "IFNA2", "IFNB1", "IFNK", # 제1형 인터페론
    "IRF7", "TCF4", "STAT1", "STAT2", # TCF4는 E2-2
    "TLR7", "TLR9" # (발현 증가 가능)
  ),
  dc_hypoxia_response_rna = c(
    "HIF1A", "EPAS1",
    "SLC2A1", "LDHA", "VEGFA",
    "CCR7", "CXCR4",
    "IL1B", "IL6", # HIF1A 의존적 분비
    "BNIP3"
  ),
  dc_oxidative_stress_response_rna = c(
    "HMOX1", "SOD2", "GSR",
    "NFE2L2",
    "FOS", "JUN", "ATF3",
    "NFKBIA", "IL6", "TNF",
    "CDKN1A",
    "CD83", "CD86" # 산화 스트레스에 의한 성숙 조절
  )
)

# 사용 예시:
# print(stress_response_rna_signatures$t_cell_damp_response_rna)
# print(stress_response_rna_signatures$mono_macro_hypoxia_response_rna)
```

#3 lmm execution ver 2
```{r}
my_config <- create_analysis_config(
    patient_col = "emrid",      # 환자 ID 컬럼
    drug_col = "drug",           # infliximab/ustekinumab/vedolizumab
    timepoint_col = "treatment",           # pre/post
    ck_col = "ck",                 # CK+/CK-
    response_col = "H3",   # mucosal_healing/histopath/endoscopic/deep
    aoi_col = "SegmentDisplayName"               # AOI 식별자
)
# CK+ 분석
seurat_ck_pos <- dsfh_ck

# CK- 분석  
seurat_ck_neg <- dsfh_str

# pre vs post 비교로 스크리닝
screening_pos <- quick_screen_genes(
  seurat_ck_pos,
  config = my_config,
  comparison_type = "pre_post",  # "pre_post" 또는 "drug", "response", "combined"
  top_n = 1000  # 상위 1000개 유전자 선택
)

# 선택된 유전자 확인
top_genes <- screening_pos$top_genes

# 간단한 모델부터 시작 (수렴 문제 방지)
simple_formula <- list(
  fixed = c("drug"), 
  random = "(1|patient)"
)
simple_formula <- list(
  fixed = c("timepoint"), 
  random = "(1|patient)"
)
simple_formula <- list(
  fixed = c("drug", "timepoint"),
  interactions = c("drug:timepoint"),  # 최소한의 상호작용
  random = "(1|patient)"
)
simple_formula <- list(
  fixed = c("treatment", "time"),
  interactions = c("treatment:time"),  # 최소한의 상호작용
  random = "(1|patient_id)"
)
simple_formula <- list(
  fixed = c("treatment", "time", "healing_level"),
  interactions = c("treatment:time"),  # 최소한의 상호작용
  random = "(1|patient_id)"
)

# LMM 실행
lmm_results <- run_lmm_multiple_genes(
  seurat_ck_pos,
  genes = top_genes[1:500],  # 먼저 500개로 테스트
  config = my_config,
  formula_components = simple_formula,
  n_cores = 8
)

# 수렴 확인
print(sprintf("%d/%d models converged", 
              lmm_results$converged_genes, 
              lmm_results$total_genes))


# outside
formula_components=simple_formula # config=my_config, genes, seurat_obj
gene=top_genes[1]
# in RLMG
expr_mt=GetAssayData(seurat_ck_pos,layer="data")
metadata=seurat_ck_pos@meta.data
gene_expr=as.numeric(expr_mt[gene,])

# in FLSG
df=cbind(data.frame(Expression=gene_expr),metadata)

fixed_effects=c(formula_components$fixed)
formula_str=paste0("Expression ~ ",
                   paste(fixed_effects, collapse=" + "),
                   " + ",
                   formula_components$random)
model=lmer(as.formula(formula_str), data=df, REML = FALSE) #not working
model=lmer(Expression ~ treatment + (1|emrid), data=df, REML=FALSE) # working

# working
lmm_results=fit_lmm_single_gene(gene_expr, seurat_ck_pos@meta.data, config=my_config)
lmm_results_=run_lmm_multiple_genes(seurat_ck_pos, top_genes, my_config)

lmm_summary=summarize_lmm_results(lmm_results_$raw_results, my_config) 
# not working
infliximab_response=find_response_differential_genes(lmm_summary, my_config, "Infliximab", 50)
Ustekinumab_response=find_response_differential_genes(lmm_summary, my_config, "Ustekinumab", 50)

# Infliximab is the control...
interaction_term=paste0("Infliximab",":",my_config$response)
# working
interaction_term=paste0("Ustekinumab",":",my_config$response)
top_genes_=lmm_summary%>%
  filter(grepl(interaction_term,term))%>%
  group_by(gene)%>%
  dplyr::summarize(
    max_effect=max(abs(estimate)),
    min_p=min(p_value),
    min_p_adj=min(p_adj)
  )%>%
  arrange(desc(max_effect)) %>%
  head(50)

drug_specific <- find_drug_specific_genes(
  lmm_summary,
  config = my_config,
  response_subset = "H3",  # 특정 반응군만 보려면
  top_n = 50
)

interaction_genes <- find_interaction_genes(
  lmm_summary,
  config = my_config,
  interaction_type = "drug_response",
  top_n = 50
)

for (gene in drug_specific$gene[1:5]) {
  p <- plot_pre_post_boxplot(
    seurat_ck_pos,
    gene = gene,
    config = my_config,
    split_by = c("treatment", "healing_level")  # 실제 컬럼명
  )
  print(p)
}

# 화산도
plot_volcano(
  lmm_summary,
  term_pattern = "drug",  # 약물 효과
  title = "Drug Effects in CK+ cells"
)
```

#4 ver2

## prepare
```{r}
library(tidyverse)
library(Seurat)
library(lme4)
library(lmerTest)
library(emmeans)
library(parallel)
library(broom.mixed)
library(ggpubr)
library(pheatmap)
library(viridis)

# ========================================
# PART 1: 데이터 준비 및 설정
# ========================================

#' 분석 설정 클래스 - 모든 변수명을 여기서 관리
create_analysis_config <- function(
  patient_col = "patient_id",
  drug_col = "drug", 
  timepoint_col = "timepoint",
  ck_col = "ck_status",
  response_col = "response",
  aoi_col = "aoi_id"
) {
  list(
    patient = patient_col,
    drug = drug_col,
    timepoint = timepoint_col,
    ck = ck_col,
    response = response_col,
    aoi = aoi_col
  )
}

#' GeoMx 데이터 준비 (Excel/CSV에서 읽기)
#' @param count_file 발현값 파일 경로
#' @param metadata_file 메타데이터 파일 경로  
#' @param config 변수명 설정
prepare_geomx_data <- function(count_file = NULL, 
                              metadata_file = NULL,
                              count_matrix = NULL,
                              metadata = NULL,
                              config = create_analysis_config(),
                              q3_normalize = TRUE) {
  
  # 파일에서 읽기 또는 직접 입력
  if (!is.null(count_file)) {
    if (grepl("\\.xlsx$", count_file)) {
      count_matrix <- openxlsx::read.xlsx(count_file, sheet = 1, rowNames = TRUE)
    } else {
      count_matrix <- read.csv(count_file, row.names = 1)
    }
  }
  
  if (!is.null(metadata_file)) {
    if (grepl("\\.xlsx$", metadata_file)) {
      metadata <- openxlsx::read.xlsx(metadata_file, sheet = 2)
    } else {
      metadata <- read.csv(metadata_file)
    }
  }
  
  # AOI 이름 매칭
  rownames(metadata) <- metadata[[config$aoi]]
  
  # Seurat 객체 생성
  seurat_obj <- CreateSeuratObject(
    counts = as.matrix(count_matrix),
    meta.data = metadata,
    min.cells = 0,
    min.features = 0
  )
  
  # Q3 정규화는 이미 되어있다고 가정
  if (!q3_normalize) {
    seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize")
  }
  
  # 조합 변수 생성 (빠른 스크리닝용)
  seurat_obj$condition_full <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]], "_", 
    seurat_obj@meta.data[[config$response]]
  )
  
  seurat_obj$condition_simple <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]]
  )
  
  return(seurat_obj)
}
```

## quick_screen_genes: using FindAllMarkers
```{r}
# ========================================
# PART 2: 빠른 스크리닝 (Wilcoxon)
# ========================================

#' Step 1: 빠른 유전자 스크리닝
#' @param seurat_obj Seurat 객체
#' @param config 변수명 설정
#' @param comparison_type "pre_post", "drug", "response", "combined" 중 선택
#' @param ck_subset ck열에서 어떤 값을 가진 aoi만 고를 것인가. 예: "ck+", "TRUE", "positive"
quick_screen_genes <- function(seurat_obj,
                              config = create_analysis_config(),
                              comparison_type = "pre_post",
                              ck_subset = NULL,
                              min_pct = 0.1,
                              logfc_threshold = 0.25,
                              top_n = 1000,
                              use_adj=FALSE) {
  
  # CK 서브셋 필터링
  if (!is.null(ck_subset)) {
    seurat_obj <- subset(seurat_obj, 
                         subset = !!sym(config$ck) == ck_subset)
  }
  
  # 비교 그룹 설정
  if (comparison_type == "pre_post") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$timepoint]]
  } else if (comparison_type == "drug") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$drug]]
  } else if (comparison_type == "response") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$response]]
  } else if (comparison_type == "combined") {
    Idents(seurat_obj) <- seurat_obj$condition_full
  }
  
  # FindAllMarkers 실행
  markers <- FindAllMarkers(
    seurat_obj,
    min.pct = min_pct,
    logfc.threshold = logfc_threshold,
    only.pos = FALSE,
    return.thresh = 1  # 모든 유전자 반환
  )
  
  # 상위 유전자 선택
  if(use_adj){
    top_genes <- markers %>%
    arrange(p_val_adj) %>%
    head(top_n) %>%
    pull(gene) %>%
    unique()
  }else{
    top_genes <- markers %>%
    arrange(p_val) %>%
    head(top_n) %>%
    pull(gene) %>%
    unique()
  }

  
  return(list(
    markers = markers,
    top_genes = top_genes,
    seurat_obj = seurat_obj
  ))
}
```

## LMM
```{r}
# ========================================
# PART 3: Linear Mixed Model 분석
# ========================================

#' Step 2: 단일 유전자 LMM
fit_lmm_single_gene <- function(gene_expr,
                                metadata,
                                config = create_analysis_config(),
                                formula_components = NULL) {
  
  # 기본 formula 구성요소
  if (is.null(formula_components)) {
    formula_components <- list(
      fixed = c(config$drug, config$timepoint, config$response),
      interactions = c(
        paste(config$drug, config$timepoint, sep = ":"),
        paste(config$drug, config$response, sep = ":"),
        paste(config$timepoint, config$response, sep = ":"),
        paste(config$drug, config$timepoint, config$response, sep = ":")
      ),
      random = paste0("(1|", config$patient, ")")
    )
  }
  
  # 데이터프레임 생성
  df <- cbind(
    data.frame(Expression = gene_expr),
    metadata
  )
  
  # Formula 문자열 생성
  fixed_effects <- c(formula_components$fixed, formula_components$interactions)
  formula_str <- paste0(
    "Expression ~ ",
    paste(fixed_effects, collapse = " + "),
    " + ",
    formula_components$random
  )
  
  # 모델 적합
  tryCatch({
    model <- lmer(as.formula(formula_str), data = df, REML = FALSE)
    
    # 결과 추출
    coef_summary <- summary(model)$coefficients
    anova_result <- anova(model)
    
    # 주요 효과 계산
    effects <- data.frame(
      term = rownames(coef_summary),
      estimate = coef_summary[, "Estimate"],
      std_error = coef_summary[, "Std. Error"],
      t_value = coef_summary[, "t value"],
      p_value = coef_summary[, "Pr(>|t|)"]
    )
    
    return(list(
      model = model,
      effects = effects,
      anova = anova_result,
      converged = TRUE,
      formula = formula_str
    ))
    
  }, error = function(e) {
    return(list(
      converged = FALSE,
      error = e$message,
      formula = formula_str
    ))
  })
}
```

# RLMG (Claude)
```{r}
#' Step 3: 다중 유전자 LMM (병렬처리)
run_lmm_multiple_genes <- function(seurat_obj,
                                  genes = NULL,
                                  config = create_analysis_config(),
                                  formula_components = NULL,
                                  n_cores = 4,
                                  verbose = TRUE) {
  
  if (is.null(genes)) {
    genes <- rownames(seurat_obj)[1:100]  # 기본값: 상위 100개
    warning("No genes specified. Using first 100 genes.")
  }
  
  # 발현 매트릭스와 메타데이터 추출
  expr_matrix <- GetAssayData(seurat_obj, slot = "data")
  metadata <- seurat_obj@meta.data
  
  # 진행상황 표시
  if (verbose) {
    message(sprintf("Running LMM for %d genes using %d cores...", 
                   length(genes), n_cores))
  }
  
  # 병렬 처리
  if (n_cores > 1) {
    cl <- makeCluster(n_cores)
    clusterEvalQ(cl, {
      library(lme4)
      library(lmerTest)
    })
    clusterExport(cl, c("fit_lmm_single_gene", "config", "metadata", 
                        "expr_matrix", "formula_components"),
                 envir = environment())
    
    results <- parLapply(cl, genes, function(gene) {
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
    
    stopCluster(cl)
  } else {
    # 순차 처리
    results <- lapply(genes, function(gene) {
      if (verbose && which(genes == gene) %% 100 == 0) {
        message(sprintf("  Processing gene %d/%d", 
                       which(genes == gene), length(genes)))
      }
      
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
  }
  
  names(results) <- genes
  
  # 결과 요약
  summary_df <- summarize_lmm_results(results, config)
  
  return(list(
    raw_results = results,
    summary = summary_df,
    converged_genes = sum(sapply(results, function(x) x$converged)),
    total_genes = length(genes)
  ))
}

#' LMM 결과 요약
summarize_lmm_results <- function(lmm_results, config) {
  # 수렴한 모델만 처리
  converged <- lmm_results[sapply(lmm_results, function(x) x$converged)]
  
  if (length(converged) == 0) {
    warning("No models converged!")
    return(NULL)
  }
  
  # 모든 효과 수집
  all_effects <- do.call(rbind, lapply(names(converged), function(gene) {
    effects <- converged[[gene]]$effects
    effects$gene <- gene
    return(effects)
  }))
  
  # p-value 보정
  all_effects <- all_effects %>%
    group_by(term) %>%
    mutate(
      p_adj = p.adjust(p_value, method = "BH"),
      significant = p_adj < 0.05
    ) %>%
    ungroup()
  
  return(all_effects)
}

# ========================================
# PART 4: 특정 질문 분석
# ========================================

#' 질문 iv) 약물별 R/NR 효과가 큰 유전자
find_response_differential_genes <- function(lmm_summary,
                                            config,
                                            drug_name,
                                            top_n = 50) {
  
  # Drug:Response 상호작용 항 찾기
  interaction_term <- paste0(drug_name, ":", config$response)
  
  top_genes <- lmm_summary %>%
    filter(grepl(interaction_term, term)) %>%
    group_by(gene) %>%
    dplyr::summarize(
      max_effect = max(abs(estimate)),
      min_p = min(p_value),
      min_p_adj = min(p_adj)
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 v) 약물 특이적 유전자
find_drug_specific_genes <- function(lmm_summary,
                                    config,
                                    response_subset = NULL,
                                    top_n = 50) {
  
  # Drug 주효과 및 상호작용
  drug_terms <- lmm_summary %>%
    filter(grepl(config$drug, term))
  
  if (!is.null(response_subset)) {
    drug_terms <- drug_terms %>%
      filter(grepl(response_subset, term))
  }
  
  top_genes <- drug_terms %>%
    group_by(gene) %>%
    dplyr::summarize(
      mean_effect = mean(abs(estimate)),
      max_effect = max(abs(estimate)),
      n_significant = sum(significant)
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 vi) Drug x Response 상호작용
find_interaction_genes <- function(lmm_summary,
                                  config,
                                  interaction_type = "drug_response",
                                  top_n = 50) {
  
  if (interaction_type == "drug_response") {
    pattern <- paste0(config$drug, ".*:", ".*", config$response)
  } else if (interaction_type == "drug_time") {
    pattern <- paste0(config$drug, ".*:", ".*", config$timepoint)
  } else if (interaction_type == "triple") {
    pattern <- paste0(config$drug, ".*:", ".*", 
                     config$timepoint, ".*:", ".*", config$response)
  }
  
  interaction_genes <- lmm_summary %>%
    filter(grepl(pattern, term)) %>%
    group_by(gene) %>%
    dplyr::summarize(
      interaction_strength = max(abs(estimate)),
      min_p_adj = min(p_adj),
      n_sig_terms = sum(significant)
    ) %>%
    arrange(desc(interaction_strength)) %>%
    head(top_n)
  
  return(interaction_genes)
}

# ========================================
# PART 5: 시각화
# ========================================

#' Pre-Post 변화 박스플롯
plot_pre_post_boxplot <- function(seurat_obj,
                                  gene,
                                  config,
                                  split_by = NULL) {
  
  # 데이터 준비
  df <- data.frame(
    Expression = GetAssayData(seurat_obj)[gene, ],
    seurat_obj@meta.data
  )
  
  # 기본 플롯
  p <- ggplot(df, aes_string(x = config$timepoint, y = "Expression")) +
    geom_boxplot(aes_string(fill = config$timepoint), alpha = 0.7) +
    geom_point(position = position_jitterdodge(0.2), alpha = 0.5) +
    stat_compare_means(paired = TRUE, method = "wilcox.test") +
    labs(title = paste("Expression Changes:", gene),
         y = "Normalized Expression",
         x = "Timepoint") +
    theme_bw()
  
  # 분할 옵션
  if (!is.null(split_by)) {
    if (length(split_by) == 1) {
      p <- p + facet_wrap(as.formula(paste("~", split_by)))
    } else if (length(split_by) == 2) {
      p <- p + facet_grid(as.formula(paste(split_by[1], "~", split_by[2])))
    }
  }
  
  return(p)
}

#' 효과 크기 화산도
plot_volcano <- function(lmm_summary,
                        term_pattern = NULL,
                        title = "Volcano Plot",
                        effect_threshold = 0.5,
                        p_threshold = 0.05) {
  
  plot_data <- lmm_summary
  
  if (!is.null(term_pattern)) {
    plot_data <- plot_data %>%
      filter(grepl(term_pattern, term))
  }
  
  plot_data <- plot_data %>%
    mutate(
      log_p = -log10(p_value),
      category = case_when(
        abs(estimate) > effect_threshold & p_adj < p_threshold ~ "Significant",
        abs(estimate) > effect_threshold ~ "Large effect",
        p_adj < p_threshold ~ "Small effect",
        TRUE ~ "Not significant"
      )
    )
  
  ggplot(plot_data, aes(x = estimate, y = log_p, color = category)) +
    geom_point(alpha = 0.6) +
    geom_hline(yintercept = -log10(p_threshold), 
               linetype = "dashed", color = "gray") +
    geom_vline(xintercept = c(-effect_threshold, effect_threshold), 
               linetype = "dashed", color = "gray") +
    scale_color_manual(values = c("Significant" = "red",
                                 "Large effect" = "orange", 
                                 "Small effect" = "blue",
                                 "Not significant" = "gray")) +
    labs(title = title,
         x = "Effect Size (Estimate)",
         y = "-log10(p-value)") +
    theme_bw()
}

# ========================================
# PART 6: 완전한 워크플로우
# ========================================

#' 전체 분석 워크플로우
run_complete_workflow <- function(
  count_data,      # 매트릭스 또는 파일 경로
  metadata,        # 데이터프레임 또는 파일 경로
  config = create_analysis_config(),
  output_dir = "./results",
  n_cores = 4
) {
  
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  
  # ===== STEP 1: 데이터 준비 =====
  message("Step 1: Preparing data...")
  
  if (is.character(count_data)) {
    seurat_obj <- prepare_geomx_data(
      count_file = count_data,
      metadata_file = metadata,
      config = config
    )
  } else {
    seurat_obj <- prepare_geomx_data(
      count_matrix = count_data,
      metadata = metadata,
      config = config
    )
  }
  
  message(sprintf("  Loaded %d genes x %d AOIs", 
                 nrow(seurat_obj), ncol(seurat_obj)))
  
  # ===== STEP 2: CK별 분리 =====
  message("Step 2: Separating by CK status...")
  
  ck_values <- unique(seurat_obj@meta.data[[config$ck]])
  message(sprintf("  Found CK groups: %s", paste(ck_values, collapse = ", ")))
  
  results_by_ck <- list()
  
  for (ck_val in ck_values) {
    message(sprintf("\n=== Analyzing %s ===", ck_val))
    
    # CK 서브셋
    seurat_ck <- subset(seurat_obj, 
                        subset = !!sym(config$ck) == ck_val)
    
    # ===== STEP 3: 빠른 스크리닝 =====
    message("Step 3: Quick screening with Wilcoxon test...")
    
    screen_results <- quick_screen_genes(
      seurat_ck,
      config = config,
      comparison_type = "combined",
      top_n = 1000
    )
    
    message(sprintf("  Selected top %d genes", 
                   length(screen_results$top_genes)))
    
    # ===== STEP 4: LMM 분석 =====
    message("Step 4: Running Linear Mixed Models...")
    
    # 간단한 모델부터 시작
    simple_formula <- list(
      fixed = c(config$drug, config$timepoint, config$response),
      interactions = c(paste(config$drug, config$timepoint, sep = ":")),
      random = paste0("(1|", config$patient, ")")
    )
    
    lmm_results <- run_lmm_multiple_genes(
      seurat_ck,
      genes = screen_results$top_genes,
      config = config,
      formula_components = simple_formula,
      n_cores = n_cores
    )
    
    message(sprintf("  %d/%d models converged", 
                   lmm_results$converged_genes,
                   lmm_results$total_genes))
    
    # ===== STEP 5: 특정 분석 =====
    message("Step 5: Analyzing specific questions...")
    
    # 약물별 분석
    drugs <- unique(seurat_ck@meta.data[[config$drug]])
    drug_response_effects <- list()
    
    for (drug in drugs) {
      drug_response_effects[[drug]] <- find_response_differential_genes(
        lmm_results$summary,
        config,
        drug_name = drug,
        top_n = 30
      )
    }
    
    # Drug-specific genes
    drug_specific <- find_drug_specific_genes(
      lmm_results$summary,
      config,
      top_n = 50
    )
    
    # Interaction genes
    interaction_genes <- find_interaction_genes(
      lmm_results$summary,
      config,
      interaction_type = "drug_response",
      top_n = 50
    )
    
    # ===== STEP 6: 결과 저장 =====
    results_by_ck[[ck_val]] <- list(
      seurat_obj = seurat_ck,
      screening = screen_results,
      lmm = lmm_results,
      drug_response_effects = drug_response_effects,
      drug_specific = drug_specific,
      interaction_genes = interaction_genes
    )
    
    # CSV 저장
    write.csv(drug_specific,
             file.path(output_dir, paste0("drug_specific_", ck_val, ".csv")),
             row.names = FALSE)
    
    write.csv(interaction_genes,
             file.path(output_dir, paste0("interaction_genes_", ck_val, ".csv")),
             row.names = FALSE)
    
    # ===== STEP 7: 시각화 =====
    message("Step 6: Creating visualizations...")
    
    # Top 5 유전자 플롯
    top_genes_to_plot <- drug_specific$gene[1:min(5, nrow(drug_specific))]
    
    pdf(file.path(output_dir, paste0("plots_", ck_val, ".pdf")), 
        width = 12, height = 8)
    
    for (gene in top_genes_to_plot) {
      p <- plot_pre_post_boxplot(
        seurat_ck,
        gene = gene,
        config = config,
        split_by = c(config$drug, config$response)
      )
      print(p)
    }
    
    # 화산도
    p_volcano <- plot_volcano(
      lmm_results$summary,
      term_pattern = config$drug,
      title = paste("Drug Effects -", ck_val)
    )
    print(p_volcano)
    
    dev.off()
  }
  
  # 전체 결과 저장
  saveRDS(results_by_ck, 
          file.path(output_dir, "complete_results.rds"))
  
  message("\n=== Analysis Complete ===")
  message(sprintf("Results saved to: %s", output_dir))
  
  return(results_by_ck)
}

# ========================================
# 사용 예시
# ========================================

# 1. 설정 정의 (실제 컬럼명에 맞게)
my_config <- create_analysis_config(
  patient_col = "patient_id",      # 실제 환자 ID 컬럼명
  drug_col = "treatment",           # 약물 컬럼명 
  timepoint_col = "time",           # pre/post 컬럼명
  ck_col = "panck",                 # CK+/- 컬럼명
  response_col = "healing_level",   # 반응 컬럼명
  aoi_col = "roi_aoi"               # AOI ID 컬럼명
)

# 2. 분석 실행
# results <- run_complete_workflow(
#   count_data = "geomx_counts.xlsx",  # 또는 매트릭스 직접 입력
#   metadata = "geomx_metadata.xlsx",   # 또는 데이터프레임 직접 입력
#   config = my_config,
#   output_dir = "./IBD_analysis_results",
#   n_cores = 8
# )

# 3. 개별 단계 실행 (필요시)
# # 데이터 로드
# seurat_obj <- prepare_geomx_data(
#   count_file = "counts.csv",
#   metadata_file = "metadata.csv", 
#   config = my_config
# )
# 
# # CK+ 만 분석
# seurat_ck_pos <- subset(seurat_obj, panck == "positive")
# 
# # 스크리닝
# screening <- quick_screen_genes(
#   seurat_ck_pos,
#   config = my_config,
#   comparison_type = "pre_post"
# )
# 
# # LMM
# lmm_results <- run_lmm_multiple_genes(
#   seurat_ck_pos,
#   genes = screening$top_genes[1:500],
#   config = my_config,
#   n_cores = 4
# )
```

#5 execution ver 11,14
```{r}
my_config <- create_analysis_config(
    patient = "emrid",      # 환자 ID 컬럼
    drug = "drug",           # infliximab/ustekinumab/vedolizumab
    timepoint = "treatment",           # pre/post
    ck = "ck",                 # CK+/CK-
    response = "H3",   # mucosal_healing/histopath/endoscopic/deep
    aoi = "SegmentDisplayName"               # AOI 식별자
)
# CK+ 분석
seurat_ck_pos <- dsfh_ck
# CK- 분석  
seurat_ck_neg <- dsfh_str


# 방법 1: Config 키워드 사용 (권장)
simple_formula <- list(
  fixed = c("drug", "timepoint"),      # config 키워드
  interactions = c("drug:timepoint"),
  random = "(1|patient)"
)
# # 방법 2: 실제 컬럼명 직접 사용
# simple_formula <- list(
#   fixed = c("drug", "treatment"),      # 실제 컬럼명
#   interactions = c("drug:treatment"),  
#   random = "(1|emrid)"
# )


lmm_results <- run_lmm_multiple_genes(
  seurat_ck_pos,
  genes = top_genes,
  config = my_config,
  formula_components = simple_formula,
  use_config_names = TRUE  # 자동 매핑!
)


# p value 조정 가능해졌다
screening_pos <- quick_screen_genes(
  seurat_ck_pos,
  config = my_config,
  comparison_type = "pre_post",
  use_adj = FALSE,  # p_val 사용 (샘플 수가 적을 때)
  top_n = 3000
)

screening_neg<- quick_screen_genes(
  seurat_ck_neg,
  config = my_config,
  comparison_type = "pre_post",
  use_adj = FALSE,  # p_val 사용 (샘플 수가 적을 때)
  top_n = 3000)

# 5. 간단한 LMM부터 시작
simple_formula <- list(
  fixed = c("timepoint"),
  random = "(1|patient)"
)

lmm_simple <- run_lmm_multiple_genes(
  seurat_ck_pos,
  genes = screening_pos$top_genes[1:100],  # 먼저 적은 수로 테스트
  config = my_config,
  formula_components = simple_formula,
  use_config_names = TRUE,
  n_cores = 1  # 디버깅 시 1코어
)

# 6. 수렴 확인 후 복잡한 모델
if (lmm_simple$converged_genes > 80) {
  complex_formula <- list(
    fixed = c("drug", "timepoint", "response"),
    interactions = c("drug:timepoint", "drug:response"),
    random = "(1|patient)"
  )
  
  lmm_complex <- run_lmm_multiple_genes(
    seurat_ck_pos,
    genes = screening_pos$top_genes,
    config = my_config,
    formula_components = complex_formula,
    use_config_names = TRUE,
    n_cores = 8
  )
  
  lmm_complex2 <- run_lmm_multiple_genes(
    seurat_ck_neg,
    genes = screening_neg$top_genes,
    config = my_config,
    formula_components = complex_formula,
    use_config_names = TRUE,
    n_cores = 8
  )
}

# 7. 결과 분석 (Infliximab reference 자동 처리)
infliximab_effects <- find_response_differential_genes(
  lmm_complex$summary,
  config = my_config,
  drug_name = "Infliximab"  # reference여도 OK
)

# 8. 시각화
plot_volcano(
  lmm_complex$summary,
  term_pattern = "treatment",
  title = "Drug Effects (Infliximab as reference)"
)

lmm_s1=lmm_complex$summary[lmm_complex$summary$term!="(Intercept)",]
lmm_s2=lmm_complex2$summary[lmm_complex2$summary$term!="(Intercept)",]
```

## QSG, LMM makin
```{r}
my_config <- create_analysis_config(patient = "emrid",drug = "drug",timepoint = "treatment",ck = "ck",response = "H3",aoi = "SegmentDisplayName")

complex_formula_all=list(fixed = c("drug", "timepoint", "response"),interactions = c("drug:timepoint", "drug:response"),random = "(1|patient)")
complex_formula1 <- list(fixed = c("drug", "timepoint", "response"),interactions = c("drug:timepoint", "drug:response"),random = "(1|patient)")
complex_formula2 <- list(fixed = c("timepoint", "response"),interactions = c("timepoint:response"),random = "(1|patient)")


qs_all=quick_screen_genes(data_seurat,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_ck=quick_screen_genes(data.ck,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_str=quick_screen_genes(data.str,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_ck_inf=quick_screen_genes(data.ck.inf,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_ck_ust=quick_screen_genes(data.ck.ust,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_ck_ved=quick_screen_genes(data.ck.ved,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_str_inf=quick_screen_genes(data.str.inf,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_str_ust=quick_screen_genes(data.str.ust,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
qs_str_ved=quick_screen_genes(data.str.ved,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)




lmm_all=run_lmm_multiple_genes(data_seurat,genes = qs_all$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm=run_lmm_multiple_genes(data.ck,genes = qs_ck$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm_=run_lmm_multiple_genes(data.str,genes = qs_str$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
# lmm_ust=run_lmm_multiple_genes(data.ck,genes = qs_ck$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm1=run_lmm_multiple_genes(data.ck.inf,genes = qs_ck_inf$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm2=run_lmm_multiple_genes(data.ck.ust,genes = qs_ck_ust$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm3=run_lmm_multiple_genes(data.ck.ved,genes = qs_ck_ved$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm4=run_lmm_multiple_genes(data.str.inf,genes = qs_str_inf$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm5=run_lmm_multiple_genes(data.str.ust,genes = qs_str_ust$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm6=run_lmm_multiple_genes(data.str.ved,genes = qs_str_ved$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()

# 약물별 R/NR 효과가 큰.
lm_1=find_response_differential_genes(lmm$summary,my_config)
# 약물특이적
lm_2=find_drug_specific_genes(lmm$summary,my_config)
# interaction이 큰?
lm_3=find_interaction_genes(lmm$summary,my_config)

# pre-post 박스플롯
box_ck=plot_pre_post_boxplot(data.ck, "IL1B", my_config, split_by="drug")

# VP

vp_ck=plot_volcano(lmm$summary)
vp_ck1=plot_volcano(lmm$summary, term_pattern = "treatmentpre", title="pre-post effect of 3 biologics")
vp_ck2=plot_volcano(lmm$summary, term_pattern = "drugUstekinumab:treatmentpre", title="Infliximab vs Ust in pre-post effect")
vp_ck3=plot_volcano(lmm$summary, term_pattern = "drugVedolizumab:treatmentpre", title="Infliximab Ust Ved in pre-post effect")
vp_ck4=plot_volcano(lmm_$summary, term_pattern = "treatmentpre")


pre_inf_vs_others=FindMarkers(data.pre, ident.1 = "Infliximab",group.by="drug")
pre_ck_inf_vs_others=FindMarkers(data.ck.pre, ident.1 = "Infliximab",group.by="drug")
pre_str_inf_vs_others=FindMarkers(data.str.pre, ident.1 = "Infliximab",group.by="drug")

vp_ck5=plot_volcano(pre_inf_vs_others, x_col = "avg_log2FC", y_col="p_val", title="in pre, inf vs others")
vp_ck6=plot_volcano(pre_ck_inf_vs_others, x_col = "avg_log2FC", y_col="p_val", title="in pre ck+, inf vs others")
vp_ck7=plot_volcano(pre_str_inf_vs_others, x_col = "avg_log2FC", y_col="p_val", title="in pre ck_, inf vs others")


```


# 시도들!!! Lmm filtering, upset plot
```{r}

m.ck.pre=lmm$summary%>%filter(term=="treatmentpre" & significant)
m.str.pre=lmm_$summary%>%filter(term=="treatmentpre" & significant)
m.ck.inf.pre=lmm1$summary%>%filter(term=="treatmentpre" & significant)
m.ck.ust.pre=lmm2$summary%>%filter(term=="treatmentpre" & significant)
m.ck.ved.pre=lmm3$summary%>%filter(term=="treatmentpre" & significant)
m.str.inf.pre=lmm4$summary%>%filter(term=="treatmentpre" & significant)
m.str.ust.pre=lmm5$summary%>%filter(term=="treatmentpre" & significant)
m.str.ved.pre=lmm6$summary%>%filter(term=="treatmentpre" & significant)

m.ck.pre2=lmm$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.str.pre2=lmm_$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.ck.inf.pre2=lmm1$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.ck.ust.pre2=lmm2$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.ck.ved.pre2=lmm3$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.str.inf.pre2=lmm4$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.str.ust.pre2=lmm5$summary%>%filter(term=="treatmentpre" & p_value<0.05)
m.str.ved.pre2=lmm6$summary%>%filter(term=="treatmentpre" & p_value<0.05)

# 
up_ck_pre1=upset_gene_lists(list(inf=m.ck.inf.pre$gene,ust=m.ck.ust.pre$gene, ved=m.ck.ved.pre$gene))
up_str_pre1=upset_gene_lists(list(inf=m.str.inf.pre$gene,ust=m.str.ust.pre$gene, ved=m.str.ved.pre$gene))
up_ck_pre1a=upset_gene_lists(list(all=m.ck.pre$gene,inf=m.ck.inf.pre$gene,ust=m.ck.ust.pre$gene, ved=m.ck.ved.pre$gene))
up_str_pre1a=upset_gene_lists(list(all=m.str.pre$gene,inf=m.str.inf.pre$gene,ust=m.str.ust.pre$gene, ved=m.str.ved.pre$gene))

up_ck_pre2=upset_gene_lists(list(inf=m.ck.inf.pre2$gene,ust=m.ck.ust.pre2$gene, ved=m.ck.ved.pre2$gene))
up_str_pre2=upset_gene_lists(list(inf=m.str.inf.pre2$gene,ust=m.str.ust.pre2$gene, ved=m.str.ved.pre2$gene))
up_ck_pre2a=upset_gene_lists(list(all=m.ck.pre2$gene,inf=m.ck.inf.pre2$gene,ust=m.ck.ust.pre2$gene, ved=m.ck.ved.pre2$gene))
up_str_pre2a=upset_gene_lists(list(all=m.str.pre2$gene,inf=m.str.inf.pre2$gene,ust=m.str.ust.pre2$gene, ved=m.str.ved.pre2$gene))

up_ck_pre1
up_str_pre1
up_ck_pre1a
up_str_pre1a
up_ck_pre2
up_str_pre2
up_ck_pre2a
up_str_pre2a

m.pp.ck1=m.pp.ck%>% marker_filter%>% filter(p_val<0.05)
m.pp.ck.inf1=m.pp.ck.inf%>% marker_filter %>% filter(p_val<0.05)
m.pp.ck.ust1=m.pp.ck.ust%>% marker_filter%>% filter(p_val<0.05)
m.pp.ck.ved1=m.pp.ck.ved%>% marker_filter%>% filter(p_val<0.05)

m.pp.str1=m.pp.str%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.inf1=m.pp.str.inf%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.ust1=m.pp.str.ust%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.ved1=m.pp.str.ved%>% marker_filter%>% filter(p_val<0.05)

up_ck_pre_1=upset_gene_lists(list(inf=m.pp.ck.inf1$gene,ust=m.pp.ck.ust1$gene,ved=m.pp.ck.ved1$gene))
up_str_pre_1=upset_gene_lists(list(inf=m.pp.str.inf1$gene,ust=m.pp.str.ust1$gene,ved=m.pp.str.ved1$gene))
up_ck_pre_1a=upset_gene_lists(list(all=m.pp.ck1$gene,inf=m.pp.ck.inf1$gene,ust=m.pp.ck.ust1$gene,ved=m.pp.ck.ved1$gene))
up_str_pre_1a=upset_gene_lists(list(all=m.pp.str1$gene,inf=m.pp.str.inf1$gene,ust=m.pp.str.ust1$gene,ved=m.pp.str.ved1$gene))

m.pp.ck2=m.pp.ck2%>% marker_filter%>% filter(p_val<0.05)
m.pp.ck.inf2=m.pp.ck.inf2%>% marker_filter %>% filter(p_val<0.05)
m.pp.ck.ust2=m.pp.ck.ust2%>% marker_filter%>% filter(p_val<0.05)
m.pp.ck.ved2=m.pp.ck.ved2%>% marker_filter%>% filter(p_val<0.05)

m.pp.str2=m.pp.str2%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.inf2=m.pp.str.inf2%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.ust2=m.pp.str.ust2%>% marker_filter%>% filter(p_val<0.05)
m.pp.str.ved2=m.pp.str.ved2%>% marker_filter%>% filter(p_val<0.05)

up_ck_pre_2a=upset_gene_lists(list(
  all=m.pp.ck2$gene,
  inf=m.pp.ck.inf2$gene,
  ust=m.pp.ck.ust2$gene,
  ved=m.pp.ck.ved2$gene))
up_str_pre_2a=upset_gene_lists(list(
  all=m.pp.str2$gene,
  inf=m.pp.str.inf2$gene,
  ust=m.pp.str.ust2$gene,
  ved=m.pp.str.ved2$gene))
up_ck_pre_2=upset_gene_lists(list(
  inf=m.pp.ck.inf2$gene,
  ust=m.pp.ck.ust2$gene,
  ved=m.pp.ck.ved2$gene))
up_str_pre_2=upset_gene_lists(list(
  inf=m.pp.str.inf2$gene,
  ust=m.pp.str.ust2$gene,
  ved=m.pp.str.ved2$gene))

paste(m.ck.inf.pre$gene,collapse=", ")
paste(m.ck.inf.pre[m.ck.inf.pre$estimate>0,]$gene,collapse=", ")
paste(m.str.inf.pre$gene,collapse=", ")

```

## 시도2 correction
```{r}
data.adj <- create_adjusted_matrix(
    data_seurat,
    lmm,
    adjustment_type = "random",
    config=my_config
)
data.adj=SetAssayData(data.adj,layer="data",new.data=GetAssayData(data.adj, assay="RNA",layer="counts"))
data.ck.adj <- create_adjusted_matrix(
    data.ck,
    lmm,
    adjustment_type = "random",
    config=my_config
)
data.ck.adj=SetAssayData(data.ck.adj,layer="data",new.data=GetAssayData(data.ck.adj, assay="RNA",layer="counts"))

```

### lmm_result filter : (Intercept) 제외
```{r}
lrf=function(lmm_result){
  lmm_result$summary=lmm_result$summary[lmm_result$summary$term!="(Intercept)",]
  return(lmm_result)
}
```
#6 ver 11 (main) QSG, RLMG -> LMM, etc. (Claude)


```{r}
library(tidyverse)
library(Seurat)
library(lme4)
library(lmerTest)
library(emmeans)
library(parallel)
library(broom.mixed)
library(ggpubr)
library(pheatmap)
library(viridis)

# ========================================
# PART 1: 데이터 준비 및 설정
# ========================================

#' 분석 설정 클래스 - 모든 변수명을 여기서 관리
create_analysis_config <- function(
  patient = "patient_id",
  drug = "drug", 
  timepoint = "timepoint",
  ck = "ck_status",
  response = "response",
  aoi = "aoi_id"
) {
  list(
    patient = patient,
    drug = drug,
    timepoint = timepoint,
    ck = ck,
    response = response,
    aoi = aoi
  )
}

#' GeoMx 데이터 준비 (Excel/CSV에서 읽기)
#' @param count_file 발현값 파일 경로
#' @param metadata_file 메타데이터 파일 경로  
#' @param config 변수명 설정
prepare_geomx_data <- function(count_file = NULL, 
                              metadata_file = NULL,
                              count_matrix = NULL,
                              metadata = NULL,
                              config = create_analysis_config(),
                              q3_normalize = TRUE) {
  
  # 파일에서 읽기 또는 직접 입력
  if (!is.null(count_file)) {
    if (grepl("\\.xlsx$", count_file)) {
      count_matrix <- openxlsx::read.xlsx(count_file, sheet = 1, rowNames = TRUE)
    } else {
      count_matrix <- read.csv(count_file, row.names = 1)
    }
  }
  
  if (!is.null(metadata_file)) {
    if (grepl("\\.xlsx$", metadata_file)) {
      metadata <- openxlsx::read.xlsx(metadata_file, sheet = 2)
    } else {
      metadata <- read.csv(metadata_file)
    }
  }
  
  # AOI 이름 매칭
  rownames(metadata) <- metadata[[config$aoi]]
  
  # Seurat 객체 생성
  seurat_obj <- CreateSeuratObject(
    counts = as.matrix(count_matrix),
    meta.data = metadata,
    min.cells = 0,
    min.features = 0
  )
  
  # Q3 정규화는 이미 되어있다고 가정
  if (!q3_normalize) {
    seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize")
  }
  
  # 조합 변수 생성 (빠른 스크리닝용)
  seurat_obj$condition_full <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]], "_", 
    seurat_obj@meta.data[[config$response]]
  )
  
  seurat_obj$condition_simple <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]]
  )
  
  return(seurat_obj)
}

# ========================================
# PART 2: 빠른 스크리닝 (Wilcoxon)
# ========================================

#' Step 1: 빠른 유전자 스크리닝
#' @param seurat_obj Seurat 객체
#' @param config 변수명 설정
#' @param comparison_type "pre_post", "drug", "response", "combined" 중 선택
#' @param use_adj p_val_adj 사용 여부 (FALSE면 p_val 사용)
quick_screen_genes <- function(seurat_obj,
                              config = create_analysis_config(),
                              comparison_type = "pre_post",
                              ck_subset = NULL,
                              min_pct = 0.1,
                              logfc_threshold = 0.25,
                              top_n = 1000,
                              use_adj = FALSE) {
  
  # CK 서브셋 필터링
  if (!is.null(ck_subset)) {
    seurat_obj <- subset(seurat_obj, 
                         subset = !!sym(config$ck) == ck_subset)
  }
  
  # 비교 그룹 설정
  if (comparison_type == "pre_post") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$timepoint]]
  } else if (comparison_type == "drug") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$drug]]
  } else if (comparison_type == "response") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$response]]
  } else if (comparison_type == "combined") {
    Idents(seurat_obj) <- seurat_obj$condition_full
  }
  
  # FindAllMarkers 실행
  markers <- FindAllMarkers(
    seurat_obj,
    min.pct = min_pct,
    logfc.threshold = logfc_threshold,
    only.pos = FALSE,
    return.thresh = 1  # 모든 유전자 반환
  )
  
  # p-value 선택 및 상위 유전자 선택
  if (use_adj) {
    top_genes <- markers %>%
      arrange(p_val_adj) %>%
      head(top_n) %>%
      pull(gene) %>%
      unique()
  } else {
    top_genes <- markers %>%
      arrange(p_val) %>%
      head(top_n) %>%
      pull(gene) %>%
      unique()
  }
  
  return(list(
    markers = markers,
    top_genes = top_genes,
    seurat_obj = seurat_obj
  ))
}

# ========================================
# PART 3: Linear Mixed Model 분석
# ========================================

#' Step 2: 단일 유전자 LMM
fit_lmm_single_gene <- function(gene_expr,
                                metadata,
                                config = create_analysis_config(),
                                formula_components = NULL,
                                use_config_names = TRUE) {
  
  # 데이터프레임 생성
  df <- cbind(
    data.frame(Expression = gene_expr),
    metadata
  )
  
  # Formula 생성
  if (is.null(formula_components)) {
    # 기본값: config 변수명 사용
    fixed_effects <- c(config$drug, config$timepoint, config$response)
    interactions <- c(
      paste(config$drug, config$timepoint, sep = ":"),
      paste(config$drug, config$response, sep = ":"),
      paste(config$timepoint, config$response, sep = ":"),
      paste(config$drug, config$timepoint, config$response, sep = ":")
    )
    random <- paste0("(1|", config$patient, ")")
    
    formula_str <- paste0(
      "Expression ~ ",
      paste(c(fixed_effects, interactions), collapse = " + "),
      " + ", random
    )
  } else {
    # formula_components 제공 시
    if (use_config_names) {
      # config 매핑 사용
      mapping <- list(
        "patient" = config$patient,
        "drug" = config$drug,
        "timepoint" = config$timepoint,
        "response" = config$response,
        "ck" = config$ck
      )
      
      # fixed effects 매핑
      fixed_mapped <- sapply(formula_components$fixed, function(x) {
        if (x %in% names(mapping)) mapping[[x]] else x
      })
      
      # interactions 매핑
      if (!is.null(formula_components$interactions)) {
        interactions_mapped <- sapply(formula_components$interactions, function(x) {
          parts <- strsplit(x, ":")[[1]]
          mapped_parts <- sapply(parts, function(p) {
            if (p %in% names(mapping)) mapping[[p]] else p
          })
          paste(mapped_parts, collapse = ":")
        })
      } else {
        interactions_mapped <- NULL
      }
      
      # random effects 매핑
      random_mapped <- formula_components$random
      for (key in names(mapping)) {
        random_mapped <- gsub(key, mapping[[key]], random_mapped)
      }
      
      formula_str <- paste0(
        "Expression ~ ",
        paste(c(fixed_mapped, interactions_mapped), collapse = " + "),
        " + ", random_mapped
      )
    } else {
      # 직접 사용 (매핑 없이)
      fixed_effects <- formula_components$fixed
      interactions <- formula_components$interactions
      formula_str <- paste0(
        "Expression ~ ",
        paste(c(fixed_effects, interactions), collapse = " + "),
        " + ", formula_components$random
      )
    }
  }
  
  # 모델 적합
  tryCatch({
    # Factor 레벨 재정렬 (reference level 설정)
    if (config$drug %in% names(df)) {
      df[[config$drug]] <- relevel(as.factor(df[[config$drug]]), ref = levels(as.factor(df[[config$drug]]))[1])
    }
    if (config$response %in% names(df)) {
      df[[config$response]] <- relevel(as.factor(df[[config$response]]), ref = levels(as.factor(df[[config$response]]))[1])
    }
    
    model <- lmer(as.formula(formula_str), data = df, REML = FALSE)
    
    # 결과 추출
    coef_summary <- summary(model)$coefficients
    anova_result <- anova(model)
    
    # 모든 약물 대비 추출 (reference level 포함)
    all_drugs <- unique(df[[config$drug]])
    ref_drug <- levels(as.factor(df[[config$drug]]))[1]
    
    # 주요 효과 계산
    effects <- data.frame(
      term = rownames(coef_summary),
      estimate = coef_summary[, "Estimate"],
      std_error = coef_summary[, "Std. Error"],
      t_value = coef_summary[, "t value"],
      p_value = coef_summary[, "Pr(>|t|)"],
      ref_drug = ref_drug
    )
    
    return(list(
      model = model,
      effects = effects,
      anova = anova_result,
      converged = TRUE,
      formula = formula_str,
      all_drugs = all_drugs,
      ref_drug = ref_drug
    ))
    
  }, error = function(e) {
    return(list(
      converged = FALSE,
      error = e$message,
      formula = formula_str
    ))
  })
}

#' Step 3: 다중 유전자 LMM (병렬처리)
run_lmm_multiple_genes <- function(seurat_obj,
                                  genes = NULL,
                                  config = create_analysis_config(),
                                  formula_components = NULL,
                                  use_config_names = TRUE,
                                  n_cores = 16,
                                  verbose = TRUE) {
  
  if (is.null(genes)) {
    genes <- rownames(seurat_obj)[1:100]  # 기본값: 상위 100개
    warning("No genes specified. Using first 100 genes.")
  }
  
  # 발현 매트릭스와 메타데이터 추출
  expr_matrix <- GetAssayData(seurat_obj, slot = "data")
  metadata <- seurat_obj@meta.data
  
  # 진행상황 표시
  if (verbose) {
    message(sprintf("Running LMM for %d genes using %d cores...", 
                   length(genes), n_cores))
  }
  
  # 병렬 처리
  if (n_cores > 1) {
    cl <- makeCluster(n_cores)
    clusterEvalQ(cl, {
      library(lme4)
      library(lmerTest)
    })
    clusterExport(cl, c("fit_lmm_single_gene", "config", "metadata", 
                        "expr_matrix", "formula_components", "use_config_names"),
                 envir = environment())
    
    results <- parLapply(cl, genes, function(gene) {
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components,
          use_config_names = use_config_names
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
    
    stopCluster(cl)
  } else {
    # 순차 처리
    results <- lapply(genes, function(gene) {
      if (verbose && which(genes == gene) %% 100 == 0) {
        message(sprintf("  Processing gene %d/%d", 
                       which(genes == gene), length(genes)))
      }
      
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
  }
  
  names(results) <- genes
  
  # 결과 요약
  summary_df <- summarize_lmm_results(results, config)
  
  return(list(
    raw_results = results,
    summary = summary_df,
    converged_genes = sum(sapply(results, function(x) x$converged)),
    total_genes = length(genes)
  ))
}

#' LMM 결과 요약; RLMG 내부에서 잘 작동하므로 건드리지 않아도 됨. 이 결과가 $summary로 나간다.
summarize_lmm_results <- function(lmm_results, config) {
  # 수렴한 모델만 처리
  converged <- lmm_results[sapply(lmm_results, function(x) x$converged)]
  
  if (length(converged) == 0) {
    warning("No models converged!")
    return(NULL)
  }
  
  # 모든 효과 수집
  all_effects <- do.call(rbind, lapply(names(converged), function(gene) {
    effects <- converged[[gene]]$effects
    effects$gene <- gene
    return(effects)
  }))
  
  # p-value 보정
  all_effects <- all_effects %>%
    group_by(term) %>%
    mutate(
      p_adj = p.adjust(p_value, method = "BH"),
      significant = p_adj < 0.05
    ) %>%
    ungroup()
  
  # Reference drug 정보 추가
  if ("ref_drug" %in% names(converged[[1]]$effects)) {
    ref_drugs <- unique(sapply(converged, function(x) x$ref_drug))
    attr(all_effects, "ref_drug") <- ref_drugs[1]
  }
  
  return(all_effects)
}

# ========================================
# PART 4: 특정 질문 분석
# ========================================

#' 질문 iv) 약물별 R/NR 효과가 큰 유전자 (reference drug 처리)
find_response_differential_genes <- function(lmm_summary,
                                            config,
                                            drug_name = NULL,
                                            top_n = 50) {
  
  # Reference drug 확인
  ref_drug <- attr(lmm_summary, "ref_drug")
  if (is.null(ref_drug) && "ref_drug" %in% names(lmm_summary)) {
    ref_drug <- unique(lmm_summary$ref_drug)[1]
  }
  
  if (!is.null(drug_name)) {
    if (drug_name == ref_drug) {
      # Reference drug인 경우: 다른 약물과의 대비 효과 확인
      message(sprintf("%s is the reference level. Showing contrasts with other drugs.", drug_name))
      
      # 다른 약물들의 main effect와 interaction 수집
      drug_terms <- lmm_summary %>%
        filter(grepl(config$drug, term) & grepl(config$response, term))
      
    } else {
      # Non-reference drug: 직접 효과 확인
      interaction_pattern <- paste0(drug_name, ".*:", ".*", config$response, "|",
                                   config$response, ".*:", ".*", drug_name)
      drug_terms <- lmm_summary %>%
        filter(grepl(interaction_pattern, term))
    }
  } else {
    # 모든 약물의 response interaction
    drug_terms <- lmm_summary %>%
      filter(grepl(paste0(config$drug, ".*:", ".*", config$response), term))
  }
  
  top_genes <- drug_terms %>%
    group_by(gene) %>%
    dplyr::summarize(
      max_effect = max(abs(estimate)),
      min_p = min(p_value),
      min_p_adj = min(p_adj),
      n_sig = sum(significant)
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 v) 약물 특이적 유전자
find_drug_specific_genes <- function(lmm_summary,
                                    config,
                                    response_subset = NULL,
                                    top_n = 50) {
  
  # Drug 주효과 및 상호작용
  drug_terms <- lmm_summary %>%
    filter(grepl(config$drug, term))
  
  if (!is.null(response_subset)) {
    drug_terms <- drug_terms %>%
      filter(grepl(response_subset, term))
  }
  
  top_genes <- drug_terms %>%
    group_by(gene) %>%
    dplyr::summarize(
      mean_effect = mean(abs(estimate)),
      max_effect = max(abs(estimate)),
      n_significant = sum(significant)
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 vi) Drug x Response 상호작용
find_interaction_genes <- function(lmm_summary,
                                  config,
                                  interaction_type = "drug_response",
                                  top_n = 50) {
  
  if (interaction_type == "drug_response") {
    pattern <- paste0(config$drug, ".*:", ".*", config$response)
  } else if (interaction_type == "drug_time") {
    pattern <- paste0(config$drug, ".*:", ".*", config$timepoint)
  } else if (interaction_type == "triple") {
    pattern <- paste0(config$drug, ".*:", ".*", 
                     config$timepoint, ".*:", ".*", config$response)
  }
  
  interaction_genes <- lmm_summary %>%
    filter(grepl(pattern, term)) %>%
    group_by(gene) %>%
    dplyr::summarize(
      interaction_strength = max(abs(estimate)),
      min_p_adj = min(p_adj),
      n_sig_terms = sum(significant)
    ) %>%
    arrange(desc(interaction_strength)) %>%
    head(top_n)
  
  return(interaction_genes)
}

# ========================================
# PART 5: 시각화
# ========================================

#' Pre-Post 변화 박스플롯
plot_pre_post_boxplot <- function(seurat_obj,
                                  gene,
                                  config,
                                  split_by = NULL) {
  
  # 데이터 준비
  df <- data.frame(
    Expression = GetAssayData(seurat_obj)[gene, ],
    seurat_obj@meta.data
  )
  
  # 기본 플롯
  p <- ggplot(df, aes_string(x = config$timepoint, y = "Expression")) +
    geom_boxplot(aes_string(fill = config$timepoint), alpha = 0.7) +
    geom_point(aes_string(fill = config$timepoint),
               position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.2), alpha = 0.5) +
    stat_compare_means(paired = TRUE, method = "wilcox.test") +
    labs(title = paste("Expression Changes:", gene),
         y = "Normalized Expression",
         x = "Timepoint") +
    theme_bw()
  
  # 분할 옵션
  if (!is.null(split_by)) {
    if (length(split_by) == 1) {
      p <- p + facet_wrap(as.formula(paste("~", split_by)))
    } else if (length(split_by) == 2) {
      p <- p + facet_grid(as.formula(paste(split_by[1], "~", split_by[2])))
    }
  }
  
  return(p)
}

#' 효과 크기 화산도
plot_volcano_legacy <- function(lmm_summary,
                        term_pattern = NULL,
                        title = "Volcano Plot",
                        effect_threshold = 0.5,
                        p_threshold = 0.05,
                        use_adj=FALSE) {

  plot_data <- lmm_summary

  if (!is.null(term_pattern)) {
    plot_data <- plot_data %>%
      filter(grepl(term_pattern, term))
  }

  if(use_adj){y_label="-log10(adj_p-value)"}else{y_label="-log10(p-value)"}


  plot_data <- plot_data %>%
    mutate(
      log_p = -log10(p_value),
      category = case_when(
        abs(estimate) > effect_threshold & p_adj < p_threshold & use_adj ~ "Significant",
        abs(estimate) > effect_threshold & p_value < p_threshold & !use_adj ~ "Significant",
        abs(estimate) > effect_threshold ~ "Large effect",
        p_adj  < p_threshold & use_adj ~ "Small effect",
        p_value  < p_threshold& !use_adj ~ "Small effect",
        TRUE ~ "Not significant"
      )
    )
  xlim_val=quantile(abs(plot_data$estimate),0.95,na.rm=TRUE)
  ggplot(plot_data, aes(x = estimate, y = log_p, color = category)) +
    geom_point(alpha = 0.6) +
    geom_hline(yintercept = -log10(p_threshold),
               linetype = "dashed", color = "gray") +
    geom_vline(xintercept = c(-effect_threshold, effect_threshold),
               linetype = "dashed", color = "gray") +
    scale_color_manual(values = c("Significant" = "red",
                                 "Large effect" = "orange",
                                 "Small effect" = "blue",
                                 "Not significant" = "gray")) +
    labs(title = title,
         x = "Effect Size (Estimate)",
         y = y_label) +
    theme_bw()+
    coord_cartesian(xlim = c(-xlim_val, xlim_val))
}

# ========================================
# PART 6: 완전한 워크플로우
# ========================================

#' 전체 분석 워크플로우
run_complete_workflow <- function(
  count_data,      # 매트릭스 또는 파일 경로
  metadata,        # 데이터프레임 또는 파일 경로
  config = create_analysis_config(),
  output_dir = "./results",
  n_cores = 16
) {
  
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  
  # ===== STEP 1: 데이터 준비 =====
  message("Step 1: Preparing data...")
  
  if (is.character(count_data)) {
    seurat_obj <- prepare_geomx_data(
      count_file = count_data,
      metadata_file = metadata,
      config = config
    )
  } else {
    seurat_obj <- prepare_geomx_data(
      count_matrix = count_data,
      metadata = metadata,
      config = config
    )
  }
  
  message(sprintf("  Loaded %d genes x %d AOIs", 
                 nrow(seurat_obj), ncol(seurat_obj)))
  
  # ===== STEP 2: CK별 분리 =====
  message("Step 2: Separating by CK status...")
  
  ck_values <- unique(seurat_obj@meta.data[[config$ck]])
  message(sprintf("  Found CK groups: %s", paste(ck_values, collapse = ", ")))
  
  results_by_ck <- list()
  
  for (ck_val in ck_values) {
    message(sprintf("\n=== Analyzing %s ===", ck_val))
    
    # CK 서브셋
    seurat_ck <- subset(seurat_obj, 
                        subset = !!sym(config$ck) == ck_val)
    
    # ===== STEP 3: 빠른 스크리닝 =====
    message("Step 3: Quick screening with Wilcoxon test...")
    
    screen_results <- quick_screen_genes(
      seurat_ck,
      config = config,
      comparison_type = "combined",
      top_n = 1000
    )
    
    message(sprintf("  Selected top %d genes", 
                   length(screen_results$top_genes)))
    
    # ===== STEP 4: LMM 분석 =====
    message("Step 4: Running Linear Mixed Models...")
    
    # 간단한 모델부터 시작 (config 키워드 사용)
    simple_formula <- list(
      fixed = c("drug", "timepoint", "response"),
      interactions = c("drug:timepoint"),
      random = "(1|patient)"
    )
    
    lmm_results <- run_lmm_multiple_genes(
      seurat_ck,
      genes = screen_results$top_genes,
      config = config,
      formula_components = simple_formula,
      use_config_names = TRUE,  # config 매핑 사용
      n_cores = n_cores
    )
    
    message(sprintf("  %d/%d models converged", 
                   lmm_results$converged_genes,
                   lmm_results$total_genes))
    
    # ===== STEP 5: 특정 분석 =====
    message("Step 5: Analyzing specific questions...")
    
    # 약물별 분석
    drugs <- unique(seurat_ck@meta.data[[config$drug]])
    drug_response_effects <- list()
    
    for (drug in drugs) {
      drug_response_effects[[drug]] <- find_response_differential_genes(
        lmm_results$summary,
        config,
        drug_name = drug,
        top_n = 30
      )
    }
    
    # Drug-specific genes
    drug_specific <- find_drug_specific_genes(
      lmm_results$summary,
      config,
      top_n = 50
    )
    
    # Interaction genes
    interaction_genes <- find_interaction_genes(
      lmm_results$summary,
      config,
      interaction_type = "drug_response",
      top_n = 50
    )
    
    # ===== STEP 6: 결과 저장 =====
    results_by_ck[[ck_val]] <- list(
      seurat_obj = seurat_ck,
      screening = screen_results,
      lmm = lmm_results,
      drug_response_effects = drug_response_effects,
      drug_specific = drug_specific,
      interaction_genes = interaction_genes
    )
    
    # CSV 저장
    write.csv(drug_specific,
             file.path(output_dir, paste0("drug_specific_", ck_val, ".csv")),
             row.names = FALSE)
    
    write.csv(interaction_genes,
             file.path(output_dir, paste0("interaction_genes_", ck_val, ".csv")),
             row.names = FALSE)
    
    # ===== STEP 7: 시각화 =====
    message("Step 6: Creating visualizations...")
    
    # Top 5 유전자 플롯
    top_genes_to_plot <- drug_specific$gene[1:min(5, nrow(drug_specific))]
    
    pdf(file.path(output_dir, paste0("plots_", ck_val, ".pdf")), 
        width = 12, height = 8)
    
    for (gene in top_genes_to_plot) {
      p <- plot_pre_post_boxplot(
        seurat_ck,
        gene = gene,
        config = config,
        split_by = c(config$drug, config$response)
      )
      print(p)
    }
    
    # 화산도
    p_volcano <- plot_volcano(
      lmm_results$summary,
      term_pattern = config$drug,
      title = paste("Drug Effects -", ck_val)
    )
    print(p_volcano)
    
    dev.off()
  }
  
  # 전체 결과 저장
  saveRDS(results_by_ck, 
          file.path(output_dir, "complete_results.rds"))
  
  message("\n=== Analysis Complete ===")
  message(sprintf("Results saved to: %s", output_dir))
  
  return(results_by_ck)
}



```
## patching
```{r}
plot_volcano <- function(lmm_summary,
                         x_col="estimate",
                         y_col="p_value",
                         filter_col="term",
                        filter_pattern = NULL,
                        title = "Volcano Plot",
                        effect_threshold = 0.5,
                        p_threshold = 0.05,
                        resize_x=TRUE,
                        resize_y=TRUE) {
  #ver2: generalized
  plot_data <- lmm_summary
  
  if (!is.null(filter_pattern)) {
    plot_data <- plot_data %>%
      filter(grepl(filter_pattern, term))
  }
  if (!is.null(x_col)){plot_data=plot_data%>%mutate(effect_size= !!sym(x_col))}
  if (!is.null(y_col)){plot_data=plot_data%>%mutate(p_value= !!sym(y_col))}

  # plot label definition
  x_label="Effect Size"
  y_label="Significance"
  
  # plot resizing
  if(resize_x){xlim_val=quantile(abs(plot_data$effect_size),0.95,na.rm=TRUE)}
  if(resize_y){ylim_val=quantile(abs(plot_data$effect_size),0.95,na.rm=TRUE)}
  
  # gene significance label arrange
  plot_data <- plot_data %>%
    mutate(
      log_p = -log10(p_value),
      category = case_when(
        abs(effect_size) > effect_threshold & p_value < p_threshold ~ "Significant",
        abs(effect_size) > effect_threshold ~ "Large effect",
        p_value  < p_threshold ~ "Small effect",
        TRUE ~ "Not significant"
      )
    )
  ggplot(plot_data, aes(x = effect_size, y = log_p, color = category)) +
    geom_point(alpha = 0.6) +
    geom_hline(yintercept = -log10(p_threshold), 
               linetype = "dashed", color = "gray") +
    geom_vline(xintercept = c(-effect_threshold, effect_threshold), 
               linetype = "dashed", color = "gray") +
    scale_color_manual(values = c("Significant" = "red",
                                 "Large effect" = "orange", 
                                 "Small effect" = "blue",
                                 "Not significant" = "gray")) +
    labs(title = title,
         x = x_label,
         y = y_label) +
    theme_bw()+
    coord_cartesian(xlim = c(-xlim_val, xlim_val))
}
```
#8 ver14 not using it. 
```{r}
library(tidyverse)
library(Seurat)
library(lme4)
library(lmerTest)
library(emmeans)
library(parallel)
library(broom.mixed)
library(ggpubr)
library(pheatmap)
library(viridis)

# ========================================
# PART 1: 데이터 준비 및 설정
# ========================================

#' 분석 설정 클래스 - 모든 변수명을 여기서 관리
create_analysis_config <- function(
  patient_col = "patient_id",
  drug_col = "drug", 
  timepoint_col = "timepoint",
  ck_col = "ck_status",
  response_col = "response",
  aoi_col = "aoi_id"
) {
  list(
    patient = patient_col,
    drug = drug_col,
    timepoint = timepoint_col,
    ck = ck_col,
    response = response_col,
    aoi = aoi_col
  )
}

#' GeoMx 데이터 준비 (Excel/CSV에서 읽기)
#' @param count_file 발현값 파일 경로
#' @param metadata_file 메타데이터 파일 경로  
#' @param config 변수명 설정
prepare_geomx_data <- function(count_file = NULL, 
                              metadata_file = NULL,
                              count_matrix = NULL,
                              metadata = NULL,
                              config = create_analysis_config(),
                              q3_normalize = TRUE) {
  
  # 파일에서 읽기 또는 직접 입력
  if (!is.null(count_file)) {
    if (grepl("\\.xlsx$", count_file)) {
      count_matrix <- openxlsx::read.xlsx(count_file, sheet = 1, rowNames = TRUE)
    } else {
      count_matrix <- read.csv(count_file, row.names = 1)
    }
  }
  
  if (!is.null(metadata_file)) {
    if (grepl("\\.xlsx$", metadata_file)) {
      metadata <- openxlsx::read.xlsx(metadata_file, sheet = 2)
    } else {
      metadata <- read.csv(metadata_file)
    }
  }
  
  # AOI 이름 매칭
  rownames(metadata) <- metadata[[config$aoi]]
  
  # Seurat 객체 생성
  seurat_obj <- CreateSeuratObject(
    counts = as.matrix(count_matrix),
    meta.data = metadata,
    min.cells = 0,
    min.features = 0
  )
  
  # Q3 정규화는 이미 되어있다고 가정
  if (!q3_normalize) {
    seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize")
  }
  
  # 조합 변수 생성 (빠른 스크리닝용)
  seurat_obj$condition_full <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]], "_", 
    seurat_obj@meta.data[[config$response]]
  )
  
  seurat_obj$condition_simple <- paste0(
    seurat_obj@meta.data[[config$timepoint]], "_",
    seurat_obj@meta.data[[config$drug]]
  )
  
  return(seurat_obj)
}

# ========================================
# PART 2: 빠른 스크리닝 (Wilcoxon)
# ========================================

#' Step 1: 빠른 유전자 스크리닝; FindMarkers u-test
#' @param seurat_obj Seurat 객체
#' @param config 변수명 설정
#' @param comparison_type "pre_post", "drug", "response", "combined" 중 선택
#' @param use_adj p_val_adj 사용 여부 (FALSE면 p_val 사용)
quick_screen_genes <- function(seurat_obj,
                              config = create_analysis_config(),
                              comparison_type = "pre_post",
                              ck_subset = NULL,
                              min_pct = 0.1,
                              logfc_threshold = 0.25,
                              top_n = 1000,
                              use_adj = FALSE) {
  
  # CK 서브셋 필터링
  if (!is.null(ck_subset)) {
    seurat_obj <- subset(seurat_obj, 
                         subset = !!sym(config$ck) == ck_subset)
  }
  
  # 비교 그룹 설정
  if (comparison_type == "pre_post") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$timepoint]]
  } else if (comparison_type == "drug") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$drug]]
  } else if (comparison_type == "response") {
    Idents(seurat_obj) <- seurat_obj@meta.data[[config$response]]
  } else if (comparison_type == "combined") {
    Idents(seurat_obj) <- seurat_obj$condition_full
  }
  
  # FindAllMarkers 실행
  markers <- FindAllMarkers(
    seurat_obj,
    min.pct = min_pct,
    logfc.threshold = logfc_threshold,
    only.pos = FALSE,
    return.thresh = 1  # 모든 유전자 반환
  )
  
  # p-value 선택 및 상위 유전자 선택
  if (use_adj) {
    top_genes <- markers %>%
      arrange(p_val_adj) %>%
      head(top_n) %>%
      pull(gene) %>%
      unique()
  } else {
    top_genes <- markers %>%
      arrange(p_val) %>%
      head(top_n) %>%
      pull(gene) %>%
      unique()
  }
  
  return(list(
    markers = markers,
    top_genes = top_genes,
    seurat_obj = seurat_obj
  ))
}

# ========================================
# PART 3: Linear Mixed Model 분석
# ========================================

#' Step 2: 단일 유전자 LMM
fit_lmm_single_gene <- function(gene_expr,
                                metadata,
                                config = create_analysis_config(),
                                formula_components = NULL,
                                use_config_names = TRUE) {
  
  # 데이터프레임 생성
  df <- cbind(
    data.frame(Expression = gene_expr),
    metadata
  )
  
  # Formula 생성
  if (is.null(formula_components)) {
    # 기본값: config 변수명 사용
    fixed_effects <- c(config$drug, config$timepoint, config$response)
    interactions <- c(
      paste(config$drug, config$timepoint, sep = ":"),
      paste(config$drug, config$response, sep = ":"),
      paste(config$timepoint, config$response, sep = ":"),
      paste(config$drug, config$timepoint, config$response, sep = ":")
    )
    random <- paste0("(1|", config$patient, ")")
    
    formula_str <- paste0(
      "Expression ~ ",
      paste(c(fixed_effects, interactions), collapse = " + "),
      " + ", random
    )
  } else {
    # formula_components 제공 시
    if (use_config_names) {
      # config 매핑 사용
      mapping <- list(
        "patient" = config$patient,
        "drug" = config$drug,
        "timepoint" = config$timepoint,
        "response" = config$response,
        "ck" = config$ck
      )
      
      # fixed effects 매핑
      fixed_mapped <- sapply(formula_components$fixed, function(x) {
        if (x %in% names(mapping)) mapping[[x]] else x
      })
      
      # interactions 매핑
      if (!is.null(formula_components$interactions)) {
        interactions_mapped <- sapply(formula_components$interactions, function(x) {
          parts <- strsplit(x, ":")[[1]]
          mapped_parts <- sapply(parts, function(p) {
            if (p %in% names(mapping)) mapping[[p]] else p
          })
          paste(mapped_parts, collapse = ":")
        })
      } else {
        interactions_mapped <- NULL
      }
      
      # random effects 매핑
      random_mapped <- formula_components$random
      for (key in names(mapping)) {
        random_mapped <- gsub(key, mapping[[key]], random_mapped)
      }
      
      formula_str <- paste0(
        "Expression ~ ",
        paste(c(fixed_mapped, interactions_mapped), collapse = " + "),
        " + ", random_mapped
      )
    } else {
      # 직접 사용 (매핑 없이)
      fixed_effects <- formula_components$fixed
      interactions <- formula_components$interactions
      formula_str <- paste0(
        "Expression ~ ",
        paste(c(fixed_effects, interactions), collapse = " + "),
        " + ", formula_components$random
      )
    }
  }
  
  # 모델 적합
  tryCatch({
    # Factor 레벨 재정렬 (reference level 설정)
    if (config$drug %in% names(df)) {
      df[[config$drug]] <- relevel(as.factor(df[[config$drug]]), ref = levels(as.factor(df[[config$drug]]))[1])
    }
    if (config$response %in% names(df)) {
      df[[config$response]] <- relevel(as.factor(df[[config$response]]), ref = levels(as.factor(df[[config$response]]))[1])
    }
    
    model <- lmer(as.formula(formula_str), data = df, REML = FALSE)
    
    # 결과 추출
    coef_summary <- summary(model)$coefficients
    anova_result <- anova(model)
    
    # 모든 약물 대비 추출 (reference level 포함)
    all_drugs <- unique(df[[config$drug]])
    ref_drug <- levels(as.factor(df[[config$drug]]))[1]
    
    # 주요 효과 계산
    effects <- data.frame(
      term = rownames(coef_summary),
      estimate = coef_summary[, "Estimate"],
      std_error = coef_summary[, "Std. Error"],
      t_value = coef_summary[, "t value"],
      p_value = coef_summary[, "Pr(>|t|)"],
      ref_drug = ref_drug
    )
    
    return(list(
      model = model,
      effects = effects,
      anova = anova_result,
      converged = TRUE,
      formula = formula_str,
      all_drugs = all_drugs,
      ref_drug = ref_drug
    ))
    
  }, error = function(e) {
    return(list(
      converged = FALSE,
      error = e$message,
      formula = formula_str
    ))
  })
}

#' Step 3: 다중 유전자 LMM (병렬처리)
run_lmm_multiple_genes <- function(seurat_obj,
                                  genes = NULL,
                                  config = create_analysis_config(),
                                  formula_components = NULL,
                                  use_config_names = TRUE,
                                  n_cores = 16,
                                  verbose = TRUE) {
  
  if (is.null(genes)) {
    genes <- rownames(seurat_obj)[1:100]  # 기본값: 상위 100개
    warning("No genes specified. Using first 100 genes.")
  }
  
  # 발현 매트릭스와 메타데이터 추출
  expr_matrix <- GetAssayData(seurat_obj, slot = "data")
  metadata <- seurat_obj@meta.data
  
  # 진행상황 표시
  if (verbose) {
    message(sprintf("Running LMM for %d genes using %d cores...", 
                   length(genes), n_cores))
  }
  
  # 병렬 처리
  if (n_cores > 1) {
    cl <- makeCluster(n_cores)
    clusterEvalQ(cl, {
      library(lme4)
      library(lmerTest)
    })
    clusterExport(cl, c("fit_lmm_single_gene", "config", "metadata", 
                        "expr_matrix", "formula_components", "use_config_names"),
                 envir = environment())
    
    results <- parLapply(cl, genes, function(gene) {
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components,
          use_config_names = use_config_names
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
    
    stopCluster(cl)
  } else {
    # 순차 처리
    results <- lapply(genes, function(gene) {
      if (verbose && which(genes == gene) %% 100 == 0) {
        message(sprintf("  Processing gene %d/%d", 
                       which(genes == gene), length(genes)))
      }
      
      if (gene %in% rownames(expr_matrix)) {
        result <- fit_lmm_single_gene(
          gene_expr = as.numeric(expr_matrix[gene, ]),
          metadata = metadata,
          config = config,
          formula_components = formula_components,
          use_config_names = use_config_names
        )
        result$gene <- gene
        return(result)
      } else {
        return(list(gene = gene, converged = FALSE, 
                   error = "Gene not found"))
      }
    })
  }
  
  names(results) <- genes
  
  # 결과 요약
  summary_df <- summarize_lmm_results(results, config)
  
  return(list(
    raw_results = results,
    summary = summary_df,
    converged_genes = sum(sapply(results, function(x) x$converged)),
    total_genes = length(genes)
  ))
}

#' LMM 결과 요약
summarize_lmm_results <- function(lmm_results, config) {
  # 수렴한 모델만 처리
  converged <- lmm_results[sapply(lmm_results, function(x) x$converged)]
  
  if (length(converged) == 0) {
    warning("No models converged!")
    return(NULL)
  }
  
  # 모든 효과 수집
  all_effects <- do.call(rbind, lapply(names(converged), function(gene) {
    effects <- converged[[gene]]$effects
    effects$gene <- gene
    return(effects)
  }))
  
  # p-value 보정
  all_effects <- all_effects %>%
    group_by(term) %>%
    mutate(
      p_adj = p.adjust(p_value, method = "BH"),
      significant = p_adj < 0.05
    ) %>%
    ungroup()
  
  # Reference drug 정보 추가
  if ("ref_drug" %in% names(converged[[1]]$effects)) {
    ref_drugs <- unique(sapply(converged, function(x) x$ref_drug))
    attr(all_effects, "ref_drug") <- ref_drugs[1]
  }
  
  return(all_effects)
}

# ========================================
# PART 4: 특정 질문 분석
# ========================================

#' 질문 iv) 약물별 R/NR 효과가 큰 유전자 (reference drug 처리)
find_response_differential_genes <- function(lmm_summary,
                                            config,
                                            drug_name = NULL,
                                            top_n = 50) {
  
  # Reference drug 확인
  ref_drug <- attr(lmm_summary, "ref_drug")
  if (is.null(ref_drug) && "ref_drug" %in% names(lmm_summary)) {
    ref_drug <- unique(lmm_summary$ref_drug)[1]
  }
  
  if (!is.null(drug_name)) {
    # drug_name 표준화 (대소문자 처리)
    drug_name_lower <- tolower(drug_name)
    ref_drug_lower <- tolower(ref_drug)
    
    if (drug_name_lower == ref_drug_lower) {
      # Reference drug인 경우: Response main effect와 다른 약물과의 대비
      message(sprintf("%s is the reference level. Showing response effects and contrasts with other drugs.", drug_name))
      
      # 1. Response main effect (reference drug에서의 효과)
      response_main <- lmm_summary %>%
        filter(term == config$response | term == paste0(config$response, "R"))
      
      # 2. 다른 약물들의 Drug:Response interaction (reference와의 차이)
      drug_response_interactions <- lmm_summary %>%
        filter(grepl(paste0("drug.*:", ".*", config$response), term, ignore.case = TRUE))
      
      # 두 결과 합치기
      drug_terms <- rbind(response_main, drug_response_interactions)
      
    } else {
      # Non-reference drug: Drug:Response interaction 찾기
      # 여러 패턴 시도
      patterns <- c(
        paste0("drug", drug_name, ":", config$response),
        paste0("drug", drug_name, ":.*", config$response),
        paste0(config$response, ".*:drug", drug_name)
      )
      
      drug_terms <- lmm_summary %>%
        filter(Reduce("|", lapply(patterns, function(p) grepl(p, term, ignore.case = TRUE))))
    }
  } else {
    # 모든 약물의 response 관련 효과
    drug_terms <- lmm_summary %>%
      filter(grepl(config$response, term, ignore.case = TRUE))
  }
  
  if (nrow(drug_terms) == 0) {
    warning(sprintf("No terms found for drug '%s' with response '%s'. Check term names in summary.", 
                   drug_name, config$response))
    return(data.frame(gene = character(), max_effect = numeric(), 
                      min_p = numeric(), min_p_adj = numeric()))
  }
  
  top_genes <- drug_terms %>%
    group_by(gene) %>%
    dplyr::summarize(
      max_effect = max(abs(estimate)),
      min_p = min(p_value),
      min_p_adj = min(p_adj),
      n_sig = sum(significant),
      main_term = term[which.max(abs(estimate))][1]  # 가장 큰 효과의 term
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 v) 약물 특이적 유전자
find_drug_specific_genes <- function(lmm_summary,
                                    config,
                                    response_subset = NULL,
                                    top_n = 50) {
  
  # Drug 주효과 및 상호작용
  drug_terms <- lmm_summary %>%
    filter(grepl(config$drug, term))
  
  if (!is.null(response_subset)) {
    drug_terms <- drug_terms %>%
      filter(grepl(response_subset, term))
  }
  
  top_genes <- drug_terms %>%
    group_by(gene) %>%
    dplyr::summarize(
      mean_effect = mean(abs(estimate)),
      max_effect = max(abs(estimate)),
      n_significant = sum(significant)
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_n)
  
  return(top_genes)
}

#' 질문 vi) Drug x Response 상호작용
find_interaction_genes <- function(lmm_summary,
                                  config,
                                  interaction_type = "drug_response",
                                  top_n = 50) {
  
  if (interaction_type == "drug_response") {
    pattern <- paste0(config$drug, ".*:", ".*", config$response)
  } else if (interaction_type == "drug_time") {
    pattern <- paste0(config$drug, ".*:", ".*", config$timepoint)
  } else if (interaction_type == "triple") {
    pattern <- paste0(config$drug, ".*:", ".*", 
                     config$timepoint, ".*:", ".*", config$response)
  }
  
  interaction_genes <- lmm_summary %>%
    filter(grepl(pattern, term)) %>%
    group_by(gene) %>%
    dplyr::summarize(
      interaction_strength = max(abs(estimate)),
      min_p_adj = min(p_adj),
      n_sig_terms = sum(significant)
    ) %>%
    arrange(desc(interaction_strength)) %>%
    head(top_n)
  
  return(interaction_genes)
}

# ========================================
# PART 5: 시각화
# ========================================

#' Pre-Post 변화 박스플롯
plot_pre_post_boxplot <- function(seurat_obj,
                                  gene,
                                  config,
                                  split_by = NULL) {
  
  # 데이터 준비
  df <- data.frame(
    Expression = GetAssayData(seurat_obj)[gene, ],
    seurat_obj@meta.data
  )
  
  # 기본 플롯
  p <- ggplot(df, aes_string(x = config$timepoint, y = "Expression")) +
    geom_boxplot(aes_string(fill = config$timepoint), alpha = 0.7) +
    geom_point(position = position_jitterdodge(0.2), alpha = 0.5) +
    stat_compare_means(paired = TRUE, method = "wilcox.test") +
    labs(title = paste("Expression Changes:", gene),
         y = "Normalized Expression",
         x = "Timepoint") +
    theme_bw()
  
  # 분할 옵션
  if (!is.null(split_by)) {
    if (length(split_by) == 1) {
      p <- p + facet_wrap(as.formula(paste("~", split_by)))
    } else if (length(split_by) == 2) {
      p <- p + facet_grid(as.formula(paste(split_by[1], "~", split_by[2])))
    }
  }
  
  return(p)
}

#' 효과 크기 화산도
plot_volcano <- function(lmm_summary,
                        term_pattern = NULL,
                        title = "Volcano Plot",
                        effect_threshold = 0.5,
                        p_threshold = 0.05) {
  
  plot_data <- lmm_summary
  
  if (!is.null(term_pattern)) {
    plot_data <- plot_data %>%
      filter(grepl(term_pattern, term))
  }
  
  plot_data <- plot_data %>%
    mutate(
      log_p = -log10(p_value),
      category = case_when(
        abs(estimate) > effect_threshold & p_adj < p_threshold ~ "Significant",
        abs(estimate) > effect_threshold ~ "Large effect",
        p_adj < p_threshold ~ "Small effect",
        TRUE ~ "Not significant"
      )
    )
  
  ggplot(plot_data, aes(x = estimate, y = log_p, color = category)) +
    geom_point(alpha = 0.6) +
    geom_hline(yintercept = -log10(p_threshold), 
               linetype = "dashed", color = "gray") +
    geom_vline(xintercept = c(-effect_threshold, effect_threshold), 
               linetype = "dashed", color = "gray") +
    scale_color_manual(values = c("Significant" = "red",
                                 "Large effect" = "orange", 
                                 "Small effect" = "blue",
                                 "Not significant" = "gray")) +
    labs(title = title,
         x = "Effect Size (Estimate)",
         y = "-log10(p-value)") +
    theme_bw()
}

# ========================================
# PART 6: 완전한 워크플로우
# ========================================

#' 전체 분석 워크플로우
run_complete_workflow <- function(
  count_data,      # 매트릭스 또는 파일 경로
  metadata,        # 데이터프레임 또는 파일 경로
  config = create_analysis_config(),
  output_dir = "./results",
  n_cores = 4
) {
  
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  
  # ===== STEP 1: 데이터 준비 =====
  message("Step 1: Preparing data...")
  
  if (is.character(count_data)) {
    seurat_obj <- prepare_geomx_data(
      count_file = count_data,
      metadata_file = metadata,
      config = config
    )
  } else {
    seurat_obj <- prepare_geomx_data(
      count_matrix = count_data,
      metadata = metadata,
      config = config
    )
  }
  
  message(sprintf("  Loaded %d genes x %d AOIs", 
                 nrow(seurat_obj), ncol(seurat_obj)))
  
  # ===== STEP 2: CK별 분리 =====
  message("Step 2: Separating by CK status...")
  
  ck_values <- unique(seurat_obj@meta.data[[config$ck]])
  message(sprintf("  Found CK groups: %s", paste(ck_values, collapse = ", ")))
  
  results_by_ck <- list()
  
  for (ck_val in ck_values) {
    message(sprintf("\n=== Analyzing %s ===", ck_val))
    
    # CK 서브셋
    seurat_ck <- subset(seurat_obj, 
                        subset = !!sym(config$ck) == ck_val)
    
    # ===== STEP 3: 빠른 스크리닝 =====
    message("Step 3: Quick screening with Wilcoxon test...")
    
    screen_results <- quick_screen_genes(
      seurat_ck,
      config = config,
      comparison_type = "combined",
      top_n = 1000
    )
    
    message(sprintf("  Selected top %d genes", 
                   length(screen_results$top_genes)))
    
    # ===== STEP 4: LMM 분석 =====
    message("Step 4: Running Linear Mixed Models...")
    
    # 간단한 모델부터 시작 (config 키워드 사용)
    simple_formula <- list(
      fixed = c("drug", "timepoint", "response"),
      interactions = c("drug:timepoint"),
      random = "(1|patient)"
    )
    
    lmm_results <- run_lmm_multiple_genes(
      seurat_ck,
      genes = screen_results$top_genes,
      config = config,
      formula_components = simple_formula,
      use_config_names = TRUE,  # config 매핑 사용
      n_cores = n_cores
    )
    
    message(sprintf("  %d/%d models converged", 
                   lmm_results$converged_genes,
                   lmm_results$total_genes))
    
    # ===== STEP 5: 특정 분석 =====
    message("Step 5: Analyzing specific questions...")
    
    # 약물별 분석
    drugs <- unique(seurat_ck@meta.data[[config$drug]])
    drug_response_effects <- list()
    
    for (drug in drugs) {
      drug_response_effects[[drug]] <- find_response_differential_genes(
        lmm_results$summary,
        config,
        drug_name = drug,
        top_n = 30
      )
    }
    
    # Drug-specific genes
    drug_specific <- find_drug_specific_genes(
      lmm_results$summary,
      config,
      top_n = 50
    )
    
    # Interaction genes
    interaction_genes <- find_interaction_genes(
      lmm_results$summary,
      config,
      interaction_type = "drug_response",
      top_n = 50
    )
    
    # ===== STEP 6: 결과 저장 =====
    results_by_ck[[ck_val]] <- list(
      seurat_obj = seurat_ck,
      screening = screen_results,
      lmm = lmm_results,
      drug_response_effects = drug_response_effects,
      drug_specific = drug_specific,
      interaction_genes = interaction_genes
    )
    
    # CSV 저장
    write.csv(drug_specific,
             file.path(output_dir, paste0("drug_specific_", ck_val, ".csv")),
             row.names = FALSE)
    
    write.csv(interaction_genes,
             file.path(output_dir, paste0("interaction_genes_", ck_val, ".csv")),
             row.names = FALSE)
    
    # ===== STEP 7: 시각화 =====
    message("Step 6: Creating visualizations...")
    
    # Top 5 유전자 플롯
    top_genes_to_plot <- drug_specific$gene[1:min(5, nrow(drug_specific))]
    
    pdf(file.path(output_dir, paste0("plots_", ck_val, ".pdf")), 
        width = 12, height = 8)
    
    for (gene in top_genes_to_plot) {
      p <- plot_pre_post_boxplot(
        seurat_ck,
        gene = gene,
        config = config,
        split_by = c(config$drug, config$response)
      )
      print(p)
    }
    
    # 화산도
    p_volcano <- plot_volcano(
      lmm_results$summary,
      term_pattern = config$drug,
      title = paste("Drug Effects -", ck_val)
    )
    print(p_volcano)
    
    dev.off()
  }
  
  # 전체 결과 저장
  saveRDS(results_by_ck, 
          file.path(output_dir, "complete_results.rds"))
  
  message("\n=== Analysis Complete ===")
  message(sprintf("Results saved to: %s", output_dir))
  
  return(results_by_ck)
}

# ========================================
# 사용 예시
# ========================================

# 1. 설정 정의 (실제 컬럼명에 맞게)
my_config <- create_analysis_config(
  patient_col = "patient_id",      # 실제 환자 ID 컬럼명
  drug_col = "treatment",           # 약물 컬럼명 
  timepoint_col = "time",           # pre/post 컬럼명
  ck_col = "panck",                 # CK+/- 컬럼명
  response_col = "healing_level",   # 반응 컬럼명
  aoi_col = "roi_aoi"               # AOI ID 컬럼명
)

# 2. 분석 실행 - 방법 A: config 변수명 사용 (권장)
# simple_formula <- list(
#   fixed = c("drug", "timepoint"),           # config 키워드 사용
#   interactions = c("drug:timepoint"),        # config 키워드 사용
#   random = "(1|patient)"                     # config 키워드 사용
# )
# 
# lmm_results <- run_lmm_multiple_genes(
#   seurat_ck_pos,
#   genes = top_genes[1:500],
#   config = my_config,
#   formula_components = simple_formula,
#   use_config_names = TRUE,    # config 매핑 사용
#   n_cores = 8
# )

# 3. Infliximab이 reference인 경우의 분석
# # Infliximab 효과 (reference drug)
# infliximab_effects <- find_response_differential_genes(
#   lmm_results$summary,
#   config = my_config,
#   drug_name = "Infliximab"  # reference여도 자동 처리
# )
#
# # 또는 reference drug 효과 직접 확인
# ref_effects <- get_reference_drug_effects(
#   lmm_results$summary,
#   config = my_config
# )
#
# # 모든 약물 비교 (reference 포함)
# all_drug_comparison <- compare_all_drug_effects(
#   lmm_results$summary,
#   config = my_config,
#   effect_type = "both",  # response와 time 효과 모두
#   top_n = 50
# )
#
# # 결과 확인
# print(all_drug_comparison$ref_drug)  # "Infliximab"
# View(all_drug_comparison$all_effects)  # 모든 약물 효과
# View(all_drug_comparison$summary)  # wide format

# 4. 분석 실행 - 방법 B: 실제 컬럼명 직접 사용
# simple_formula <- list(
#   fixed = c("treatment", "time"),            # 실제 컬럼명
#   interactions = c("treatment:time"),         # 실제 컬럼명  
#   random = "(1|patient_id)"                  # 실제 컬럼명
# )
# 
# lmm_results <- run_lmm_multiple_genes(
#   seurat_ck_pos,
#   genes = top_genes[1:500],
#   config = my_config,
#   formula_components = simple_formula,
#   use_config_names = FALSE,    # 직접 사용
#   n_cores = 8
# )

# 5. 분석 실행 - 방법 C: formula_components = NULL (기본값 사용)
# lmm_results <- run_lmm_multiple_genes(
#   seurat_ck_pos,
#   genes = top_genes[1:500],
#   config = my_config,
#   formula_components = NULL,    # config 변수 자동 사용
#   n_cores = 8
# )
```

#9 from the nature IM paper
```{r}
library(escape) #BiocManager::install("escape")
library(GSEABase)
library(AnnotationDbi)
library(org.Hs.eg.db)
gene_str=read_xlsx("/data/kjc1/mylit/myR/data/41590_2024_1994_MOESM6_ESM.xlsx", sheet="Inflammation_score")
genes_inflammatory_score <- gene_str %>% pull(1)
# 4. Ensembl ID를 Gene Symbol로 변환
#    mapIds 함수를 사용하여 변환을 수행합니다.
genes_inflammatory_score_symbols <- mapIds(
  org.Hs.eg.db,                              # 사용할 데이터베이스
  keys = genes_inflammatory_score,           # 변환할 Ensembl ID 리스트
  keytype = "ENSEMBL",                       # 입력 키의 타입
  column = "SYMBOL",                         # 출력할 값의 타입 (Gene Symbol)
  multiVals = "first"                        # 중복 매칭 시 첫 번째 값만 사용
)
# 5. 변환 과정에서 NA가 된 값(매칭 실패)들 제거
genes_inflammatory_score_symbols <- na.omit(genes_inflammatory_score_symbols)

expr_matrix_inflammatory_score=GetAssayData(data_seurat, assay="RNA", layer="data")
inflammatory_gene_set <- GeneSet(genes_inflammatory_score_symbols, setName = "InflammatoryScore")
gene_sets_collection <- GeneSetCollection(inflammatory_gene_set)
inflammatory_scores <- enrichIt(
  obj = expr_matrix_inflammatory_score,
  gene.sets = gene_sets_collection,
  cores = 8 # Adjust based on your available CPU cores
)


data_seurat <- AddMetaData(
  object = data_seurat,
  metadata = as.data.frame(inflammatory_scores)
)

# all

VlnPlot(data_seurat, features="InflammatoryScore", group.by="ck", split.by="treatment")
vln_p(data_seurat, feature="InflammatoryScore", group.by="ck", split.by="treatment")
mybox(data_seurat, features="InflammatoryScore", group.by="ck", split.by="treatment", sample_col = "emrid")

# by drugs
vln_p(data.ck, feature="InflammatoryScore", group.by="drug", split.by="treatment")
mybox(data.ck, features="InflammatoryScore", group.by="drug", split.by="treatment", sample_col = "emrid")

vln_p(data.str, feature="InflammatoryScore", group.by="drug", split.by="treatment")
mybox(data.str, features="InflammatoryScore", group.by="drug", split.by="treatment", sample_col = "emrid")

# by response

vln_p(data.ck, feature="InflammatoryScore", group.by="H3", split.by="treatment")
mybox(data.ck, features="InflammatoryScore", group.by="H3", split.by="treatment", sample_col = "emrid")

vln_p(data.str, feature="InflammatoryScore", group.by="H3", split.by="treatment")
mybox(data.str, features="InflammatoryScore", group.by="H3", split.by="treatment", sample_col = "emrid")

vln_p(data.ck, feature="InflammatoryScore", group.by="drug_r", split.by="treatment")
mybox(data.ck, features="InflammatoryScore", group.by="drug_r", split.by="treatment", sample_col = "emrid")

vln_p(data.str, feature="InflammatoryScore", group.by="drug_r", split.by="treatment")
mybox(data.str, features="InflammatoryScore", group.by="drug_r", split.by="treatment", sample_col = "emrid")

# in pre, by drugs
# data.pre.ck
# data.pre.str

vln_p(data.pre, feature="InflammatoryScore", group.by="ck", split.by="drug")
mybox(data.pre, features="InflammatoryScore", group.by="ck", split.by="drug", sample_col = "emrid")

```

#10 using progeny to get TNF signalling score (IM paper)
```{r}
#BiocManager::install("progeny")
library(progeny)
# Seurat 객체를 PROGENy에 맞게 변환하고 경로 활성도를 계산합니다.
# topn = 100은 각 경로별로 가장 큰 영향을 받는 유전자 100개를 사용하라는 의미입니다.
ds_p <- progeny(data_seurat, scale=FALSE, organism="Human", topn=100, perm=1, return_assay = TRUE) #scale and return_assay cannot be both TRUE, because return_assay means that it will return "progeny" assay, and scale means that it will calculate scaling in the function  
ds_p <- ScaleData(ds_p, assay = "progeny")

# 계산된 PROGENy 점수는 Seurat 객체의 새로운 assay ('progeny')에 저장됩니다.
# 점수를 메타데이터로 옮겨 시각화에 용이하게 만듭니다.
progeny_scores <- as.data.frame(t(GetAssayData(ds_p, assay = "progeny", slot = "scale.data")))
head(progeny_scores)

# 기존 메타데이터에 PROGENy 점수를 추가합니다.
data_seurat <- AddMetaData(data_seurat, metadata = progeny_scores)
head(data_seurat@meta.data)


# try
vln_p(data.pre, feature="TNFa", group.by="ck", split.by="drug")
mybox(data.pre, features="TNFa", group.by="ck", split.by="drug", sample_col = "emrid")

vln_p(data.pre, feature=c(names(data_seurat@meta.data)[95:108]), group.by="ck", split.by="drug")

myhm_genes4(data.pre, group ="drug" , assay="RNA", genes=c("TNFa"))
```


# GPT Epithelial .... plotting
##11 function
```{r}
plot_interaction_for_gene_legacy <- function(sobj, gene, assay="RNA", layer="data",
                                      drug_col="drug", nested = FALSE, # ref_drug=NULL,
                                      time_col="treatment", time_levels=c("pre","post"),time_labels=c("pre","post"),
                                      segment_col="ck" ,subset_comp = NULL, 
                                      patient_col="emrid" #,optimizer="bobyqa"
                                      ) {
  # segment_col은 GeoMx를 상정.
  # subset_col은, segment_col에서 어떤 value를 가진 데이터만 subset할 건지,
  # nested는 drug/patient로 nesting하여 분석할 건지 (lmer ~ (1|drug/patient))
  expr=GetAssayData(sobj, assay=assay, layer=layer)
  meta=sobj@meta.data %>%
    mutate(
      time=factor(.data[[time_col]], levels=time_levels,labels=time_labels),
      drug=factor(.data[[drug_col]]),
      patient=factor(.data[[patient_col]]),
      comp=factor(.data[[segment_col]])
    )
  # 선택적 compartment 필터
  if (!is.null(subset_comp)) {
    keep <- meta$comp == subset_comp
  } else {
    keep <- rep(TRUE, nrow(meta))
  }
  y <- as.numeric(expr[gene, keep])
  df <- cbind.data.frame(y = y, meta[keep, , drop = FALSE])

  # 변동성/결측 체크
  if (all(is.na(y)) || sd(y, na.rm = TRUE) == 0) {
    stop(sprintf("Gene %s has no variance or all NA in the selected subset.", gene))
  }

  # 모델: nested = TRUE면 patient가 drug에 nested
  # (1|patient)도 괜찮지만 엄밀히는 patient가 drug에 속하므로 (1|drug/patient) 권장
  if (nested) {
    fit <- lmer(y ~ time * drug + (1 | drug/patient), data = df, REML = FALSE)
  } else {
    fit <- lmer(y ~ time * drug + (1 | patient), data = df, REML = FALSE)
  }

  # 2-1) emmeans로 시간*약제 조합의 추정 평균과 CI
  emm <- emmeans(fit, ~ time * drug)
  emm_df <- as.data.frame(emm) %>%
    mutate(time = factor(time, levels = c("pre","post")))

  p1 <- ggplot(emm_df, aes(x = time, y = emmean, group = drug, color = drug)) +
    geom_point(size = 3) +
    geom_line(size = 1) +
    geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.1) +
    labs(
      title = sprintf("%s: time × drug (estimated marginal means ± 95%% CI)", gene),
      x = "Time", y = "Estimated mean expression"
    ) +
    theme_bw()

  # 2-2) 환자별 pre→post 스파게티 (실측치)
  # (개별 변화의 분산/이질성을 직관적으로 확인)
  df_plot <- df %>%
    dplyr::select(y, time, drug, patient) %>%
    mutate(time = factor(time, levels = c("pre","post")))

  p2 <- ggplot(df_plot, aes(x = time, y = y, group = patient, color = drug)) +
    geom_line(alpha = 0.35) +
    geom_point(size = 2, alpha = 0.7) +
    labs(
      title = sprintf("%s: individual pre→post (raw, by patient)", gene),
      x = "Time", y = "Expression (Q3/log scale)"
    ) +
    theme_bw()

  # 2-3) 약제별 Δ(post-pre) 비교 (emmeans 대비/대조)
  # 각 약제 내 post-pre contrast
  delta_by_drug <- contrast(emm, method = "revpairwise", by = "drug", adjust = "none") %>%
    # revpairwise(pre,post) → (post - pre)로 보려면 pairs(~ time | drug) 사용 권장
    # 아래는 명시적 방법:
    pairs(by = "drug", adjust = "none")
  # 더 직관적인 방식:
  deltas <- contrast(emmeans(fit, ~ time | drug), method = list(delta = c(-1, 1)))
  deltas_df <- as.data.frame(deltas)

  p3 <- ggplot(deltas_df, aes(x = drug, y = estimate, ymin = lower.CL, ymax = upper.CL, color = drug)) +
    geom_pointrange(position = position_dodge(width = 0.2)) +
    geom_hline(yintercept = 0, linetype = 2) +
    labs(
      title = sprintf("%s: Δ(post-pre) by drug (EMMean contrast ± 95%% CI)", gene),
      x = "Drug", y = "Δ(post - pre)"
    ) +
    theme_bw() +
    theme(legend.position = "none")

  # 결과와 객체 반환
  list(
    fit = fit,
    emm = emm_df,
    deltas = deltas_df,
    plot_emmeans = p1,
    plot_spaghetti = p2,
    plot_delta = p3
  )
}
```

##12 usage: heatmap~~~
```{r}
res_IL1B_CK=plot_interaction_for_gene(data_seurat, "IL1B",nested=FALSE,subset_comp=TRUE)
res_IL1B_CK$plot_emmeans   # 시간×약제 상호작용 평균±CI
res_IL1B_CK$plot_spaghetti # 환자별 실측 pre→post
res_IL1B_CK$plot_delta     # 약제별 Δ(post-pre) 비교

genes <- c("IL1B","CXCL8","CXCL2","CXCL1","CXCL3","S100A8","S100A9","TNFRSF6B","CSF3R")
#m.ck, m.str로 시작하면 lmm출신, m.pp로 시작하면 FM 출신.
gcui=m.ck.inf.pre2[order(m.ck.inf.pre2$estimate),]$gene[1:20]
gcdi=m.ck.inf.pre2[order(-m.ck.inf.pre2$estimate),]$gene[1:20]
gcuu=m.ck.ust.pre2[order(m.ck.ust.pre2$estimate),]$gene[1:20]
gcdu=m.ck.ust.pre2[order(-m.ck.ust.pre2$estimate),]$gene[1:20]
gcuv=m.ck.ved.pre2[order(m.ck.ved.pre2$estimate),]$gene[1:20]
gcdv=m.ck.ved.pre2[order(-m.ck.ved.pre2$estimate),]$gene[1:20]
gsui=m.str.inf.pre2[order(m.str.inf.pre2$estimate),]$gene[1:20]
gsdi=m.str.inf.pre2[order(-m.str.inf.pre2$estimate),]$gene[1:20]
gsuu=m.str.ust.pre2[order(m.str.ust.pre2$estimate),]$gene[1:20]
gsdu=m.str.ust.pre2[order(-m.str.ust.pre2$estimate),]$gene[1:20]
gsuv=m.str.ved.pre2[order(m.str.ved.pre2$estimate),]$gene[1:20]
gsdv=m.str.ved.pre2[order(-m.str.ved.pre2$estimate),]$gene[1:20]
guiu=lmm$summary%>% filter(estimate>0, p_value<0.05 ,term=="drugUstekinumab:treatmentpre") %>% arrange(desc(estimate)) %>% pull(gene)
gdiu=lmm$summary%>% filter(estimate<0, p_value<0.05 ,term=="drugUstekinumab:treatmentpre") %>% arrange((estimate)) %>% pull(gene)
guiv=lmm$summary%>% filter(estimate>0, p_value<0.05 ,term=="drugVedolizumab:treatmentpre") %>% arrange(desc(estimate)) %>% pull(gene)
gdiv=lmm$summary%>% filter(estimate<0, p_value<0.05 ,term=="drugVedolizumab:treatmentpre") %>% arrange((estimate)) %>% pull(gene)


res_list <- lapply(genes, function(g) plot_interaction_for_gene(data_seurat, g, subset_comp=FALSE)) %>% set_names(genes)
res_list2 <- lapply(genes, function(g) plot_interaction_for_gene(data.ck, g, subset_comp=TRUE)) %>% set_names(genes)
res_list3 <- lapply(genes, function(g) plot_interaction_for_gene(data.str, g, subset_comp=FALSE)) %>% set_names(genes)
res_list4 <- lapply(gcui, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcui)
res_list5 <- lapply(gcdi, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcdi)
res_list6 <- lapply(gcuu, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcuu)
res_list7 <- lapply(gcdu, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcdu)
res_list8 <- lapply(gcuv, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcuv)
res_list9 <- lapply(gcdv, function(g) plot_interaction_for_gene(data.ck, g, segment_col=NULL)) %>% set_names(gcdv)
res_list4s <- lapply(gsui, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsui)
res_list5s <- lapply(gsdi, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsdi)
res_list6s <- lapply(gsuu, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsuu)
res_list7s <- lapply(gsdu, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsdu)
res_list8s <- lapply(gsuv, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsuv)
res_list9s <- lapply(gsdv, function(g) plot_interaction_for_gene(data.str, g, segment_col=NULL)) %>% set_names(gsdv)
pifg=function(sobj, gene_list){
  return(lapply(gene_list, function(g) plot_interaction_for_gene(sobj, g, segment_col=NULL)) %>% set_names(gene_list))
}

rl_guiu=pifg(data.ck, guiu)
rl_gdiu=pifg(data.ck, gdiu)
rl_guiv=pifg(data.ck, guiv)
rl_gdiv=pifg(data.ck, gdiv)

hm_guiu=plot_delta_heatmap(rl_guiu)
hm_gdiu=plot_delta_heatmap(rl_gdiu)
hm_guiv=plot_delta_heatmap(rl_guiv)
hm_gdiv=plot_delta_heatmap(rl_gdiv)

heatmap_out <- plot_delta_heatmap(res_list)
heatmap_out2 <- plot_delta_heatmap(res_list2)
heatmap_out3 <- plot_delta_heatmap(res_list3)
heatmap_out4 <- plot_delta_heatmap(res_list4)
heatmap_out5 <- plot_delta_heatmap(res_list5)
heatmap_out6 <- plot_delta_heatmap(res_list6)
heatmap_out7 <- plot_delta_heatmap(res_list7)
heatmap_out8 <- plot_delta_heatmap(res_list8)
heatmap_out9 <- plot_delta_heatmap(res_list9)
heatmap_out4s <- plot_delta_heatmap(res_list4s)
heatmap_out5s <- plot_delta_heatmap(res_list5s)
heatmap_out6s <- plot_delta_heatmap(res_list6s)
heatmap_out7s <- plot_delta_heatmap(res_list7s)
heatmap_out8s <- plot_delta_heatmap(res_list8s)
heatmap_out9s <- plot_delta_heatmap(res_list9s)

heatmap_out

res_IL1B_CK2=plot_interaction_for_gene(data.ck.adj, "IL1B",nested=FALSE,segment_col=NULL)
res_IL1B_CK2$plot_emmeans   # 시간×약제 상호작용 평균±CI
res_IL1B_CK2$plot_spaghetti # 환자별 실측 pre→post
res_IL1B_CK2$plot_delta     # 약제별 Δ(post-pre) 비교

res_IL1B_CK3=plot_interaction_for_gene(data.ck, "IL1B",nested=FALSE,segment_col=NULL)
res_IL1B_CK3$plot_emmeans   # 시간×약제 상호작용 평균±CI
res_IL1B_CK3$plot_spaghetti # 환자별 실측 pre→post
res_IL1B_CK3$plot_delta     # 약제별 Δ(post-pre) 비교
```

## 13 function v2

📌 plot_interaction_for_gene v2.0
변경/추가 사항
ref_drug 인자 추가 → 기준 drug 레벨 지정 가능 (NULL이면 factor 첫 레벨).
optimizer 인자 추가 → lmer optimizer 선택 가능 (기본 "bobyqa").
factor 수준 체크 강화 (time, patient 최소 2수준).
confint() 사용하여 항상 lower.CL, upper.CL 포함.
plot_delta_heatmap 추가: 여러 유전자 결과(deltas_df)를 모아 heatmap 요약 가능.
deltas 데이터프레임에 gene 이름을 붙여서 list에 반환.
plot_delta_heatmap는 ComplexHeatmap 또는 ggplot2::geom_tile() 기반. (여기선 ggplot2 버전으로 제공)
```{r}
plot_interaction_for_gene <- function(
  sobj, gene, assay = "RNA", layer = "data",
  drug_col = "drug", nested = FALSE, ref_drug = NULL, 
  time_col = "treatment", time_levels = c("pre","post"), time_labels = c("pre","post"),
  segment_col = "ck",subset_comp = NULL,
  patient_col = "emrid",
  optimizer = "bobyqa"
) {
  # ==== Data prep ====
  expr <- GetAssayData(sobj, assay = assay, slot = layer)
  meta <- sobj@meta.data %>%
    mutate(
      time    = factor(.data[[time_col]], levels = time_levels, labels = time_labels),
      drug    = factor(.data[[drug_col]]),
      patient = factor(.data[[patient_col]])
    )
  if (!is.null(segment_col)){
    meta=meta%>%mutate(
      comp=.data[[segment_col]]
    )
  }else{subset_comp=NULL} #현재 상태로는 comp가 있을지 여부가 갈리므로 후속 분석에 안 좋을 가능성이 크다. 현재는 문제없음.
  
  if (!is.null(subset_comp)) {
    keep <- meta$comp == subset_comp
  } else {
    keep <- rep(TRUE, nrow(meta))
  }
  
  if (!is.null(ref_drug)) meta$drug <- relevel(meta$drug, ref = ref_drug)
  
  y <- as.numeric(expr[gene, keep])
  df <- cbind.data.frame(y = y, meta[keep, , drop = FALSE])

  # ==== Checks ====
  if (all(is.na(y)) || sd(y, na.rm = TRUE) == 0) {
    stop(sprintf("Gene %s has no variance or all NA in this subset.", gene))
  }
  if (nlevels(df$time) < 2) stop("time has <2 levels in this subset.")
  if (nlevels(df$patient) < 2) stop("patient has <2 levels in this subset.")

  # ==== Model ====
  ctrl <- lmerControl(optimizer = optimizer, calc.derivs = TRUE,
                      check.conv.singular = "ignore")
  if (nested) {
    fit <- lmer(y ~ time * drug + (1 | drug/patient),
                data = df, REML = FALSE, control = ctrl)
  } else {
    fit <- lmer(y ~ time * drug + (1 | patient),
                data = df, REML = FALSE, control = ctrl)
  }

  # ==== emmeans ====
  emm <- emmeans(fit, ~ time * drug)
  emm_df <- as.data.frame(confint(emm)) %>%
    mutate(time = factor(time, levels = time_levels, labels = time_labels))

  p1 <- ggplot(emm_df, aes(x = time, y = emmean, group = drug, color = drug)) +
    geom_point(size = 3) +
    geom_line(size = 1) +
    geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.1) +
    labs(
      title = sprintf("%s: time × drug (EMMeans ±95%% CI)", gene),
      x = "Time", y = "Estimated mean expression"
    ) +
    theme_bw()

  # ==== spaghetti ====
  df_plot <- df %>%
    dplyr::select(y, time, drug, patient) %>%
    mutate(time = factor(time, levels = time_levels, labels = time_labels))

  p2 <- ggplot(df_plot, aes(x = time, y = y, group = interaction(patient, drug), color = drug)) +
    geom_line(alpha = 0.35) +
    geom_point(size = 2, alpha = 0.7) +
    labs(
      title = sprintf("%s: individual pre→post (raw)", gene),
      x = "Time", y = "Expression (Q3/log scale)"
    ) +
    theme_bw()

  # ==== delta (post-pre) ====
  em_time_by_drug <- emmeans(fit, ~ time | drug)
  deltas <- contrast(em_time_by_drug, method = list(delta = c(-1, 1)))
  deltas_df <- as.data.frame(confint(deltas)) %>%
    mutate(gene = gene)

  p3 <- ggplot(deltas_df, aes(x = drug, y = estimate,
                              ymin = lower.CL, ymax = upper.CL, color = drug)) +
    geom_pointrange(position = position_dodge(width = 0.2)) +
    geom_hline(yintercept = 0, linetype = 2) +
    labs(
      title = sprintf("%s: Δ(post-pre) by drug (EMMeans ±95%% CI)", gene),
      x = "Drug", y = expression(Delta~"(post - pre)")
    ) +
    theme_bw() +
    theme(legend.position = "none")

  # Return
  list(
    df = df,
    fit = fit,
    emm = emm_df,
    deltas = deltas_df,
    plot_emmeans = p1,
    plot_spaghetti = p2,
    plot_delta = p3
  )
}

plot_delta_heatmap <- function(results_list) {
  # results_list: list of outputs from plot_interaction_for_gene (여러 gene)
  all_deltas <- purrr::map_dfr(results_list, "deltas")
  
  # drug x gene 매트릭스
  mat <- all_deltas %>%
    dplyr::select(gene, drug, estimate) %>%
    tidyr::pivot_wider(names_from = drug, values_from = estimate)
  
  df_long <- all_deltas
  
  p <- ggplot(df_long, aes(x = drug, y = gene, fill = estimate)) +
    geom_tile(color = "white") +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
    labs(title = "Δ(post-pre) heatmap by drug",
         x = "Drug", y = "Gene", fill = expression(Delta)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  list(matrix = mat, plot = p, raw = df_long)
}
```

## 14 MDMP: delta calculator - patient by patient (cell-wise)
```{r}
make_delta_matrix_by_patient <- function(
  sobj,
  assay="RNA", layer="data",
  time_col="treatment", drug_col="drug", patient_col="emrid", segment_col="ck",
  time_levels=c("pre","post"), subset_comp=NULL,
  agg_fun = function(v) mean(v, na.rm=TRUE)
){
  X <- GetAssayData(sobj, assay=assay, layer=layer) # genes x AOIs
  meta <- sobj@meta.data %>%
    mutate(
      time    = factor(.data[[time_col]], levels=time_levels),
      drug    = factor(.data[[drug_col]]),
      patient = factor(.data[[patient_col]]),
      comp    = factor(.data[[segment_col]])
    )
  stopifnot(identical(colnames(X), rownames(meta)))

  if (!is.null(subset_comp)) {
    keep <- meta$comp == subset_comp
    X <- X[, keep, drop=FALSE]
    meta <- meta[keep, , drop=FALSE]
  }
  
  # meta column filtering
  gene_names <- rownames(X)
  
  run=0#
  while(length(which(gene_names%in%names(meta)))>0){
    num_meta_in_gene=which(names(meta)%in%gene_names)
    names(meta)[num_meta_in_gene]=paste0(names(meta)[num_meta_in_gene],"_re")
    run=run+1#
    print(run)#
    if(run>5)break#
  }
  # AOI별 표현을 long으로
  long <- as.data.frame(t(X)) %>%
    tibble::rownames_to_column("AOI") %>%
    cbind(meta, .)

  # pre/post를 같은 환자/약제/comp 안에서 집계 후 Δ = post − pre
  # 메모리 절약을 위해 gene-wise로 루프
  make_delta_one_gene <- function(g){
    dd <- long %>%
      dplyr::select(patient, drug, comp, time, !!sym(g)) %>%
      group_by(patient, drug, comp, time) %>%
      summarise(expr = agg_fun(.data[[g]]), .groups="drop") %>%
      tidyr::pivot_wider(names_from = time, values_from = expr) %>%
      mutate(delta = .data[[time_levels[2]]] - .data[[time_levels[1]]]) %>%
      dplyr::select(patient, drug, comp, delta)
    dd$gene <- g
    dd
  }

  delta_long <- purrr::map_dfr(gene_names, make_delta_one_gene)

  # 샘플 정의: 환자*약제*(comp)
  delta_long <- delta_long %>%
    mutate(sample_id = if (!is.null(subset_comp)) 
             paste(patient, drug, sep="|") else
             paste(patient, drug, comp, sep="|"))

  # gene x sample 행렬
  delta_mat <- delta_long %>%
    dplyr::select(gene, sample_id, delta) %>%
    tidyr::pivot_wider(names_from = sample_id, values_from = delta) %>%
    tibble::column_to_rownames("gene") %>%
    as.matrix()

  # 메타(샘플) 테이블
  sample_meta <- delta_long %>%
    distinct(sample_id, patient, drug, comp) %>%
    tibble::column_to_rownames("sample_id")

  list(delta_mat = delta_mat, sample_meta = sample_meta)
}

# # 예시: CK만 사용
# out <- make_delta_matrix_by_patient(
#   sobj = data_seurat, subset_comp = TRUE,
#   time_col="treatment", drug_col="drug", patient_col="emrid", segment_col="ck",
#   time_levels=c("pre","post")
# )
# 
# # Seurat로 올려서 HVG 선택/스케일/PCA/클러스터링
# delta_mat <- out$delta_mat                       # genes x samples
# sample_meta <- out$sample_meta                   # samples x {patient,drug,comp}
# 
# # Δ 값은 음수/양수 포함 → counts 슬롯 대신 data 슬롯에 넣는 게 안전
# obj_delta <- CreateSeuratObject(counts = matrix(0, nrow=nrow(delta_mat), ncol=ncol(delta_mat)))
# obj_delta[["DELTA"]] <- CreateAssayObject(counts = matrix(0, nrow=nrow(delta_mat), ncol=ncol(delta_mat)))
# DefaultAssay(obj_delta) <- "DELTA"
# obj_delta[["DELTA"]]@data <- delta_mat
# obj_delta <- AddMetaData(obj_delta, sample_meta[ colnames(obj_delta), , drop=FALSE ])
# 
# # HVG는 Δ-변이로 선별 (원하시면 전체 사용도 가능)
# obj_delta <- FindVariableFeatures(obj_delta, selection.method="vst", nfeatures=3000, assay="DELTA")
# 
# # Scale & PCA & UMAP
# obj_delta <- ScaleData(obj_delta, features=VariableFeatures(obj_delta), assay="DELTA", clip.max=3)
# obj_delta <- RunPCA(obj_delta, features=VariableFeatures(obj_delta), assay="DELTA")
# obj_delta <- FindNeighbors(obj_delta, dims=1:20)
# obj_delta <- FindClusters(obj_delta, resolution=0.6)
# obj_delta <- RunUMAP(obj_delta, dims=1:20)
```

### obj_delta
```{r}
out <- make_delta_matrix_by_patient(
  sobj = data_seurat, subset_comp = TRUE,
  time_col="treatment", drug_col="drug", patient_col="emrid", segment_col="ck",
  time_levels=c("pre","post")
)

delta_mat <- out$delta_mat                       # genes x samples
to_drop=colSums(is.na(delta_drop))>0
delta_mat=delta_mat[,!to_drop,drop=FALSE]
sample_meta <- out$sample_meta                   # samples x {patient,drug,comp}


# Δ 값은 음수/양수 포함 → counts 슬롯 대신 data 슬롯에 넣는 게 안전 -> matrix(0, dim(x)[1],dim(x)[2]) 방식은, gene name, cell name 다 없어서 안됨.
obj_delta <- CreateSeuratObject(counts = delta_mat)
obj_delta[["DELTA"]] <- CreateAssayObject(counts = delta_mat)
DefaultAssay(obj_delta) <- "DELTA"
obj_delta[["DELTA"]]@data <- delta_mat
obj_delta <- AddMetaData(obj_delta, sample_meta[ colnames(obj_delta), , drop=FALSE ])


# HVG는 Δ-변이로 선별 (원하시면 전체 사용도 가능)
obj_delta <- FindVariableFeatures(obj_delta, selection.method="vst", nfeatures=3000, assay="DELTA")

# Scale & PCA & UMAP
obj_delta <- ScaleData(obj_delta, features=VariableFeatures(obj_delta), assay="DELTA", clip.max=3)
obj_delta <- RunPCA(obj_delta, features=VariableFeatures(obj_delta), assay="DELTA")
obj_delta <- FindNeighbors(obj_delta, dims=1:20)
obj_delta <- FindClusters(obj_delta, resolution=0.6)
obj_delta <- RunUMAP(obj_delta, dims=1:20)


meta=data_seurat@meta.data
meta2=meta
meta2 %>% count(aoi_id) %>% filter(n > 1) #중복 확인
meta2=meta%>%
  mutate(aoi_id=paste(emrid, drug, ck, sep="|"))%>%
  filter(aoi_id %in% colnames(delta_mat))%>%
  distinct(aoi_id, .keep_all=TRUE)%>% # aoi_id 중복 제거
  set_rownames(NULL)%>% #rownames이 없어야 column_to_rownames가 먹힘
  column_to_rownames("aoi_id") #AddMetaData로 합치기 위해.
obj_delta <- AddMetaData(obj_delta, meta2)


```
#### scoring by cluster DEGs
```{r}
r_m=FindMarkers(obj_delta, ident.1 = 1, group.by="seurat_clusters")
r_mi=FindMarkers(subset(data.pre,drug=="Infliximab"), ident.1 = "NR", group.by="response")
r_mu=FindMarkers(subset(data.pre,drug=="Ustekinumab"), ident.1 = "NR", group.by="response")
r_mv=FindMarkers(subset(data.pre,drug=="Vedolizumab"), ident.1 = "NR", group.by="response")


r_m_p=r_m%>%marker_filter()%>%filter(avg_log2FC>0, p_val_adj<0.05)%>%pull(gene)%>%GeneSet(setName="C1_pos")%>%GeneSetCollection
r_m_n=r_m%>%marker_filter()%>%filter(avg_log2FC<0, p_val_adj<0.05)%>%pull(gene)%>%GeneSet(setName="C1_neg")%>%GeneSetCollection

r_mi_p=r_mi%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="INF_pos")%>%GeneSetCollection
r_mi_n=r_mi%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="INF_neg")%>%GeneSetCollection
r_mu_p=r_mu%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="UST_pos")%>%GeneSetCollection
r_mu_n=r_mu%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="UST_neg")%>%GeneSetCollection
r_mv_p=r_mv%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="VED_pos")%>%GeneSetCollection
r_mv_n=r_mv%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]%>%GeneSet(setName="VED_neg")%>%GeneSetCollection
# expr_matrix_inflammatory_score=GetAssayData(data_seurat, assay="RNA", layer="data")
C1_pos= enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_m_p,cores = 8) # Adjust based on your available CPU cores
C1_neg= enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_m_n,cores = 8) # Adjust based on your available CPU cores

INF_pos=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mi_p,cores = 16) # Adjust based on your available CPU cores
INF_neg=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mi_n,cores = 16) # Adjust based on your available CPU cores
UST_pos=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mu_p,cores = 16) # Adjust based on your available CPU cores
UST_neg=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mu_n,cores = 16) # Adjust based on your available CPU cores
VED_pos=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mv_p,cores = 16) # Adjust based on your available CPU cores
VED_neg=enrichIt(obj = expr_matrix_inflammatory_score,gene.sets = r_mv_n,cores = 16) # Adjust based on your available CPU cores

data_seurat <- AddMetaData(object = data_seurat,metadata = as.data.frame(C1_pos))
data_seurat <- AddMetaData( object = data_seurat,metadata = as.data.frame(C1_neg))
data_seurat <- AddMetaData(object = data_seurat,metadata = as.data.frame(INF_pos))
data_seurat <- AddMetaData( object = data_seurat,metadata = as.data.frame(INF_neg))
data_seurat <- AddMetaData(object = data_seurat,metadata = as.data.frame(UST_pos))
data_seurat <- AddMetaData( object = data_seurat,metadata = as.data.frame(UST_neg))
data_seurat <- AddMetaData(object = data_seurat,metadata = as.data.frame(VED_pos))
data_seurat <- AddMetaData( object = data_seurat,metadata = as.data.frame(VED_neg))

VlnPlot(subset(data_seurat,treatment=="pre"), features=c("C1_pos","C1_neg"), group.by="drug_ck",split.by="response")

VlnPlot(subset(data_seurat,treatment=="pre"), features=c("INF_pos","INF_neg"), group.by="drug_ck",split.by="response")
VlnPlot(subset(data_seurat,treatment=="pre"), features=c("UST_pos","UST_neg"), group.by="drug_ck",split.by="response")
VlnPlot(subset(data_seurat,treatment=="pre"), features=c("VED_pos","VED_neg"), group.by="drug_ck",split.by="response")
```

#### delta of delta!!!
```{r}
obj_dr=subset(obj_delta, response=="R")
obj_dn=subset(obj_delta, response=="NR")

obj_di=subset(obj_delta, drug=="Infliximab")
obj_du=subset(obj_delta, drug=="Ustekinumab")
obj_dv=subset(obj_delta, drug=="Vedolizumab")

r_dm_i=FindMarkers(obj_di, ident.1="NR",group.by="response")
r_dm_u=FindMarkers(obj_du, ident.1="NR",group.by="response")
r_dm_v=FindMarkers(obj_dv, ident.1="NR",group.by="response")

rr_dm_iu=FindMarkers(obj_dr, ident.1="Infliximab",ident.2="Ustekinumab",group.by="drug")
rr_dm_iv=FindMarkers(obj_dr, ident.1="Infliximab",ident.2="Vedolizumab",group.by="drug")
rr_dm_uv=FindMarkers(obj_dr, ident.1="Ustekinumab",ident.2="Vedolizumab",group.by="drug")

rn_dm_iu=FindMarkers(obj_dn, ident.1="Infliximab",ident.2="Ustekinumab",group.by="drug")
rn_dm_iv=FindMarkers(obj_dn, ident.1="Infliximab",ident.2="Vedolizumab",group.by="drug")
rn_dm_uv=FindMarkers(obj_dn, ident.1="Ustekinumab",ident.2="Vedolizumab",group.by="drug")

list_fm1=list(INF_UST=rr_dm_iu%>%marker_filter()%>%filter(avg_log2FC>0, p_val<0.05)%>%pull(gene),
              INF_VED=rr_dm_iv%>%marker_filter()%>%filter(avg_log2FC>0, p_val<0.05)%>%pull(gene),
              UST_VED=rr_dm_uv%>%marker_filter()%>%filter(avg_log2FC>0, p_val<0.05)%>%pull(gene))
list_fm2=list(INF_UST=rr_dm_iu%>%marker_filter()%>%filter(avg_log2FC<0, p_val<0.05)%>%pull(gene),
              INF_VED=rr_dm_iv%>%marker_filter()%>%filter(avg_log2FC<0, p_val<0.05)%>%pull(gene),
              UST_VED=rr_dm_uv%>%marker_filter()%>%filter(avg_log2FC<0, p_val<0.05)%>%pull(gene))
# upset_easy=function(list_fm,sign="+"){
#   if(sign+="+") filter_str1="avg_log2FC>0" else filter_str1="avg_log2FC<0"
#   list_fm1=lapply(list_fm1, FUN = , )
# }

# responder에서 일어나는 일들에 관하여... INF_UST: INF의 difference와, UST의 difference가 어떻게 다른지...
up1=upset_gene_lists(list_fm1)
up2=upset_gene_lists(list_fm2)

```

## DOGE, MDEM, deltas_df; for each drug
```{r}
library(lme4)
library(lmerTest)
library(emmeans)
library(purrr)

# 유전자 1개 -> deltas_df (drug별 Δ와 CI, p) 반환
delta_one_gene_emm <- function(
  sobj, gene,
  nested = FALSE, subset_comp = NULL,
  assay = "RNA", layer = "data",
  time_col = "treatment", time_levels = c("pre","post"),
  drug_col = "drug", patient_col = "emrid", segment_col = "ck",
  ref_drug = NULL, optimizer = "bobyqa"
){
  X <- GetAssayData(sobj, assay=assay, slot=layer)
  meta <- sobj@meta.data %>%
    mutate(
      time    = factor(.data[[time_col]], levels=time_levels),
      drug    = factor(.data[[drug_col]]),
      patient = factor(.data[[patient_col]]),
      comp    = factor(.data[[segment_col]])
    )
  if (!is.null(ref_drug)) meta$drug <- relevel(meta$drug, ref=ref_drug)
  stopifnot(identical(colnames(X), rownames(meta)))

  keep <- if (is.null(subset_comp)) rep(TRUE, nrow(meta)) else meta$comp == subset_comp
  y <- as.numeric(X[gene, keep])
  df <- cbind.data.frame(y = y, meta[keep, , drop=FALSE])

  if (all(is.na(y)) || sd(y, na.rm=TRUE) == 0) return(NULL)
  if (nlevels(df$time) < 2 || nlevels(df$patient) < 2) return(NULL)

  ctrl <- lmerControl(optimizer=optimizer, calc.derivs=TRUE, check.conv.singular="ignore")
  form <- if (nested) y ~ time * drug + (1|drug/patient) else y ~ time * drug + (1|patient)
  fit <- try(lmer(form, data=df, REML=FALSE, control=ctrl), silent=TRUE)
  if (inherits(fit, "try-error")) return(NULL)

  em_time_by_drug <- emmeans(fit, ~ time | drug)
  deltas <- contrast(em_time_by_drug, method=list(delta=c(-1,1)))
  deltas_df <- as.data.frame(confint(deltas))
  deltas_df$gene <- gene
  deltas_df
}

# 여러 유전자 병렬 처리하여 Δ(post-pre) 행렬 (genes x drugs) 구축
make_delta_emm_matrix <- function(
  sobj, genes,
  subset_comp = NULL, nested=FALSE,
  assay="RNA", layer="data",
  time_col="treatment", time_levels=c("pre","post"),
  drug_col="drug", patient_col="emrid", segment_col="ck",
  ref_drug=NULL, optimizer="bobyqa",
  mc.cores = 1
){
  fun <- function(g)
    delta_one_gene_emm(sobj, g, nested, subset_comp, assay, layer,
                       time_col, time_levels, drug_col, patient_col, segment_col,
                       ref_drug, optimizer)
  res_list <- if (mc.cores > 1 && .Platform$OS.type != "windows") {
    parallel::mclapply(genes, fun, mc.cores=mc.cores)
  } else {
    lapply(genes, fun)
  }
  res <- dplyr::bind_rows(res_list)
  if (nrow(res) == 0) stop("No gene produced a delta result.")

  # 행렬화
  mat <- res %>%
    dplyr::select(gene, drug, estimate) %>%
    tidyr::pivot_wider(names_from = drug, values_from = estimate) %>%
    tibble::column_to_rownames("gene") %>%
    as.matrix()

  list(delta_df = res, delta_mat = mat)
}

# # 예시
genes <- rownames(GetAssayData(data_seurat, "RNA", "data"))

emm_out <- make_delta_emm_matrix(
  sobj = data_seurat, genes = genes,
  subset_comp = TRUE, nested = FALSE,
  ref_drug = "Infliximab", optimizer="bobyqa",
  mc.cores = 16
)

emm_out2 <- make_delta_emm_matrix(
  sobj = data_seurat, genes = genes,
  subset_comp = NULL, nested = FALSE,
  assay="RNA", layer="data",
  time_col="treatment", time_levels=c("pre","post"),
  drug_col="drug_r", patient_col="emrid", segment_col="ck",
  ref_drug = "Infliximab _ 0", optimizer="bobyqa",
  mc.cores = 16
)
emm_out3 <- make_delta_emm_matrix(
  sobj = data_seurat, genes = genes,
  subset_comp = TRUE, nested = FALSE,
  assay="RNA", layer="data",
  time_col="treatment", time_levels=c("pre","post"),
  drug_col="drug_r", patient_col="emrid", segment_col="ck",
  ref_drug = "Infliximab _ 0", optimizer="bobyqa",
  mc.cores = 16
)
emm_out4 <- make_delta_emm_matrix(
  sobj = data_seurat, genes = genes,
  subset_comp = FALSE, nested = FALSE,
  assay="RNA", layer="data",
  time_col="treatment", time_levels=c("pre","post"),
  drug_col="drug_r", patient_col="emrid", segment_col="ck",
  ref_drug = "Infliximab _ 0", optimizer="bobyqa",
  mc.cores = 16
)
# 약제별 Δ heatmap
df_long <- emm_out$delta_df
df_long2 <- emm_out2$delta_df
df_long3 <- emm_out3$delta_df
df_long4 <- emm_out4$delta_df

ggplot(df_long, aes(x = drug, y = gene, fill = estimate)) +
  geom_tile() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0) +
  theme_minimal() + theme(axis.text.x = element_text(angle=45, hjust=1))
## outlier때문에...
lims <- quantile(df_long$estimate, probs = c(0.01, 0.99), na.rm=TRUE)
ggplot(df_long, aes(x = drug, y = gene, fill = estimate)) +
  geom_tile() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0,
                       limits = lims, oob=scales::squish) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))

### z score로 시도
df_long <- df_long %>%
  mutate(estimate_z = scale(estimate)[,1])

ggplot(df_long, aes(x = drug, y = gene, fill = estimate_z)) +
  geom_tile() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0) +
  theme_minimal()
```

### drug response signature map: 쓸모 있음.
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(pheatmap)   # 또는 ComplexHeatmap 사용 가능

# df_long: (gene, drug, estimate) 형태 (이미 있으심)

# 1. wide matrix (genes x drugs)
mat <- df_long %>%
  select(gene, drug, estimate) %>%
  pivot_wider(names_from = drug, values_from = estimate) %>%
  tibble::column_to_rownames("gene") %>%
  as.matrix()

mat2 <- df_long %>%
  select(gene, drug, estimate) %>%
  pivot_wider(names_from = drug, values_from = estimate) %>%
  tibble::column_to_rownames("gene") %>%
  as.matrix()

# 2. clipping to reduce outlier influence (quantile-based)
lims <- quantile(mat, probs = c(0.01, 0.99), na.rm=TRUE)
mat_clipped <- pmin(pmax(mat, lims[1]), lims[2])

# 3. optional row-scaling (gene-wise z-score)
#    → 이렇게 하면 각 gene의 drug 간 상대적 반응만 강조됨
mat_scaled <- t(scale(t(mat_clipped)))

# NaN 다수 발견!
mat_scaled_=mat_scaled
mat_scaled <- mat_scaled[!apply(is.nan(mat_scaled), 1, any), , drop = FALSE]
# 4. clustering heatmap
pheatmap(mat_scaled,
         color = colorRampPalette(c("blue","white","red"))(100),
         cluster_rows = TRUE,   # gene clustering
         cluster_cols = TRUE,   # drug clustering도 수행
         show_rownames = FALSE, # gene 이름 너무 많으면 숨기기
         border_color = NA,
         main = "Drug Response Signature Map (Δ post-pre)")

pheatmap(mat,
         color = colorRampPalette(c("blue","white","red"))(100),
         cluster_rows = TRUE,   # gene clustering
         cluster_cols = TRUE,   # drug clustering도 수행
         show_rownames = FALSE, # gene 이름 너무 많으면 숨기기
         border_color = NA,
         main = "Drug Response Signature Map (Δ post-pre)")
```

#### customize
```{r}
obj_mat=GetAssayData(obj_delta, assay="DELTA", layer="data")

# top effect size from each response deg from delta

grip=r_dm_i%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grin=r_dm_i%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]
grup=r_dm_u%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grun=r_dm_u%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]
grvp=r_dm_v%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grvn=r_dm_v%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]

genes_to_see=c(grip,grin,grup,grun,grvp,grvn)

# top significance from each response deg from delta

grip=r_dm_i%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grin=r_dm_i%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grup=r_dm_u%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grun=r_dm_u%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grvp=r_dm_v%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grvn=r_dm_v%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]

genes_to_see=unique(c(genes_to_see,grip,grin,grup,grun,grvp,grvn))


# test_em=emmeans(lmm_all$raw_results$SOCS1$model, ~ treatment | drug)
# lmm_all=run_lmm_multiple_genes(data_seurat,genes = qs_all$top_genes,config = my_config,formula_components = complex_formula1)
obj_mat_to_see=obj_mat[,genes_to_see]

#######################
# 1. 초기 메타데이터 더하기 ---------------------------------------------------------
cn <- colnames(obj_mat_to_see)
parts <- do.call(rbind, strsplit(cn, "\\s*\\|\\s*"))  # 공백 포함 구분
stopifnot(ncol(parts) == 3)
colnames(parts) <- c("emrid", "drug", "tissue_type")

emrid       <- parts[, "emrid"]
drug        <- parts[, "drug"]
tissue_type <- parts[, "tissue_type"]

## 2) emrid 매칭으로 response 추출
# meta$emrid와 타입/공백 정리
meta$emrid <- as.character(meta$emrid)
response_lookup <- setNames(meta$response, meta$emrid)
response <- unname(response_lookup[emrid])  # emrid 순서대로 매핑

## 3) 추가할 행(문자 매트릭스) 구성
ann_rows <- rbind(
  drug        = drug,
  tissue_type = tissue_type,
  response    = response
)

## 4A) 정말 "행으로" 붙이기 (→ 전체가 character로 변환됨)
obj_mat_aug <- rbind(
  apply(obj_mat_to_see, 2, as.character),  # 숫자를 문자로 변환
  ann_rows
)%>%set_rownames(c(rownames(obj_mat_to_see), "drug","tissue_type","response"))
#######################
# 2. 디테일 ---------------------------------------------------------
# 0) annotation 행 분리 ---------------------------------------------------------
ann_rows <- c("drug", "tissue_type", "response")
stopifnot(all(ann_rows %in% rownames(obj_mat_aug)))

drug_raw     <- as.character(obj_mat_aug["drug", ])
tissue_raw   <- as.character(obj_mat_aug["tissue_type", ])
response_raw <- as.character(obj_mat_aug["response", ])

# 표기 바꾸기: tissue_type TRUE → "CK", FALSE → "STR"
tissue <- ifelse(tissue_raw %in% c("TRUE", "T", "1", "true"),
                 "CK", "STR")

drug     <- drug_raw
response <- response_raw

# 1) 표현행렬(genes × samples) 복원 (문자→숫자) -------------------------------
genes <- setdiff(rownames(obj_mat_aug), ann_rows)
mat   <- obj_mat_aug[genes, , drop = FALSE]

# 만약 obj_mat_aug가 character 행렬이면 숫자로 변환
if (!is.numeric(mat[1, 1])) {
  mat <- apply(mat, 2, function(x) as.numeric(x))
  mat <- as.matrix(mat)
  rownames(mat) <- genes
  colnames(mat) <- colnames(obj_mat_aug)
}

# (선택) z-score로 행 표준화: 패턴 중심 클러스터링에 유리
mat_z <- t(scale(t(mat)))   # NA 생기면: mat_z[is.na(mat_z)] <- 0 등으로 처리 가능

# 2) 열 메타데이터(어노테이션) -------------------------------------------------
# 색 매핑
col_drug <- structure(
  setNames(RColorBrewer::brewer.pal(max(3, length(unique(drug))), "Set1")[seq_along(unique(drug))],
           unique(drug))
)
col_tissue <- c(CK = "#F8766D", STR = "#00BFC4")
col_response <- c(R = "#2E8B57", NR = "#D55E00")

ha <- HeatmapAnnotation(
  Drug = drug,
  Tissue = tissue,
  Response = response,
  col = list(
    Drug     = col_drug,
    Tissue   = col_tissue,
    Response = col_response
  ),
  annotation_name_side = "left",
  annotation_legend_param = list(
    Drug     = list(title = "Drug"),
    Tissue   = list(title = "Tissue"),
    Response = list(title = "Response")
  )
)

# 3) 열 분할(슬라이스): drug → tissue → response 순서 --------------------------
# data.frame을 주면 왼쪽부터 순차 분할됨
col_split_df <- data.frame(
  drug = factor(drug, levels = sort(unique(drug))),      # 필요시 원하는 순서로 levels 지정
  tissue = factor(tissue, levels = c("CK","STR")),
  response = factor(response, levels = c("R","NR"))
)

# 4) 색 함수 및 클러스터링 옵션 -----------------------------------------------
col_fun <- colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))  # z-score 기준

ht <- Heatmap(
  mat_z,
  name = "Z", col = col_fun,
  top_annotation = ha,

  # 열 슬라이스: drug → tissue → response
  column_split = col_split_df,
  cluster_column_slices = TRUE,     # 각 슬라이스 내에서만 열 클러스터링

  # 클러스터링 설정(표현 데이터는 보통 상관거리 권장)
  clustering_distance_rows = "pearson",   # 1 - correlation
  clustering_method_rows   = "average",   # UPGMA
  clustering_distance_columns = "pearson",
  clustering_method_columns   = "average",

  show_row_names = FALSE,
  show_column_names = FALSE,
  column_title = "Drug | Tissue | Response",
  heatmap_legend_param = list(title = "Z-score")
)

draw(ht)
#######################



# 1) 표기/순서 고정: Tissue, Response
tissue <- ifelse(tissue_raw %in% c("TRUE", "T", "1", TRUE), "CK", "STR")
tissue_f   <- factor(tissue,   levels = c("CK","STR"))     # 고정
response_f <- factor(response, levels = c("R","NR"))       # 고정

# 2) 열 분할은 Tissue × Response만 사용 (Drug은 분할에 넣지 않음)
col_split <- interaction(tissue_f, response_f, drop = TRUE,
                         sep = " | ")   # 슬라이스 제목 표기용

# 3) 어노테이션 (범례/순서 고정)
col_drug     <- setNames(RColorBrewer::brewer.pal(3, "Set1")[seq_along(unique(drug))],
                         unique(drug))
col_tissue   <- c(CK = "#F8766D", STR = "#00BFC4")
col_response <- c(R  = "#2E8B57", NR  = "#D55E00")

ha <- HeatmapAnnotation(
  Tissue   = tissue_f,    # 맨 위
  Response = response_f,  # 그 다음
  Drug     = drug,        # Drug은 색띠만; 분할 X
  col = list(
    Tissue   = col_tissue,
    Response = col_response,
    Drug     = col_drug
  ),
  annotation_name_side = "left"
)

# 4) 히트맵 (열 클러스터링으로 drug 유사성 정렬)
ht <- Heatmap(
  mat_z,
  name = "Z",
  col = colorRamp2(c(-2, 0, 2), c("blue","white","red")),
  top_annotation = ha,

  column_split = col_split,           # Tissue → Response 슬라이스 고정
  cluster_columns = TRUE,             # 열 클러스터링 활성화
  cluster_column_slices = TRUE,       # 각 슬라이스 내에서만 클러스터링
  clustering_distance_columns = "pearson",
  clustering_method_columns = "average",

  clustering_distance_rows = "pearson",
  clustering_method_rows   = "average",

  show_column_names = FALSE,
  show_row_names    = FALSE,
  column_title = "Tissue | Response (Drug is clustered within slices)",
  heatmap_legend_param = list(title = "Z-score")
)

draw(ht)
```

### 논문 수준 이라주장 - 더 좋긴 함
```{r}
library(dplyr)
library(tidyr)
library(circlize)
library(ComplexHeatmap)

# -------- helper: pathway membership matrix (gene x pathway, 0/1) --------
.make_pathway_mat <- function(genes, gene_sets=list()){
  if (length(gene_sets)==0) return(NULL)
  pws <- names(gene_sets)
  m <- sapply(gene_sets, function(gv) as.integer(genes %in% gv))
  colnames(m) <- pws
  rownames(m) <- genes
  m
}

# -------- helper: p-value 별표 --------
.stars <- function(p){ ifelse(p < 0.001, "***",
                       ifelse(p < 0.01,  "**",
                       ifelse(p < 0.05,  "*", ""))) }

# -------- main plotting function --------
plot_drug_response_map <- function(
  df_long,                      # gene, drug, estimate
  drug_annot = NULL,            # optional: drug, class, route ...
  gene_sets = list(),           # optional: list(pathway = c(genes))
  sig_df = NULL,                # optional: gene, drug, p_adj
  clip_q = c(0.01, 0.99),       # quantile clipping to tame outliers
  scale_row = TRUE,             # gene-wise z
  show_rownames = FALSE,
  show_colnames = TRUE,
  top_n_genes = NULL,           # 선택: 상위 변이 gene만 (예: 2000)
  row_split_k = NULL,           # 선택: 행 클러스터 k-split
  col_split_k = NULL            # 선택: 열 클러스터 k-split
){
  # 1) wide matrix
  mat <- df_long %>%
    select(gene, drug, estimate) %>%
    pivot_wider(names_from = drug, values_from = estimate) %>%
    tibble::column_to_rownames("gene") %>%
    as.matrix()

  # 2) optional gene filter by variance
  if (!is.null(top_n_genes)) {
    v <- apply(mat, 1, function(x) var(x, na.rm=TRUE))
    keep <- names(sort(v, decreasing=TRUE))[seq_len(min(top_n_genes, length(v)))]
    mat <- mat[keep, , drop=FALSE]
  }

  # 3) clipping
  qlims <- quantile(mat, probs = clip_q, na.rm = TRUE)
  mat_clip <- pmin(pmax(mat, qlims[1]), qlims[2])

  # 4) row scaling (gene-wise z)
  if (scale_row) {
    mat_use <- t(scale(t(mat_clip)))
  } else {
    mat_use <- mat_clip
  }
  mat_use[is.na(mat_use)] <- 0  # 안전장치

  # 5) color scale (대칭)
  col_fun <- colorRamp2(c(min(mat_use), 0, max(mat_use)), c("blue","white","red"))

  # 6) column annotation (drug info)
  ha_col <- NULL
  if (!is.null(drug_annot)) {
    drug_annot <- as.data.frame(drug_annot)
    rownames(drug_annot) <- drug_annot$drug
    drug_annot <- drug_annot[colnames(mat_use), setdiff(colnames(drug_annot),"drug"), drop=FALSE]
    # 범주형에 대한 색 자동 생성
    ann_cols <- lapply(drug_annot, function(v){
      if (is.numeric(v)) NULL else
        structure(scales::hue_pal()(length(unique(v))), names=unique(v))
    })
    ha_col <- HeatmapAnnotation(df = drug_annot, col = ann_cols, which = "column")
  }

  # 7) row annotation: pathway membership (bar/dot)
  ha_row <- NULL
  pw_mat <- .make_pathway_mat(rownames(mat_use), gene_sets)
  if (!is.null(pw_mat)) {
    # pathway count bar
    pw_count <- rowSums(pw_mat)
    ha_row <- rowAnnotation(
      pw_count = anno_barplot(pw_count, gp = gpar(fill="#888888", col=NA), width = unit(0.8,"cm"))
    )
  }

  # 8) 유의성 별표 overlay (선택)
  layer_fun <- NULL
  if (!is.null(sig_df)) {
    sig_df <- sig_df %>% mutate(star = .stars(p_adj))
    # matrix of stars aligned to mat_use
    star_mat <- matrix("", nrow=nrow(mat_use), ncol=ncol(mat_use),
                       dimnames = dimnames(mat_use))
    common_genes <- intersect(rownames(mat_use), sig_df$gene)
    common_drugs <- intersect(colnames(mat_use), sig_df$drug)
    sig_sub <- sig_df %>% filter(gene %in% common_genes, drug %in% common_drugs)
    idx_r <- match(sig_sub$gene, rownames(mat_use))
    idx_c <- match(sig_sub$drug, colnames(mat_use))
    star_mat[cbind(idx_r, idx_c)] <- sig_sub$star

    layer_fun <- function(j, i, x, y, w, h, fill){
      grid.text(star_mat[i, j], x, y, gp = gpar(col = "black", fontsize = 8))
    }
  }

  # 9) Heatmap 생성
  ht <- Heatmap(
    mat_use,
    name = "Δ (scaled)",
    col = col_fun,
    cluster_rows = TRUE, cluster_columns = TRUE,
    show_row_names = show_rownames,
    show_column_names = show_colnames,
    top_annotation = ha_col,
    left_annotation = ha_row,
    row_split = row_split_k,
    column_split = col_split_k,
    border = FALSE,
    rect_gp = gpar(col = NA),
    cell_fun = layer_fun,
    column_names_rot = 45
  )

  draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
  invisible(list(matrix = mat_use, heatmap = ht))
}


```
#### 사용예시
```{r}
# # df_long: (gene, drug, estimate)
# drug_annot 예: data.frame(drug=c("Infliximab","Vedolizumab","Ustekinumab"),
#                           class=c("TNF","Integrin","IL12/23"),
#                           route=c("IV","IV","IV"))
drug_annot=data.frame(drug=c("Infliximab","Vedolizumab","Ustekinumab"),
                          class=c("TNF","Integrin","IL12/23"),
                          route=c("IV","IV","IV"))
drug_annot2=data.frame(drug=c("Infliximab _ 0","Infliximab _ 1", "Vedolizumab _ 0","Vedolizumab _ 1","Ustekinumab _ 0","Ustekinumab _ 1"),
                          class=c("TNF","TNF","Integrin","Integrin","IL12/23","IL12/23"),
                          route=c("IV","IV","IV"))

out <- plot_drug_response_map(
  df_long,
  drug_annot = drug_annot,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)

out2 =plot_drug_response_map(
  df_long2,
  drug_annot = drug_annot2,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)

out3 =plot_drug_response_map(
  df_long3,
  drug_annot = drug_annot2,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)

out4 =plot_drug_response_map(
  df_long4,
  drug_annot = drug_annot2,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)
grip=r_mi%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grin=r_mi%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]
grup=r_mu%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grun=r_mu%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]
grvp=r_mv%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(desc(avg_log2FC))%>%pull(gene)%>%.[1:50]
grvn=r_mv%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(avg_log2FC)%>%pull(gene)%>%.[1:50]

grip=r_mi%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grin=r_mi%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grup=r_mu%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange((p_val))%>%pull(gene)%>%.[1:50]
grun=r_mu%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]
grvp=r_mv%>%marker_filter()%>%filter(avg_log2FC>0)%>%arrange((p_val))%>%pull(gene)%>%.[1:50]
grvn=r_mv%>%marker_filter()%>%filter(avg_log2FC<0)%>%arrange(p_val)%>%pull(gene)%>%.[1:50]

genes_res=c(grip,grin,grup,grun,grvp,grvn)
df_long3_=df_long3%>%filter(gene%in%genes_res)
df_long4_=df_long4%>%filter(gene%in%genes_res)
out5 =plot_drug_response_map(
  df_long3_,
  drug_annot = drug_annot2,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)

out6 =plot_drug_response_map(
  df_long4_,
  drug_annot = drug_annot2,
  gene_sets = list(
    TNF_pathway = c("TNF","NFKBIA","CXCL8","CXCL1","IL1B","CCL20"),
    IFNG_pathway= c("IFNG","STAT1","CXCL9","CXCL10","CXCL11"),
    IL17_pathway= c("IL17A","IL17F","CSF3","S100A8","S100A9")
  ),
  sig_df = df_long %>% mutate(p_adj = 1), # 예시: 유의성 없으면 생략 가능
  clip_q = c(0.01, 0.99),
  scale_row = TRUE,
  show_rownames = FALSE,
  top_n_genes = 2000
)
```

# parity checker
```{r}
library(dplyr)
library(tidyr)
library(glue)

diagnosis_parity <- function(sobj, patient, treatment, timepoint, tissue,
                             check_key, check_values) {
  # 1) 메타데이터 + unique_id 만들기
  meta <- sobj@meta.data %>%
    mutate(
      unique_id = paste0({{patient}}, {{treatment}}, {{timepoint}}, {{tissue}}),
      .val_chr  = as.character(.data[[check_key]])  # factor 안전 처리
    )
  
  # 2) 필터: 각 unique_id 그룹에 check_values가 "모두" 실제 관측되었는지
  filt <- meta %>%
    group_by(unique_id) %>%
    filter(all(check_values %in% .val_chr)) %>%
    ungroup()

  # 3) 진단 테이블: 각 unique_id별로 check_values의 개수와 기타(n_other) 계산
  totals <- filt %>%
    count(unique_id, name = "total_n")

  counts_sel <- filt %>%
    filter(.val_chr %in% check_values) %>%
    count(unique_id, .val_chr) %>%
    tidyr::pivot_wider(names_from = .val_chr, values_from = n, values_fill = 0)

  diag <- totals %>%
    left_join(counts_sel, by = "unique_id") %>%
    # 혹시라도 존재하지 않는 컬럼이 생기면 0으로 채움
    mutate(across(all_of(intersect(check_values, names(.))), ~replace_na(.x, 0))) %>%
    # n_other = 전체 - 선택값들의 합
    rowwise() %>%
    mutate(
      n_selected = sum(c_across(all_of(check_values))[!is.na(c_across(all_of(check_values)))]),
      n_other    = total_n - n_selected,
      # has_all: 모든 check_values가 최소 1개 이상
      has_all    = all(c_across(all_of(check_values)) > 0, na.rm = TRUE),
      # parity: 선택한 값들의 개수가 서로 모두 동일(= pre/post가 같음, 3개면 모두 같음)
      parity_eq  = { 
        vals <- c_across(all_of(check_values))
        vals <- vals[!is.na(vals)]
        length(vals) > 0 && length(unique(vals)) == 1
      },
      ok = has_all && parity_eq && n_other == 0
    ) %>%
    ungroup()

  # 4) 패스 못 한 id 메시지
  no_pass_ids <- diag %>% filter(!ok) %>% pull(unique_id)
  msg <- if (length(no_pass_ids) == 0) {
    "✅ All groups passed parity & exclusivity checks."
  } else {
    glue("checkout {paste(no_pass_ids, collapse = ', ')}")
  }

  # 5) 결과 반환(진단표 + 메시지 + 필터된 데이터)
  list(
    diag_table = diag,
    filtered_meta = filt,
    message = msg
  )
}

diagnosis_parity_detailed <- function(sobj,
                                      patient=NULL, treatment=NULL, timepoint=NULL, tissue=NULL,   # 문자열 컬럼명 허용
                                      check_key, check_values) {
  # 동적 진단 열 이름: "pre","post" -> "n_pre","n_post"
  safe_counts_names <- paste0("n_", make.names(check_values, unique = TRUE))
  
  make_unique_id <- function(meta, patient=NULL, treatment=NULL, timepoint=NULL, tissue=NULL, check_key=NULL) {
    # unique_id를 만들 때 쓸 후보
    cols <- c(patient, treatment, timepoint, tissue)
  
    # check_key가 들어있으면 제외
    cols <- cols[!cols %in% check_key]
  
    # NULL 제거
    cols <- cols[!sapply(cols, is.null)]
  
    # 조합
    if (length(cols) == 0) {
      meta$unique_id <- seq_len(nrow(meta))  # 전부 NULL이면 그냥 row별 고유 번호
    } else {
      meta <- meta %>%
        mutate(across(all_of(cols), ~ tidyr::replace_na(as.character(.x), ""))) %>%
        mutate(unique_id = do.call(paste0, .[cols]))
    }
    meta
  }
  
  meta <- sobj@meta.data %>%
    make_unique_id(patient=patient,
                 treatment=treatment,
                 timepoint=timepoint,
                 tissue=tissue,
                 check_key=check_key) %>%
    mutate(
      .val_chr  = as.character(.data[[check_key]])
    )

  # unique_id별 전체 개수
  totals <- meta %>% count(unique_id, name = "total_n")

  # 선택값 카운트 (없어도 0으로 생성되도록 complete + pivot_wider)
  counts_sel <- meta %>%
    mutate(.val_chr = factor(.val_chr, levels = check_values)) %>%
    count(unique_id, .val_chr) %>%
    complete(unique_id, .val_chr, fill = list(n = 0)) %>%
    pivot_wider(names_from = .val_chr, values_from = n, values_fill = 0)

  # pivot에서 특정 값 컬럼 자체가 안 생긴 경우 대비해서 강제 추가
  for (v in check_values) {
    if (!hasName(counts_sel, v)) counts_sel[[v]] <- 0L
  }

  # 읽기 쉬운 이름으로 통일: pre -> n_pre, post -> n_post ...
  counts_sel <- counts_sel %>%
    rename_with(~ paste0("n_", make.names(.x, unique = TRUE)),
                .cols = all_of(check_values))

  # 진단 테이블 계산 (rowwise 없이)
  diag_table <- totals %>%
    left_join(counts_sel, by = "unique_id") %>%
    mutate(across(c(total_n, all_of(safe_counts_names)),
                  ~ replace_na(.x, 0))) %>%
    mutate(
      # 선택값 합계
      n_selected = reduce(across(all_of(safe_counts_names)), `+`),
      # 모든 선택값이 최소 1개 이상인가?
      has_all    = if_all(all_of(safe_counts_names), ~ .x > 0),
      # 선택값들의 개수가 모두 동일한가? (pre==post==... 형태)
      parity_eq  = pmap_lgl(across(all_of(safe_counts_names)),
                            ~ { v <- c(...); length(unique(v)) == 1 }),
      # 기타 값 개수
      n_other    = total_n - n_selected,
      # 최종 통과 조건(원래 의도 유지)
      ok         = has_all & parity_eq & n_other == 0
    ) %>%
    dplyr::select(unique_id, total_n, all_of(safe_counts_names),
           n_selected, n_other, has_all, parity_eq, ok)

  # 원본 롱형 테이블에 진단 열 조인
  detailed <- meta %>% left_join(diag_table, by = "unique_id")

  # 실패 id 메시지
  no_pass_ids <- diag_table %>% filter(!ok) %>% pull(unique_id)
  msg <- if (length(no_pass_ids) == 0) {
    "✅ All groups passed parity & exclusivity checks."
  } else {
    sprintf("checkout %s", paste(no_pass_ids, collapse = ", "))
  }
  print(msg)
  print("View($detailed)")
  print("View($diag_table)")
  ok_id=detailed%>%
    filter(ok)%>%
    pull(SegmentDisplayName)
  
  list(
    detailed    = detailed,    # 원본 행 + n_pre/n_post/... + ok 등
    diag_table  = diag_table,  # id별 한 줄 요약
    message     = msg,
    paired_ids = ok_id
  )
}
```
## use
```{r}
res <- diagnosis_parity(
    sobj = data_seurat,
    patient = "emrid", treatment = "drug", timepoint = "treatment", tissue = "ck_",
    check_key = "treatment",            # 검증할 열 이름(문자열)
    check_values = c("pre","post")      # 페어로 맞춰야 할 값들
)

res <- diagnosis_parity_detailed (
    sobj = data_seurat,
    patient = "emrid", treatment = "drug", timepoint = "treatment", tissue = "ck_",
    check_key = "treatment",            # 검증할 열 이름(문자열)
    check_values = c("pre","post")      # 페어로 맞춰야 할 값들
)
```
# another teacher in claude
```{r}
# ========================================
# ENHANCED: Pairwise Comparisons & Effect Adjustment
# ========================================

#' Enhanced LMM with all pairwise comparisons
#' @description Fits LMM with explicit pairwise comparisons for all factor levels
fit_lmm_pairwise <- function(gene_expr,
                            metadata,
                            config = create_analysis_config(),
                            formula_components = NULL,
                            reference_levels = NULL,
                            compute_pairwise = TRUE,
                            use_emmeans = TRUE) {
  
  # 데이터프레임 생성
  df <- cbind(
    data.frame(Expression = gene_expr),
    metadata
  )
  
  # Reference levels 설정
  if (!is.null(reference_levels)) {
    for (var in names(reference_levels)) {
      if (var %in% names(df)) {
        df[[var]] <- relevel(as.factor(df[[var]]), ref = reference_levels[[var]])
      }
    }
  }
  
  # Formula 생성 (기존 코드와 동일)
  if (is.null(formula_components)) {
    fixed_effects <- c(config$drug, config$timepoint, config$response)
    interactions <- c(
      paste(config$drug, config$timepoint, sep = ":"),
      paste(config$drug, config$response, sep = ":"),
      paste(config$timepoint, config$response, sep = ":"),
      paste(config$drug, config$timepoint, config$response, sep = ":")
    )
    random <- paste0("(1|", config$patient, ")")
    
    formula_str <- paste0(
      "Expression ~ ",
      paste(c(fixed_effects, interactions), collapse = " + "),
      " + ", random
    )
  } else {
    # formula_components 제공 시 (기존 로직)
    formula_str <- construct_formula_string(formula_components, config, use_config_names = TRUE)
  }
  
  # 모델 적합
  tryCatch({
    model <- lmer(as.formula(formula_str), data = df, REML = FALSE)
    
    # 기본 결과
    coef_summary <- summary(model)$coefficients
    anova_result <- anova(model)
    
    # 1. PAIRWISE COMPARISONS using emmeans
    pairwise_results <- list()
    
    if (compute_pairwise && use_emmeans) {
      library(emmeans)
      
      # Drug main effect pairwise
      if (config$drug %in% names(df) && length(unique(df[[config$drug]])) > 2) {
        emm_drug <- emmeans(model, specs = config$drug)
        pairwise_drug <- pairs(emm_drug, adjust = "tukey")
        pairwise_results$drug_main <- as.data.frame(pairwise_drug)
        pairwise_results$drug_main$comparison_type <- "drug_main_effect"
      }
      
      # Drug x Response interaction pairwise
      if (config$drug %in% names(df) && config$response %in% names(df)) {
        emm_drug_response <- emmeans(model, 
                                    specs = c(config$drug, config$response))
        
        # Within response comparisons
        pairwise_within_response <- pairs(emm_drug_response, 
                                         by = config$response,
                                         adjust = "tukey")
        pairwise_results$drug_within_response <- as.data.frame(pairwise_within_response)
        pairwise_results$drug_within_response$comparison_type <- "drug_within_response"
        
        # Within drug comparisons
        pairwise_within_drug <- pairs(emm_drug_response,
                                     by = config$drug,
                                     adjust = "tukey")
        pairwise_results$response_within_drug <- as.data.frame(pairwise_within_drug)
        pairwise_results$response_within_drug$comparison_type <- "response_within_drug"
      }
      
      # Drug x Timepoint interaction pairwise
      if (config$drug %in% names(df) && config$timepoint %in% names(df)) {
        emm_drug_time <- emmeans(model,
                               specs = c(config$drug, config$timepoint))
        
        pairwise_drug_time <- pairs(emm_drug_time,
                                   by = config$timepoint,
                                   adjust = "tukey")
        pairwise_results$drug_within_time <- as.data.frame(pairwise_drug_time)
        pairwise_results$drug_within_time$comparison_type <- "drug_within_timepoint"
      }
      
      # Triple interaction if exists
      if (all(c(config$drug, config$timepoint, config$response) %in% names(df))) {
        emm_triple <- emmeans(model,
                            specs = c(config$drug, config$timepoint, config$response))
        
        # Drug comparisons at each timepoint x response combination
        pairwise_triple <- pairs(emm_triple,
                               by = c(config$timepoint, config$response),
                               adjust = "tukey")
        pairwise_results$drug_by_time_response <- as.data.frame(pairwise_triple)
        pairwise_results$drug_by_time_response$comparison_type <- "drug_by_time_and_response"
      }
    }
    
    # 2. Manual pairwise contrasts (alternative method)
    if (compute_pairwise && !use_emmeans) {
      pairwise_results <- compute_manual_pairwise(model, df, config)
    }
    
    # Combine all pairwise results
    if (length(pairwise_results) > 0) {
      all_pairwise <- do.call(rbind, lapply(names(pairwise_results), function(x) {
        df_pw <- pairwise_results[[x]]
        if (!"contrast" %in% names(df_pw) && "contrast" %in% names(df_pw)) {
          names(df_pw)[names(df_pw) == "contrast"] <- "contrast"
        }
        df_pw
      }))
    } else {
      all_pairwise <- NULL
    }
    
    # Original effects (from model coefficients)
    effects <- data.frame(
      term = rownames(coef_summary),
      estimate = coef_summary[, "Estimate"],
      std_error = coef_summary[, "Std. Error"],
      t_value = coef_summary[, "t value"],
      p_value = coef_summary[, "Pr(>|t|)"]
    )
    
    return(list(
      model = model,
      effects = effects,
      pairwise = all_pairwise,
      pairwise_list = pairwise_results,
      anova = anova_result,
      converged = TRUE,
      formula = formula_str
    ))
    
  }, error = function(e) {
    return(list(
      converged = FALSE,
      error = e$message,
      formula = formula_str
    ))
  })
}

#' Manual pairwise contrast computation
compute_manual_pairwise <- function(model, df, config) {
  library(multcomp)
  
  results <- list()
  
  # Get unique levels for each factor
  if (config$drug %in% names(df)) {
    drug_levels <- unique(as.character(df[[config$drug]]))
    n_drugs <- length(drug_levels)
    
    if (n_drugs > 2) {
      # Create contrast matrix for all pairwise comparisons
      drug_pairs <- combn(drug_levels, 2)
      contrasts <- list()
      
      for (i in 1:ncol(drug_pairs)) {
        pair_name <- paste(drug_pairs[1,i], "-", drug_pairs[2,i])
        
        # Create contrast vector
        contrast_vec <- rep(0, length(fixef(model)))
        
        # Find relevant coefficients
        term1 <- paste0(config$drug, drug_pairs[1,i])
        term2 <- paste0(config$drug, drug_pairs[2,i])
        
        coef_names <- names(fixef(model))
        
        # Set contrast weights
        if (term1 %in% coef_names) contrast_vec[which(coef_names == term1)] <- 1
        if (term2 %in% coef_names) contrast_vec[which(coef_names == term2)] <- -1
        
        # Handle reference level
        if (!term1 %in% coef_names && !term2 %in% coef_names) {
          # Both are reference - no contrast needed
          next
        } else if (!term1 %in% coef_names) {
          # term1 is reference
          contrast_vec[which(coef_names == term2)] <- -1
        } else if (!term2 %in% coef_names) {
          # term2 is reference
          contrast_vec[which(coef_names == term1)] <- 1
        }
        
        contrasts[[pair_name]] <- contrast_vec
      }
      
      # Compute contrasts
      if (length(contrasts) > 0) {
        contrast_matrix <- do.call(rbind, contrasts)
        glht_result <- glht(model, linfct = contrast_matrix)
        summary_glht <- summary(glht_result, test = adjusted("none"))
        
        results$drug_pairwise <- data.frame(
          contrast = names(contrasts),
          estimate = summary_glht$test$coefficients,
          std_error = summary_glht$test$sigma,
          z_value = summary_glht$test$tstat,
          p_value = summary_glht$test$pvalues
        )
      }
    }
  }
  
  return(results)
}

# ========================================
# EFFECT ADJUSTMENT - Extract adjusted values
# ========================================

#' Extract random effects from fitted model
extract_random_effects <- function(model) {
  ranef_list <- ranef(model)
  
  # Convert to data frame
  ranef_df <- do.call(rbind, lapply(names(ranef_list), function(group) {
    effects <- ranef_list[[group]]
    data.frame(
      group = group,
      level = rownames(effects),
      effect = effects[,1],
      stringsAsFactors = FALSE
    )
  }))
  
  return(ranef_df)
}

#' Get expression values adjusted for random effects
#' @description Removes random effects to get population-level values
get_random_adjusted_expression <- function(model, original_expr, metadata, config) {
  
  # Get fitted values (includes all effects)
  fitted_vals <- fitted(model)
  
  # Get random effects
  ranef_vals <- ranef(model)
  
  # Calculate random effect contribution for each observation
  random_contribution <- rep(0, length(original_expr))
  
  # Patient random effects
  if (config$patient %in% names(metadata)) {
    patient_effects <- ranef_vals[[paste0("(Intercept)|", config$patient)]]
    
    # Match each observation to its patient effect
    for (i in 1:length(original_expr)) {
      patient_id <- as.character(metadata[[config$patient]][i])
      if (patient_id %in% rownames(patient_effects)) {
        random_contribution[i] <- patient_effects[patient_id, "(Intercept)"]
      }
    }
  }
  
  # Adjusted expression = fitted - random effects
  adjusted_expr <- fitted_vals - random_contribution
  
  return(data.frame(
    original = original_expr,
    fitted = fitted_vals,
    random_effect = random_contribution,
    adjusted = adjusted_expr,
    residual = residuals(model)
  ))
}

#' Get expression values adjusted for fixed effects
#' @description Removes specific fixed effects while keeping others
get_fixed_adjusted_expression <- function(model, 
                                        original_expr,
                                        metadata,
                                        config,
                                        remove_effects = c("drug")) {
  
  # Get model matrix
  X <- model.matrix(model)
  beta <- fixef(model)
  
  # Calculate contribution of effects to remove
  remove_contribution <- rep(0, nrow(X))
  
  for (effect in remove_effects) {
    # Find columns related to this effect
    effect_cols <- grep(effect, colnames(X), ignore.case = TRUE)
    
    if (length(effect_cols) > 0) {
      # Calculate contribution
      remove_contribution <- remove_contribution + 
        as.vector(X[, effect_cols, drop = FALSE] %*% beta[effect_cols])
    }
  }
  
  # Adjusted values = original - effect contribution
  adjusted_expr <- original_expr - remove_contribution
  
  return(data.frame(
    original = original_expr,
    effect_removed = remove_contribution,
    adjusted = adjusted_expr
  ))
}

#' Create adjusted expression matrix for multiple genes
#' @description Batch process adjustment for multiple genes
create_adjusted_matrix <- function(seurat_obj,
                                 lmm_results,
                                 config,
                                 adjustment_type = "random",
                                 remove_effects = NULL) {
  
  # Get expression matrix
  expr_matrix <- GetAssayData(seurat_obj, slot = "data")
  metadata <- seurat_obj@meta.data
  
  # Initialize adjusted matrix
  adjusted_matrix <- expr_matrix
  
  # Get converged genes
  converged_genes <- names(lmm_results$raw_results)[
    sapply(lmm_results$raw_results, function(x) x$converged)
  ]
  
  message(sprintf("Adjusting %d genes...", length(converged_genes)))
  
  # Process each gene
  for (gene in converged_genes) {
    model <- lmm_results$raw_results[[gene]]$model
    original_expr <- as.numeric(expr_matrix[gene, ])
    
    if (adjustment_type == "random") {
      adj_result <- get_random_adjusted_expression(
        model, original_expr, metadata, config
      )
      adjusted_matrix[gene, ] <- adj_result$adjusted
      
    } else if (adjustment_type == "fixed") {
      adj_result <- get_fixed_adjusted_expression(
        model, original_expr, metadata, config,
        remove_effects = remove_effects
      )
      adjusted_matrix[gene, ] <- adj_result$adjusted
      
    } else if (adjustment_type == "residual") {
      # Just get residuals
      adjusted_matrix[gene, ] <- residuals(model)
    }
  }
  
  # Create new Seurat object with adjusted values
  seurat_adjusted <- CreateSeuratObject(
    counts = adjusted_matrix,
    meta.data = metadata
  )
  
  return(seurat_adjusted)
}

# ========================================
# ENHANCED WORKFLOW with pairwise comparisons
# ========================================

#' Enhanced multiple gene analysis with pairwise
run_lmm_pairwise_multiple <- function(seurat_obj,
                                     genes = NULL,
                                     config = create_analysis_config(),
                                     formula_components = NULL,
                                     reference_levels = NULL,
                                     compute_pairwise = TRUE,
                                     n_cores = 4,
                                     verbose = TRUE) {
  
  if (is.null(genes)) {
    genes <- rownames(seurat_obj)[1:100]
    warning("No genes specified. Using first 100 genes.")
  }
  
  expr_matrix <- GetAssayData(seurat_obj, slot = "data")
  metadata <- seurat_obj@meta.data
  
  if (verbose) {
    message(sprintf("Running LMM with pairwise comparisons for %d genes using %d cores...", 
                   length(genes), n_cores))
  }
  
  # Sequential processing for now (parallel needs more setup for emmeans)
  results <- list()
  
  for (i in seq_along(genes)) {
    gene <- genes[i]
    
    if (verbose && i %% 50 == 0) {
      message(sprintf("  Processing gene %d/%d: %s", i, length(genes), gene))
    }
    
    if (gene %in% rownames(expr_matrix)) {
      result <- fit_lmm_pairwise(
        gene_expr = as.numeric(expr_matrix[gene, ]),
        metadata = metadata,
        config = config,
        formula_components = formula_components,
        reference_levels = reference_levels,
        compute_pairwise = compute_pairwise
      )
      result$gene <- gene
      results[[gene]] <- result
    }
  }
  
  # Summarize results
  summary_df <- summarize_pairwise_results(results, config)
  
  return(list(
    raw_results = results,
    summary = summary_df$main_effects,
    pairwise_summary = summary_df$pairwise,
    converged_genes = sum(sapply(results, function(x) x$converged)),
    total_genes = length(genes)
  ))
}

#' Summarize pairwise results
summarize_pairwise_results <- function(results, config) {
  
  converged <- results[sapply(results, function(x) x$converged)]
  
  if (length(converged) == 0) {
    return(list(main_effects = NULL, pairwise = NULL))
  }
  
  # Main effects summary
  main_effects <- do.call(rbind, lapply(names(converged), function(gene) {
    effects <- converged[[gene]]$effects
    effects$gene <- gene
    return(effects)
  }))
  
  # Pairwise summary
  pairwise_all <- do.call(rbind, lapply(names(converged), function(gene) {
    if (!is.null(converged[[gene]]$pairwise)) {
      pw <- converged[[gene]]$pairwise
      pw$gene <- gene
      return(pw)
    }
    return(NULL)
  }))
  
  # Add adjusted p-values
  if (!is.null(main_effects)) {
    main_effects <- main_effects %>%
      group_by(term) %>%
      mutate(p_adj = p.adjust(p_value, method = "BH")) %>%
      ungroup()
  }
  
  if (!is.null(pairwise_all)) {
    pairwise_all <- pairwise_all %>%
      group_by(comparison_type, contrast) %>%
      mutate(p_adj_global = p.adjust(p_value, method = "BH")) %>%
      ungroup()
  }
  
  return(list(
    main_effects = main_effects,
    pairwise = pairwise_all
  ))
}

# ========================================
# VISUALIZATION for pairwise comparisons
# ========================================

#' Plot pairwise comparison results
plot_pairwise_heatmap <- function(pairwise_summary,
                                 comparison_type = "drug_main_effect",
                                 top_genes = 50,
                                 p_threshold = 0.05) {
  
  # Filter for comparison type and significant results
  plot_data <- pairwise_summary %>%
    filter(comparison_type == !!comparison_type,
           p_adj_global < p_threshold) %>%
    group_by(gene) %>%
    summarize(
      max_effect = max(abs(estimate)),
      n_sig = n()
    ) %>%
    arrange(desc(max_effect)) %>%
    head(top_genes)
  
  # Create matrix for heatmap
  selected_genes <- plot_data$gene
  
  pairwise_matrix <- pairwise_summary %>%
    filter(gene %in% selected_genes,
           comparison_type == !!comparison_type) %>%
    select(gene, contrast, estimate) %>%
    pivot_wider(names_from = contrast, values_from = estimate, values_fill = 0)
  
  # Convert to matrix
  mat <- as.matrix(pairwise_matrix[,-1])
  rownames(mat) <- pairwise_matrix$gene
  
  # Plot heatmap
  pheatmap(
    mat,
    color = colorRampPalette(c("blue", "white", "red"))(100),
    scale = "none",
    clustering_distance_rows = "euclidean",
    clustering_distance_cols = "euclidean",
    main = paste("Pairwise Comparisons:", comparison_type),
    fontsize = 8
  )
}

# ========================================
# USAGE EXAMPLES
# ========================================

# Example 1: Run with pairwise comparisons
example_pairwise_analysis <- function() {
  # Set reference levels explicitly
  reference_levels <- list(
    treatment = "Infliximab",  # Set Infliximab as reference
    time = "pre",
    healing_level = "NR"
  )
  
  # Run analysis with pairwise
  results <- run_lmm_pairwise_multiple(
    seurat_obj,
    genes = top_genes[1:100],
    config = my_config,
    reference_levels = reference_levels,
    compute_pairwise = TRUE,
    n_cores = 4
  )
  
  # Extract specific pairwise comparisons
  drug_comparisons <- results$pairwise_summary %>%
    filter(comparison_type == "drug_main_effect")
  
  # Get Adalimumab vs Vedolizumab comparison
  ada_vs_vedo <- drug_comparisons %>%
    filter(grepl("Adalimumab.*Vedolizumab", contrast))
  
  return(results)
}

# Example 2: Get adjusted expression values
example_adjustment <- function() {
  # Run LMM first
  lmm_results <- run_lmm_pairwise_multiple(
    seurat_obj,
    genes = top_genes[1:500],
    config = my_config
  )
  
  # Remove random effects (patient effects)
  seurat_adj_random <- create_adjusted_matrix(
    seurat_obj,
    lmm_results,
    config = my_config,
    adjustment_type = "random"
  )
  
  # Remove drug effects (keep timepoint and response)
  seurat_adj_drug <- create_adjusted_matrix(
    seurat_obj,
    lmm_results,
    config = my_config,
    adjustment_type = "fixed",
    remove_effects = c("treatment")  # Using actual column name
  )
  
  # Get residuals only
  seurat_residuals <- create_adjusted_matrix(
    seurat_obj,
    lmm_results,
    config = my_config,
    adjustment_type = "residual"
  )
  
  return(list(
    random_adjusted = seurat_adj_random,
    drug_adjusted = seurat_adj_drug,
    residuals = seurat_residuals
  ))
}

# Example 3: Complete workflow with all features
run_enhanced_workflow <- function(seurat_obj, config, output_dir = "./results_enhanced") {
  
  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  
  # Step 1: Quick screening
  message("Step 1: Initial screening...")
  screen_results <- quick_screen_genes(
    seurat_obj,
    config = config,
    comparison_type = "combined",
    top_n = 1000
  )
  
  # Step 2: Run LMM with pairwise
  message("Step 2: Running LMM with pairwise comparisons...")
  
  # Try different reference levels
  reference_sets <- list(
    set1 = list(drug = levels(factor(seurat_obj@meta.data[[config$drug]]))[1]),
    set2 = list(drug = levels(factor(seurat_obj@meta.data[[config$drug]]))[2])
  )
  
  all_pairwise_results <- list()
  
  for (set_name in names(reference_sets)) {
    message(sprintf("  Testing reference set: %s", set_name))
    
    results <- run_lmm_pairwise_multiple(
      seurat_obj,
      genes = screen_results$top_genes[1:200],
      config = config,
      reference_levels = reference_sets[[set_name]],
      compute_pairwise = TRUE,
      n_cores = 4
    )
    
    all_pairwise_results[[set_name]] <- results
  }
  
  # Step 3: Get adjusted expression
  message("Step 3: Computing adjusted expression values...")
  
  adjusted_data <- create_adjusted_matrix(
    seurat_obj,
    all_pairwise_results$set1,
    config = config,
    adjustment_type = "random"
  )
  
  # Step 4: Save results
  message("Step 4: Saving results...")
  
  # Save pairwise comparisons
  for (set_name in names(all_pairwise_results)) {
    write.csv(
      all_pairwise_results[[set_name]]$pairwise_summary,
      file.path(output_dir, paste0("pairwise_", set_name, ".csv")),
      row.names = FALSE
    )
  }
  
  # Save adjusted expression
  saveRDS(adjusted_data, file.path(output_dir, "adjusted_expression.rds"))
  
  # Step 5: Visualizations
  message("Step 5: Creating visualizations...")
  
  pdf(file.path(output_dir, "pairwise_heatmaps.pdf"), width = 12, height = 10)
  
  for (set_name in names(all_pairwise_results)) {
    if (!is.null(all_pairwise_results[[set_name]]$pairwise_summary)) {
      tryCatch({
        plot_pairwise_heatmap(
          all_pairwise_results[[set_name]]$pairwise_summary,
          comparison_type = "drug_main_effect",
          top_genes = 30
        )
      }, error = function(e) {
        message(sprintf("Could not create heatmap for %s: %s", set_name, e$message))
      })
    }
  }
  
  dev.off()
  
  message("Enhanced analysis complete!")
  
  return(list(
    pairwise_results = all_pairwise_results,
    adjusted_expression = adjusted_data
  ))
}

# Print summary of pairwise comparisons
print_pairwise_summary <- function(results) {
  if (!is.null(results$pairwise_summary)) {
    cat("\n=== PAIRWISE COMPARISONS SUMMARY ===\n")
    
    comparison_types <- unique(results$pairwise_summary$comparison_type)
    
    for (ct in comparison_types) {
      cat(sprintf("\n%s:\n", ct))
      
      subset_data <- results$pairwise_summary %>%
        filter(comparison_type == ct)
      
      contrasts <- unique(subset_data$contrast)
      cat(sprintf("  Number of contrasts: %d\n", length(contrasts)))
      cat("  Contrasts: ", paste(contrasts, collapse = ", "), "\n")
      
      sig_genes <- subset_data %>%
        filter(p_adj_global < 0.05) %>%
        pull(gene) %>%
        unique()
      
      cat(sprintf("  Significant genes: %d\n", length(sig_genes)))
    }
  }
}
```
# claude's refactoring
```{r}
config <- create_analysis_config(
 patient = "emrid",
 drug = "drug",
 timepoint = "treatment",
 response = "response",
 aoi="index"
)
RCA=run_complete_analysis(seurat_obj=data_seurat,
                          config=config,
                          screening_params=list(grouping_var="drug", top_n=500),
                          lmm_params=list(
                            fixed_effects=c("drug","timepoint","response"),
                            interactions=c("drug:timepoint:response")
                          ),
                          output_prefix="IBD_analysis"
)
```

## function by function
### sc
```{r}
screening_results <- screen_genes(
  seurat_obj = data_seurat,
  config = config,
  grouping_var = "timepoint",  # Compare pre vs post
  min_pct = 0.1,               # Gene expressed in ≥10% of either group
  logfc_threshold = 0.1,       # Minimum log fold-change
  top_n = 500,                 # Select top 500 genes
  test_method = "wilcox"       # Wilcoxon rank-sum test
)
```
### lmm
```{r}
lmm_full <- run_lmm_analysis(
  seurat_obj = data_seurat,
  genes = screening_results$top_genes,  # Use screened genes
  config = config,
  fixed_effects = c("drug", "timepoint", "response"),
  interactions = c("drug:timepoint:response"),  # 3-way interaction
  random_effects = "(1|patient)",  # Random intercept per patient
  reference_levels = list(
    timepoint = "pre",      # "pre" is reference (baseline)
    response = "NR",        # "NR" is reference
    drug = "Infliximab"     # "Infliximab" is reference
  ),
  n_cores = 6,     # Use 6 CPU cores
  verbose = TRUE
)

# Example 2: Simpler model - drug-by-time interaction only
lmm_simple <- run_lmm_analysis(
  seurat_obj = data_seurat,
  genes = screening_results$top_genes,
  config = config,
  fixed_effects = c("drug", "timepoint"),
  interactions = c("drug:timepoint"),
  random_effects = "(1|patient)",
  reference_levels = list(timepoint = "pre"),
  n_cores = 6,
  verbose = TRUE
)
```
### summary
```{r}
# Overall summary
cat("\nLMM Analysis Summary:\n")
cat("═══════════════════════\n")
cat(sprintf("Total genes analyzed: %d\n", lmm_full$total_count))
cat(sprintf("Converged models: %d (%.1f%%)\n",
            lmm_full$converged_count,
            100 * lmm_full$converged_count / lmm_full$total_count))
cat(sprintf("Singular fits: %d\n", lmm_full$singular_count))
cat(sprintf("Failed models: %d\n", lmm_full$failed_count))

# View all coefficients
head(lmm_full$summary, 20)

# How many significant effects per term?
lmm_full$summary %>%
  filter(significant) %>%
  count(term, sort = TRUE)

# Distribution of effect sizes
lmm_full$summary %>%
  filter(significant) %>%
  ggplot(aes(x = estimate)) +
  geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
  facet_wrap(~term, scales = "free") +
  theme_bw() +
  labs(title = "Distribution of Significant Effect Sizes")
```
# original workflow (251010)

## configs
```{r}
my_config <- create_analysis_config(patient = "emrid",drug = "drug",timepoint = "treatment",ck = "ck",response = "H3",aoi = "SegmentDisplayName")

forms=list(
  pp_simple_each=list(fixed=c("drug", "timepoint", "response"),random="(1|patient)"),
  pp_complex_each=list(fixed = c("drug", "timepoint", "response"),interactions = c("drug:timepoint", "drug:response", "response:timepoint"),random = "(1|patient)")
)

forms_str=list(
  pp_simple_all="Expression ~ ck+drug+treatment+response+(1|emrid)",
  pp_simple_each="Expression ~ drug+treatment+response+(1|emrid)",
  pp_complex_all="Expression ~ ck*drug*treatment*response+(1|emrid)",
  pp_complex_each="Expression ~ drug*treatment*response+(1|emrid)"
)




complex_formula_all=list(fixed = c("drug", "timepoint", "response"),interactions = c("drug:timepoint", "drug:response", "response:timepoint"),random = "(1|patient)")
complex_formula1 <- list(fixed = c("drug", "timepoint", "response"),interactions = c("drug:timepoint", "drug:response"),random = "(1|patient)")
complex_formula2 <- list(fixed = c("timepoint", "response"),interactions = c("timepoint:response"),random = "(1|patient)")

```
## quick screening 
```{r}
qss=list(
qs_all=quick_screen_genes(data_seurat,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
qs_ck=quick_screen_genes(data.ck,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
qs_str=quick_screen_genes(data.str,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)#,
# qs_ck_inf=quick_screen_genes(data.ck.inf,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
# qs_ck_ust=quick_screen_genes(data.ck.ust,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
# qs_ck_ved=quick_screen_genes(data.ck.ved,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
# qs_str_inf=quick_screen_genes(data.str.inf,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
# qs_str_ust=quick_screen_genes(data.str.ust,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000),
# qs_str_ved=quick_screen_genes(data.str.ved,config = my_config,comparison_type = "pre_post",use_adj = FALSE,top_n = 3000)
)
```
## lmms
### major, simple
```{r}
# usethis::edit_r_environ() #NCONNECTIONS=500 입력 -> Session 완전 종료 후 다시시작하면, 500개 연결한도 갖고 시작.
# library(future)
# # 기존의 multisession 대신 multicore를 사용하도록 설정 -> Rstudio에서는 안 된다.
# plan(multicore, workers = 32)

lmm_list=list(
  lmm_simple_all=run_lmm_multiple_genes(data_seurat, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_components = forms[[1]]),
  lmm_simple_ck=run_lmm_multiple_genes(data.ck, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_components = forms[[2]]),
  lmm_simple_str=run_lmm_multiple_genes(data.str, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_components = forms[[2]]),
  lmm_complex_all=run_lmm_multiple_genes(data_seurat, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_components = forms[[4]]),
)


lmm_list=list(
  lmm_simple_ck=run_lmm_multiple_genes(data.ck, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_str = forms_str[[2]], n_cores=8),
  lmm_simple_str=run_lmm_multiple_genes(data.str, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_str = forms_str[[2]], n_cores=8),
  lmm_complex_ck=run_lmm_multiple_genes(data.ck, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_str = forms_str[[4]], n_cores=8),
  lmm_complex_str=run_lmm_multiple_genes(data.str, genes=rownames(data_seurat@assays$RNA$counts),config=my_config,formula_str = forms_str[[4]], n_cores=8)
)
```
### sub
```{r}
lmm_all=run_lmm_multiple_genes(data_seurat,genes = qs_all$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm=run_lmm_multiple_genes(data.ck,genes = qs_ck$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm_=run_lmm_multiple_genes(data.str,genes = qs_str$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
# lmm_ust=run_lmm_multiple_genes(data.ck,genes = qs_ck$top_genes,config = my_config,formula_components = complex_formula1)%>%lrf()
lmm1=run_lmm_multiple_genes(data.ck.inf,genes = qs_ck_inf$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm2=run_lmm_multiple_genes(data.ck.ust,genes = qs_ck_ust$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm3=run_lmm_multiple_genes(data.ck.ved,genes = qs_ck_ved$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm4=run_lmm_multiple_genes(data.str.inf,genes = qs_str_inf$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm5=run_lmm_multiple_genes(data.str.ust,genes = qs_str_ust$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
lmm6=run_lmm_multiple_genes(data.str.ved,genes = qs_str_ved$top_genes,config = my_config,formula_components = complex_formula2)%>%lrf()
```
## lmm for signatures
```{r}
# INF_pos, test and patches
lmm_INF_pos=fit_lmm_single_gene(data_seurat$INF_pos, data_seurat@meta.data, config=my_config, formula_components=complex_formula_all, use_config_names=TRUE)
lmm_INF_pos=fit_lmm_single_gene(data_seurat$INF_pos, data_seurat@meta.data, config=my_config, formula_str="Expression ~ ck*drug*treatment*response+(1|emrid)")
View(lmm_INF_pos$effects)
lmm_INF_pos2=fit_lmm_single_gene(data_seurat$INF_pos, data_seurat@meta.data, config=my_config, formula_str=forms_str[[1]])

# IS score
lmm_Inf=fit_lmm_single_gene(data_seurat$InflammatoryScore, data_seurat@meta.data, config=my_config, formula_str="Expression ~ ck*drug*treatment*response+(1|emrid)")
View(lmm_Inf$effects)
lmm_Inf_ck=fit_lmm_single_gene(data.ck$InflammatoryScore, data.ck@meta.data, config=my_config, formula_str="Expression ~ ck*drug*treatment*response+(1|emrid)")
lmm_Inf_str=fit_lmm_single_gene(data.str$InflammatoryScore, data.str@meta.data, config=my_config, formula_str="Expression ~ ck*drug*treatment*response+(1|emrid)")
View(lmm_Inf_ck$effects)
View(lmm_Inf_str$effects)

# simplify (after nonsignificant)
lmm_Inf_ck_rnr=fit_lmm_single_gene(data.ck$InflammatoryScore, data.ck@meta.data, config=my_config, formula_str="Expression ~ treatment*response+(1|emrid)")
lmm_Inf_ck_drug=fit_lmm_single_gene(data.ck$InflammatoryScore, data.ck@meta.data, config=my_config, formula_str="Expression ~ drug*treatment+(1|emrid)")
lmm_Inf_str_rnr=fit_lmm_single_gene(data.str$InflammatoryScore, data.str@meta.data, config=my_config, formula_str="Expression ~ treatment*response+(1|emrid)")
lmm_Inf_str_drug=fit_lmm_single_gene(data.str$InflammatoryScore, data.str@meta.data, config=my_config, formula_str="Expression ~ drug*treatment+(1|emrid)")

View(lmm_Inf_ck_rnr$effects)
View(lmm_Inf_ck_drug$effects)
View(lmm_Inf_str_rnr$effects)
View(lmm_Inf_str_drug$effects)
```
#d 
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```
```{r}

```