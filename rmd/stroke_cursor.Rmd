---
title: "Stroke scRNA-seq Analysis - Cursor Refactored"
author: "Jaecheon Ko"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: show
    df_print: paged
    theme: cerulean
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 8,
  dpi = 300
)
```

# Project Overview

**Project:** Stroke scRNA-seq Analysis  
**Data:** Multiple GEMs (stroke1-4, GEX1-4) with SNP/HTO-based demultiplexing  
**Goal:** Comprehensive single-cell characterization of stroke pathology

**Key Steps:**
1. Data loading and QC
2. Demultiplexing (SNP + HTO)
3. Ambient RNA removal (SoupX)
4. Integration
5. Clustering and cell type annotation
6. Differential expression analysis
7. Pathway enrichment
8. Advanced analyses (Trajectory, CCI, etc.)

---

# 1. Setup

## 1.1 Load Libraries

```{r libraries}
# Core analysis
library(Seurat)
library(dplyr)
library(tidyr)
library(ggplot2)

# Quality control and preprocessing
library(scDblFinder)
library(SoupX)

# Downstream analysis
library(edgeR)
library(readxl)

# Load refactored myR package
suppressMessages({
  library(devtools)
  setwd("/data/kjc1/mylit/myR")
  load_all()  # Or library(myR) if installed
})

# Set global options
options(Seurat.object.assay.version = "v5")
set.seed(1234)
```

## 1.2 Define Paths

```{r paths}
# Project directory
project_dir <- "/data/kjc1/projects/#130.stroke"

# GEM directories (filtered matrices)
list_snp <- list(
  GEM1 = file.path(project_dir, "gems/stroke1/outs/filtered_feature_bc_matrix"),
  GEM2 = file.path(project_dir, "gems/stroke2/outs/filtered_feature_bc_matrix"),
  GEM3 = file.path(project_dir, "gems/stroke3/outs/filtered_feature_bc_matrix"),
  GEM4 = file.path(project_dir, "gems/stroke4/outs/filtered_feature_bc_matrix"),
  GEM5 = file.path(project_dir, "gems/GEX1/outs/filtered_feature_bc_matrix"),
  GEM6 = file.path(project_dir, "gems/GEX2/outs/filtered_feature_bc_matrix"),
  GEM7 = file.path(project_dir, "gems/GEX3/outs/filtered_feature_bc_matrix"),
  GEM8 = file.path(project_dir, "gems/GEX4/outs/filtered_feature_bc_matrix")
)

# Raw matrices (for SoupX)
list_snp_raw <- list(
  GEM1 = file.path(project_dir, "gems/stroke1/outs/raw_feature_bc_matrix"),
  GEM2 = file.path(project_dir, "gems/stroke2/outs/raw_feature_bc_matrix"),
  GEM3 = file.path(project_dir, "gems/stroke3/outs/raw_feature_bc_matrix"),
  GEM4 = file.path(project_dir, "gems/stroke4/outs/raw_feature_bc_matrix"),
  GEM5 = file.path(project_dir, "gems/GEX1/outs/raw_feature_bc_matrix"),
  GEM6 = file.path(project_dir, "gems/GEX2/outs/raw_feature_bc_matrix"),
  GEM7 = file.path(project_dir, "gems/GEX3/outs/raw_feature_bc_matrix"),
  GEM8 = file.path(project_dir, "gems/GEX4/outs/raw_feature_bc_matrix")
)

# Demultiplexing results
list_demux <- list(
  file.path(project_dir, "demux/xlot_1_posterior.csv"),
  file.path(project_dir, "demux/xlot_2_posterior.csv"),
  file.path(project_dir, "demux/xlot_3_posterior.csv"),
  file.path(project_dir, "demux/xlot_4_posterior.csv"),
  file.path(project_dir, "demux/xlot_5_posterior.csv"),
  file.path(project_dir, "demux/xlot_6_posterior.csv"),
  file.path(project_dir, "demux/xlot_7_posterior.csv"),
  file.path(project_dir, "demux/xlot_8_posterior.csv")
)

# Output directory
output_dir <- file.path(project_dir, "results_cursor")
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
```

---

# 2. Data Loading and Preprocessing

## 2.1 Load Raw Data

```{r load_data, eval=FALSE}
# Initialize storage
seurat_list <- list()

# Load each GEM
for (i in seq_along(list_snp)) {
  gem_name <- names(list_snp)[i]
  
  message("Loading ", gem_name, "...")
  
  # Read 10X data
  counts <- Read10X(list_snp[[i]])
  
  # Create Seurat object
  seurat_list[[gem_name]] <- CreateSeuratObject(
    counts = counts,
    project = "Stroke",
    min.cells = 3,
    min.features = 200
  )
  
  # Add GEM metadata
  seurat_list[[gem_name]]$GEM <- gem_name
  seurat_list[[gem_name]]$orig.ident <- gem_name
}

message("Loaded ", length(seurat_list), " GEMs")
```

## 2.2 Demultiplexing

### SNP-based Demultiplexing

```{r demux_snp, eval=FALSE}
# Load demux results and add to Seurat objects
for (i in seq_along(seurat_list)) {
  gem_name <- names(seurat_list)[i]
  demux_file <- list_demux[[i]]
  
  message("Adding demux info for ", gem_name, "...")
  
  # Read demux results
  demux_data <- read.csv(demux_file, row.names = 1)
  
  # Use refactored demulti_utils functions
  barcode_assignments <- get_barcode_mapping(
    as.matrix(demux_data),
    singlet_threshold = 0.5,
    doublet_threshold = 0.3,
    return_probs = TRUE
  )
  
  # Add to metadata
  rownames(barcode_assignments) <- barcode_assignments$barcode
  common_cells <- intersect(colnames(seurat_list[[i]]), rownames(barcode_assignments))
  
  seurat_list[[i]] <- AddMetaData(
    seurat_list[[i]],
    metadata = barcode_assignments[common_cells, ],
    col.name = colnames(barcode_assignments)
  )
  
  # Summarize
  summary <- summarize_demulti_results(barcode_assignments)
  message("  Singlets: ", summary$n_singlets, 
          ", Doublets: ", summary$n_doublets,
          ", Negative: ", summary$n_negative)
}
```

### Filter to Keep Only Singlets

```{r filter_singlets, eval=FALSE}
for (i in seq_along(seurat_list)) {
  gem_name <- names(seurat_list)[i]
  
  # Keep only singlets
  n_before <- ncol(seurat_list[[i]])
  seurat_list[[i]] <- subset(seurat_list[[i]], subset = type == "singlet")
  n_after <- ncol(seurat_list[[i]])
  
  message(gem_name, ": ", n_before, " -> ", n_after, " cells (", 
          round(100 * n_after / n_before, 1), "% retained)")
}
```

## 2.3 Quality Control

```{r qc, eval=FALSE}
# Calculate QC metrics
for (i in seq_along(seurat_list)) {
  gem_name <- names(seurat_list)[i]
  
  # Add mitochondrial percentage
  seurat_list[[i]][["percent.mt"]] <- PercentageFeatureSet(
    seurat_list[[i]], 
    pattern = "^MT-"
  )
  
  # Add ribosomal percentage
  seurat_list[[i]][["percent.ribo"]] <- PercentageFeatureSet(
    seurat_list[[i]], 
    pattern = "^RP[SL]"
  )
  
  # Add hemoglobin percentage
  seurat_list[[i]][["percent.hb"]] <- PercentageFeatureSet(
    seurat_list[[i]], 
    pattern = "^HB[AB]"
  )
}

# Visualize QC metrics
VlnPlot(
  merge(seurat_list[[1]], seurat_list[2:length(seurat_list)]),
  features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
  ncol = 3,
  pt.size = 0
)
```

### Apply QC Filters

```{r qc_filter, eval=FALSE}
# Define thresholds
nFeature_min <- 200
nFeature_max <- 6000
percent_mt_max <- 20

# Apply filters
for (i in seq_along(seurat_list)) {
  gem_name <- names(seurat_list)[i]
  n_before <- ncol(seurat_list[[i]])
  
  seurat_list[[i]] <- subset(
    seurat_list[[i]],
    subset = nFeature_RNA > nFeature_min & 
             nFeature_RNA < nFeature_max & 
             percent.mt < percent_mt_max
  )
  
  n_after <- ncol(seurat_list[[i]])
  message(gem_name, " QC: ", n_before, " -> ", n_after, " cells")
}
```

## 2.4 Ambient RNA Removal (SoupX)

```{r soupx, eval=FALSE}
# Apply SoupX to each GEM
for (i in seq_along(seurat_list)) {
  gem_name <- names(seurat_list)[i]
  
  message("Running SoupX for ", gem_name, "...")
  
  # Load raw counts
  tod <- Read10X(list_snp_raw[[i]])
  toc <- Read10X(list_snp[[i]])
  
  # Create SoupChannel
  sc <- SoupChannel(tod, toc)
  
  # Quick clustering for contamination estimation
  srat_temp <- CreateSeuratObject(counts = toc)
  srat_temp <- NormalizeData(srat_temp)
  srat_temp <- FindVariableFeatures(srat_temp)
  srat_temp <- ScaleData(srat_temp)
  srat_temp <- RunPCA(srat_temp, verbose = FALSE)
  srat_temp <- FindNeighbors(srat_temp, dims = 1:20, verbose = FALSE)
  srat_temp <- FindClusters(srat_temp, resolution = 0.5, verbose = FALSE)
  
  # Add cluster info to SoupChannel
  sc <- setClusters(sc, setNames(srat_temp$seurat_clusters, colnames(srat_temp)))
  
  # Estimate contamination
  sc <- autoEstCont(sc, verbose = FALSE)
  
  # Adjust counts
  adj_counts <- adjustCounts(sc)
  
  # Update Seurat object with adjusted counts
  common_genes <- intersect(rownames(seurat_list[[i]]), rownames(adj_counts))
  common_cells <- intersect(colnames(seurat_list[[i]]), colnames(adj_counts))
  
  seurat_list[[i]] <- CreateSeuratObject(
    counts = adj_counts[common_genes, common_cells],
    meta.data = seurat_list[[i]]@meta.data[common_cells, ]
  )
  
  message("  Estimated contamination: ", round(sc$fit$rho * 100, 2), "%")
}
```

---

# 3. Integration

## 3.1 Standard Workflow per Sample

```{r normalize_scale, eval=FALSE}
# Normalize and find variable features
seurat_list <- lapply(seurat_list, function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
  return(x)
})
```

## 3.2 Integration (Harmony or CCA)

### Option 1: Harmony Integration

```{r integration_harmony, eval=FALSE}
# Merge all samples
seurat_merged <- merge(
  seurat_list[[1]], 
  seurat_list[2:length(seurat_list)],
  merge.data = TRUE
)

# Standard workflow
seurat_merged <- ScaleData(seurat_merged)
seurat_merged <- RunPCA(seurat_merged, npcs = 50, verbose = FALSE)

# Harmony integration
library(harmony)
seurat_merged <- RunHarmony(
  seurat_merged, 
  group.by.vars = "GEM",
  dims.use = 1:30
)

# UMAP on harmony embeddings
seurat_merged <- RunUMAP(seurat_merged, reduction = "harmony", dims = 1:30)
seurat_merged <- FindNeighbors(seurat_merged, reduction = "harmony", dims = 1:30)
seurat_merged <- FindClusters(seurat_merged, resolution = 0.5)
```

### Option 2: CCA Integration

```{r integration_cca, eval=FALSE}
# Find integration anchors
features <- SelectIntegrationFeatures(object.list = seurat_list)
anchors <- FindIntegrationAnchors(object.list = seurat_list, anchor.features = features)

# Integrate
seurat_integrated <- IntegrateData(anchorset = anchors)

# Standard workflow on integrated assay
DefaultAssay(seurat_integrated) <- "integrated"
seurat_integrated <- ScaleData(seurat_integrated)
seurat_integrated <- RunPCA(seurat_integrated, npcs = 50, verbose = FALSE)
seurat_integrated <- RunUMAP(seurat_integrated, reduction = "pca", dims = 1:30)
seurat_integrated <- FindNeighbors(seurat_integrated, reduction = "pca", dims = 1:30)
seurat_integrated <- FindClusters(seurat_integrated, resolution = 0.5)
```

## 3.3 Visualization

```{r visualize_integrated}
# Use whichever integration method you chose
sobj <- seurat_merged  # or seurat_integrated

# UMAP plots
DimPlot(sobj, reduction = "umap", group.by = "GEM", label = FALSE) + 
  ggtitle("UMAP by GEM")

DimPlot(sobj, reduction = "umap", label = TRUE, repel = TRUE) + 
  ggtitle("UMAP by Cluster")
```

---

# 4. Cell Type Annotation

## 4.1 Find Cluster Markers

```{r find_markers}
# Find markers for all clusters
Idents(sobj) <- "seurat_clusters"
all_markers <- FindAllMarkers(
  sobj,
  only.pos = TRUE,
  min.pct = 0.25,
  logfc.threshold = 0.25
)

# Filter using refactored functions
all_markers_filtered <- all_markers %>%
  marker_trim(direction = "up", padj_threshold = 0.05) %>%
  marker_filter(remove_ribo = TRUE, remove_mito = TRUE, remove_hb = TRUE)

# Print top markers per cluster
marker_print_all(all_markers_filtered, n = 10)
```

## 4.2 Visualize Marker Genes

```{r visualize_markers}
# Known cell type markers
markers_to_plot <- list(
  T_cells = c("CD3D", "CD3E", "CD3G", "CD4", "CD8A"),
  B_cells = c("MS4A1", "CD79A", "CD79B"),
  Monocytes = c("CD14", "LYZ", "S100A8", "S100A9"),
  NK_cells = c("GNLY", "NKG7", "KLRD1"),
  DC = c("FCER1A", "CD1C", "CLEC9A"),
  Neutrophils = c("FCGR3B", "CSF3R", "CXCR2")
)

# Use refactored heatmap function (from plots.R or create new one)
DotPlot(sobj, features = unlist(markers_to_plot)) + 
  RotatedAxis() +
  ggtitle("Cell Type Markers")
```

## 4.3 Assign Cell Types

```{r assign_celltypes}
# Based on marker expression, assign cell types
cell_type_map <- c(
  "0" = "T_cells",
  "1" = "Monocytes",
  "2" = "B_cells",
  "3" = "NK_cells",
  "4" = "T_cells",
  "5" = "Monocytes",
  "6" = "DC",
  "7" = "Neutrophils"
  # ... adjust based on your data
)

sobj$cell_type <- cell_type_map[as.character(sobj$seurat_clusters)]

# Visualize
DimPlot(sobj, reduction = "umap", group.by = "cell_type", label = TRUE)
```

---

# 5. Differential Expression Analysis

## 5.1 Pseudobulk DE (Using Refactored Function)

```{r pseudobulk_de}
# Define your comparison (adjust metadata column names)
# Example: Compare condition A vs B

# Use refactored differential_expression.R
results_pseudobulk <- run_pseudobulk_deg(
  object = sobj,
  sample_col = "assignment",  # Your sample identifier
  group_col = "condition",     # Your grouping variable
  comparison = c("Stroke", "Control"),
  mode = "per_cluster",
  cluster_col = "cell_type",
  assay = "RNA",
  slot = "counts",
  min_cells = 10
)

# View results for a specific cell type
head(results_pseudobulk$T_cells)
```

## 5.2 Linear Regression (For Continuous Variables)

```{r linear_regression}
# Example: Gene expression vs age or severity score
# Using refactored linear_seurat function

results_linear <- linear_seurat(
  sobj = sobj,
  layer = "data",
  features = "all",  # or specific genes
  regressor = "age",  # Your continuous variable
  regressor.type = "continuous",
  covariates = c("sex", "batch"),  # Optional covariates
  min.cells = 10
)

# View top results
head(results_linear[order(results_linear$adj.p.value), ], 20)
```

---

# 6. Pathway Enrichment Analysis

```{r pathway_analysis}
# Use refactored pathway_enrichment.R functions

# Example: Pathway analysis on DEGs from cluster 0 (T cells)
t_cell_degs <- results_pseudobulk$T_cells

# Run comprehensive pathway analysis
pathway_results <- myGO(
  deg_results = t_cell_degs,
  run_go = TRUE,
  run_kegg = TRUE,
  run_gsea = TRUE,
  go_ont = "BP",
  gsea_category = "H",
  padj_threshold = 0.05,
  logfc_threshold = 0.5
)

# View GO results
if (!is.null(pathway_results$GO)) {
  head(pathway_results$GO_formatted, 20)
}

# View GSEA results
if (!is.null(pathway_results$GSEA)) {
  head(pathway_results$GSEA_formatted, 20)
}
```

---

# 7. Advanced Analyses

## 7.1 Trajectory Analysis (Slingshot)

```{r trajectory, eval=FALSE}
# Using refactored trajectory_inference.R

# Run Slingshot
sce <- run_slingshot_from_seurat(
  seurat_obj = sobj,
  cluster_col = "cell_type",
  reduction = "umap",
  start_cluster = "Monocytes",  # Adjust based on your data
  assay = "RNA"
)

# Analyze gene dynamics along pseudotime
genes_of_interest <- c("CCR2", "CX3CR1", "ITGAX")

dynamics_results <- process_gene_list_dynamics(
  sce = sce,
  genes = genes_of_interest,
  lineage = 1,
  plot = TRUE,
  output_dir = file.path(output_dir, "trajectory")
)
```

## 7.2 Cell-Cell Communication (NicheNet)

```{r nichenet, eval=FALSE}
# Load NicheNet networks (do this once)
# lr_network <- readRDS(url("https://zenodo.org/record/3260758/files/lr_network.rds"))
# sig_network <- readRDS(url("https://zenodo.org/record/3260758/files/signaling_network.rds"))
# gr_network <- readRDS(url("https://zenodo.org/record/3260758/files/gr_network.rds"))

# Using refactored nichenet_analysis.R
nichenet_results <- run_nichenet_analysis(
  seurat_obj = sobj,
  sender_cells = c("Monocytes", "Neutrophils"),
  receiver_cells = "T_cells",
  condition_oi = "Stroke",
  condition_ref = "Control",
  condition_col = "condition",
  lr_network = lr_network,
  sig_network = sig_network,
  gr_network = gr_network,
  top_n_ligands = 20,
  plot_circos = FALSE
)

# View top ligands
head(nichenet_results$ligand_activities, 10)
```

## 7.3 Gene Signature Discovery

```{r signature_discovery}
# Using your new find_gene_signature function!

# Find genes that distinguish Stroke vs Control
signature_results <- find_gene_signature(
  data = sobj,
  target_var = "condition",
  target_group = c("Stroke", "Control"),
  method = "lasso",  # or tree_based, limma, nmf, etc.
  n_features = 50,
  preprocess = TRUE
)

# View results
print(signature_results)

# Apply signature to new data
# scores <- score_signature(new_data, signature_results)
```

---

# 8. Visualization and Reporting

## 8.1 Composition Analysis

```{r composition}
# Using refactored composition_plots.R

# Proportional stacked bar
cmb(
  sobj,
  cluster_col = "cell_type",
  sample_col = "assignment",
  title = "Cell Type Composition by Sample"
)

# Absolute counts
acmb(
  sobj,
  cluster_col = "cell_type",
  sample_col = "assignment",
  title = "Cell Type Counts by Sample"
)
```

## 8.2 Generate Summary Plots

```{r summary_plots}
# Create output directory for figures
fig_dir <- file.path(output_dir, "figures")
dir.create(fig_dir, showWarnings = FALSE)

# Save key plots
ggsave(
  filename = file.path(fig_dir, "umap_celltypes.pdf"),
  plot = DimPlot(sobj, group.by = "cell_type", label = TRUE),
  width = 10, height = 8
)
```

---

# 9. Save Results

```{r save_results}
# Save processed Seurat object
saveRDS(sobj, file = file.path(output_dir, "stroke_seurat_processed.rds"))

# Save DE results
saveRDS(results_pseudobulk, file = file.path(output_dir, "pseudobulk_de_results.rds"))

# Save pathway results
saveRDS(pathway_results, file = file.path(output_dir, "pathway_results.rds"))

# Export key results to Excel
library(openxlsx)
wb <- createWorkbook()

# Add sheets for each result
for (celltype in names(results_pseudobulk)) {
  addWorksheet(wb, sheetName = celltype)
  writeData(wb, sheet = celltype, x = results_pseudobulk[[celltype]])
}

saveWorkbook(wb, file = file.path(output_dir, "DE_results.xlsx"), overwrite = TRUE)
```

---

# Session Info

```{r session_info}
sessionInfo()
```

---

# Notes and Next Steps

**Key Findings:**
- [ ] Document key findings here
- [ ] Cell type proportions
- [ ] Major DEGs
- [ ] Pathway enrichments

**Next Steps:**
- [ ] Validate key findings
- [ ] Additional subcluster analysis
- [ ] Functional validation experiments
- [ ] Integration with other datasets

**References:**
- Add relevant references here

