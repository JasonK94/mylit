# 프로젝트 전용 컨텍스트

## 주요 목표
단일세포 RNA-seq 및 GeoMx 공간 전사체 분석을 위한 재사용 가능한 R 툴킷(`myR`)을 구축합니다.  
의사벌크 DEG, 경로 풍부도, 의사시간, 세포 간 상호작용, GeoMx 전처리 등 검증된 모듈을 문서화된 재현 가능한 워크플로로 제공하는 것이 목표입니다.

## 사용 예정 AI 모델
제한 없음(코드 리팩터링, 문서 작성, 데이터 처리 지원에 중점).

---

# AI 어시스턴트를 위한 일반 컨텍스트

## 프로젝트 초기화 워크플로

이 프로젝트는 목표, 범위, 구현 전략을 정의하는 구조화된 대화로 시작합니다. 아래 단계를 따르세요.

1. **사용자 목표 진술**: 어떤 모듈/문서를 다룰지 요구사항을 수집합니다.
2. **AI 주도 범위·전략 논의**  
    - 대상 기능(예: 의사벌크, Milo, README 보완)을 명확히 합니다.  
    - 관련 커밋·스크립트·문서를 식별합니다(`docs/functions/function_analysis.md`, `R/*.R` 등).  
    - 산출물(코드, 문서, 테스트)을 합의합니다.
3. **세부 계획 수립**: 편집 전 TODO 목록을 작성하고 대상 파일을 명시합니다.
4. **구현 시작**: 계획을 단계적으로 실행하며 각 단계마다 검증합니다.

## 문서 갱신 규칙

이 문서는 정적이지 않습니다. 협업 방식이 발전함에 따라 지속적으로 업데이트해야 합니다.

1. **변경 제안**: 사용자 또는 AI가 개선 아이디어를 제안합니다.
2. **실패 기록**: 치명적인 실수가 발생하면 “프로젝트별 주의사항” 섹션에 규칙을 추가합니다.
3. **논의 및 합의**: 변경이 유효한지 짧게 검토하고 합의합니다.
4. **적용**: 합의된 내용을 문서에 반영합니다. 풀 리퀘스트 리뷰와 동일한 절차라고 생각하면 됩니다.

이 문서는 코딩 프로젝트에서 AI 어시스턴트가 따를 일반 지침을 제공합니다.

## 핵심 원칙
1. **목표 이해**: 모든 변경을 패키지 로드맵(예: Milo 개선, 문서 동기화)과 연결합니다.
2. **계획 수립**: TODO 목록을 유지하고, 관련 문서·코드 변경을 묶어서 진행합니다.
3. **체계적 작업**: 모듈·문서를 하나씩 업데이트하며 커밋을 작게 유지합니다.
4. **행동 설명**: 명령·편집이 필요한 이유를 명시합니다(예: "`b260bb1` 커밋에서 Milo 맥락 확인").
5. **자가 교정**: 실패나 불일치가 발생하면 문제를 요약하고 대안을 제시합니다.

## 🪲 프로젝트별 주의사항 (교훈)

*이 섹션은 과거 실수에서 배운 교훈을 기록하는 살아있는 문서입니다. 사용자와 AI 모두 반복 실수를 막기 위해 책임지고 업데이트해야 합니다.*

---
*(발견 즉시 규칙을 추가하세요.)*
- Milo 분석 시 `milo@Nhoods`를 찾아야 하는데, `milo@nhoods` 슬롯이 존재하지 않는다고 오판해 디버깅을 반복한 사례가 있다. 항상 `nhoods(milo)` 등 공개 accessor를 사용하고, 객체 구조를 함수로 확인한다.
- `plotNhoodGraphDA()`를 실행하기 전에 `buildNhoodGraph(milo)`가 완료되어 있어야 한다. 그래프가 준비되지 않은 상태에서 플롯을 호출하면 시각화 단계 전체가 실패한다.
- `plotDAbeeswarm()`의 `alpha` 임계값과 색상 스케일은 SpatialFDR 분포를 전제로 한다. 기준보다 작은 값이 없을 경우 오류가 발생하므로, 메트릭을 `PValue`·`logFC` 백분위 등으로 교체하거나 `alpha`를 조정한다.
- Milo 워크플로 각 단계는 계산 비용이 크므로, 중간 산출물을 저장하고 `force_run` 플래그로 재실행 여부를 제어하는 패턴을 유지한다.
- Milo 스크립트는 `st/` 디렉터리에서 `start.R`을 통해 초기화된 `renv` 환경에서만 실행한다. 루트에서 바로 R 세션을 열면 `Seurat`, `miloR`, `cli` 등 필수 패키지가 누락되어 파이프라인이 실패한다.
- 핵심 함수(`run_milo_pipeline()` 등)는 반드시 `myR/R/` 최상위에 둔다. 하위 폴더에 두면 namespace에 export되지 않아 `myR::run_milo_pipeline`을 찾을 수 없다.
- `SingleCellExperiment::colData<-` 같은 네임스페이스 지정 setter는 사용하지 않는다. 특정 버전에서 export되지 않아 `'not an exported object'` 오류가 발생한다.
- GEM barcode suffix(`-1`, `-2`)를 임의로 제거하거나 샘플 ID를 손대지 않는다. 과거 LLM이 suffix를 없앴다가 sample ID 중복으로 DA 단계 전체가 실패했다.
- 자동화 스크립트에서 `git switch`를 사용하지 않는다. 잘못된 worktree를 checkout해 작업물이 소실될 뻔한 문제가 있었다.
- 캐시 `.qs`를 재사용할 때는 동일 데이터인지 확인한다. 필요하면 `cache_files` 인자로 경로를 명시하고 실행 후 `milo$commands` 로그를 검토한다.

## 코드 품질 & 스타일
1. **가독성**: 기존 스타일을 따르며 읽기 쉬운 구조와 주석을 유지합니다.
2. **모듈화**: 목적이 명확한 작은 함수/모듈로 나눕니다. 거대한 스크립트를 피하세요.
3. **설정 분리**: 자주 바뀔 수 있는 값(API 키, 모델명, 경로 등)은 설정 파일에 둡니다.
4. **에러 처리**: 실패를 우아하게 처리하고 명확한 오류 메시지를 제공합니다.

## 프로젝트 관리
1. **버전 관리**: 관련 커밋과 함께 DEVLOG/CHANGELOG를 업데이트합니다.
2. **문서화**: `README.md`, `README_Korean.md`에 기능을 설명하며 모듈 변경 시 갱신합니다.
3. **의존성 관리**: `DESCRIPTION` 수정 시 CHANGELOG에 이유를 기록합니다.

## 커뮤니케이션
1. **명확·간결**: 불필요한 전문용어를 피하고 핵심만 전달합니다.
2. **피드백 반영**: 사용자의 요청과 피드백을 명시적으로 확인합니다.
3. **능동적 공유**: 긴 작업에는 중간 진척 상황을 공유합니다.

## 개발 히스토리 & 푸시 정책

- 루트에서 두 가지 문서를 유지합니다.
  - `DEVLOG.md`: 세션별 내러티브 기록
  - `CHANGELOG.md`: 의미 있는 변경 사항을 시맨틱 버전 기준으로 요약
- 워크플로:
  1. 중요한 작업 전 `DEVLOG.md`에 의도를 기록
  2. 자주 커밋하되, 안정화되거나 협업이 필요할 때만 푸시
  3. 주요 변경 사항은 Keep a Changelog 형식으로 `CHANGELOG.md`에 정리
  4. 필요하면 관련 DEVLOG 항목을 커밋 메시지에 언급

## 프로젝트 산출물

`cinit`으로 초기화하면 다음 파일이 생성됩니다.

1. **`context.md`**: AI를 위한 단일 진실 소스. 목표·범위·제약 사항을 담고 지속적으로 업데이트합니다.
2. **`NEXT_STEPS.md`**: 최초 Cursor 세션에서 사용할 가이드 프롬프트.
3. **`DEVLOG.md`**: 세션별 결정과 다음 단계를 기록하는 내러티브 로그.
4. **`CHANGELOG.md`**: 사용자 영향이 있는 변경 사항을 버전별로 기록하는 문서.
