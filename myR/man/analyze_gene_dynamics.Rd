% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pseudotime.R
\name{analyze_gene_dynamics}
\alias{analyze_gene_dynamics}
\title{Analyze gene expression dynamics along pseudotime using GAM}
\usage{
analyze_gene_dynamics(
  gene_id,
  cds_obj,
  condition_col_name,
  pseudotime_method = monocle3::pseudotime,
  sample_col_name = NULL,
  output_dir = "gam_analysis_plots",
  k_val = 6,
  min_cells_for_fit = 30,
  plot_split = FALSE,
  plot_width = 7,
  plot_height = 5,
  plot_dpi = 300,
  scale_DR = TRUE
)
}
\arguments{
\item{gene_id}{A character string specifying the gene ID (e.g., gene symbol).}

\item{cds_obj}{A cell_data_set object from Monocle3.}

\item{condition_col_name}{A character string naming the column in \code{colData(cds_obj)}
that contains the condition information (e.g., treatment group, patient prognosis).
This column should ideally be a factor.}

\item{pseudotime_method}{A function or character string to specify how pseudotime is
extracted. Defaults to \code{monocle3::pseudotime}. If your CDS object might have
multiple disconnected trajectories or specific roots, you might need a custom
function or ensure \code{order_cells} was run appropriately.}

\item{sample_col_name}{Optional. A character string naming the column in \code{colData(cds_obj)}
that contains sample/patient IDs. If provided, metrics can be potentially
summarized or checked at this level in future extensions, or used for pseudo-bulk aggregation.
Currently, this argument is noted for future patient-level aggregation development.}

\item{output_dir}{A character string specifying the directory to save plots.
If it doesn't exist, it will be created recursively.}

\item{k_val}{An integer, the number of basis functions for GAM splines (mgcv's k).}

\item{min_cells_for_fit}{An integer, the minimum number of cells with finite
expression and pseudotime values required to fit the GAM.}

\item{plot_split}{Logical, if TRUE, plots for different conditions will be faceted.
If FALSE (default), conditions will be overlaid on the same plot distinguished by color.}

\item{plot_width}{Width of the saved plot in inches.}

\item{plot_height}{Height of the saved plot in inches.}

\item{plot_dpi}{DPI of the saved plot.}

\item{scale_DR}{Logical, if TRUE, Dynamic Range (DR) will be scaled by the mean
expression of the gene in the cells used for fitting.}
}
\value{
A list containing:
\itemize{
\item \code{gene}: The input gene ID.
\item \code{status}: Character string, "success", "skipped_insufficient_data", etc.
\item \code{metrics}: A list or tibble of calculated metrics (e.g., deviance explained,
interaction p-value, TV, DR per condition).
\item \code{plot_path}: Path to the saved plot file, if successful.
\item \code{plot_object}: The ggplot object itself.
}
Returns \code{NULL} if the gene is not found or critical errors occur early.
}
\description{
This function fits a Generalized Additive Model (GAM) to model gene expression
changes along pseudotime, potentially accounting for different conditions.
It calculates various metrics and generates plots.
}
\examples{
\dontrun{
# Assuming 'cds' is a valid Monocle3 object with pseudotime calculated
# and 'colData(cds)$condition' exists.
# gene_list <- c("geneA", "geneB")
# results <- lapply(gene_list, function(g) {
#   analyze_gene_dynamics(
#     gene_id = g,
#     cds_obj = cds,
#     condition_col_name = "condition",
#     output_dir = "my_gam_plots"
#   )
# })
# metrics_df <- dplyr::bind_rows(lapply(results, function(r) {
#   if(r$status == "success") {
#     # Further processing of r$metrics might be needed to flatten it
#     # This is a simplified example
#     df <- as.data.frame(r$metrics[!sapply(r$metrics, is.data.frame)])
#     if(!is.null(r$metrics$TV_per_condition)) {
#        tv_wide <- tidyr::pivot_wider(r$metrics$TV_per_condition,
#                                      names_from = cond, values_from = TV, names_prefix = "TV_")
#        df <- cbind(df, tv_wide)
#     }
#     if(!is.null(r$metrics$DR_per_condition)) {
#        dr_wide <- tidyr::pivot_wider(r$metrics$DR_per_condition,
#                                      names_from = cond, values_from = DR, names_prefix = "DR_")
#        df <- cbind(df, dr_wide)
#     }
#     return(df)
#   }
#   return(data.frame(gene = r$gene, status = r$status))
# }))
}
}
