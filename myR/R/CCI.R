
#' @export
ligand_to_target=function(ligand,target,NN_data=NicheNetData,ligand_tf_matrix=NULL,weighted_networks=NULL){
  if(is.null(ligand_tf_matrix)){
    ligand_tf_matrix=NicheNetData$ligand_tf_matrix
  }
  if(is.null(weighted_networks)){
    weighted_networks=NicheNetData$weighted_networks
  }
  
  
  active_signaling_network = get_ligand_signaling_path (
    ligand_tf_matrix = ligand_tf_matrix, ligands_all = ligand, 
    targets_all = target, weighted_networks = weighted_networks)
  
  # For better visualization of edge weigths: normalize edge weights to 
  # make them comparable between signaling and gene regulatory interactions
  active_signaling_network_min_max = active_signaling_network
  
  active_signaling_network_min_max$sig = active_signaling_network_min_max$sig %>% 
    mutate(weight = ((weight-min(weight))/(max(weight)-min(weight))) + 0.75)
  
  active_signaling_network_min_max$gr = active_signaling_network_min_max$gr %>% 
    mutate(weight = ((weight-min(weight))/(max(weight)-min(weight))) + 0.75)
  
  graph_min_max = diagrammer_format_signaling_graph (
    signaling_graph_list = active_signaling_network_min_max, 
    ligands_all = ligand, targets_all = target, 
    sig_color = "indianred", gr_color = "steelblue")
  
  # To render the graph: uncomment following line of code
  plot=DiagrammeR::render_graph(graph_min_max, layout = "tree")
  
  return(plot)
}


#' Perform NicheNet Cell-Cell Communication Analysis
#'
#' @description
#' This function wraps the NicheNet analysis pipeline to identify key ligands,
#' their target genes, and receptors involved in cell-cell communication between
#' defined sender and receiver cell populations. It handles loading of NicheNet's
#' prior interaction data, with options for local caching, global environment storage,
#' and downloading from Zenodo if necessary.
#'
#' @param seurat_obj A Seurat object containing the single-cell expression data.
#' @param species Character string, either "human" or "mouse", to load the appropriate NicheNet databases.
#' @param sender_celltypes Character vector of cell types acting as senders.
#' @param receiver_celltype Character string of the cell type acting as the receiver.
#' @param assay_name Character string, the name of the assay in the Seurat object to use (e.g., "SCT", "RNA"). Default: "SCT".
#' @param cluster_col Character string, the name of the metadata column in `seurat_obj` that contains cell type or cluster annotations.
#'        This will be used to set `Idents(seurat_obj)`.
#' @param receiver_DE_ident1 Character string, the identity for `ident.1` in `FindMarkers` for DE analysis within the `receiver_celltype`.
#' @param receiver_DE_ident2 Character string, the identity for `ident.2` in `FindMarkers` (e.g., control group). Can be NULL if comparing against all other cells in `receiver_DE_group_by`.
#' @param receiver_DE_group_by Character string, the metadata column used for `group.by` in `FindMarkers` for DE analysis within the `receiver_celltype`.
#' @param min_pct_expressed Numeric, minimum fraction of cells in which a gene must be expressed in sender/receiver groups for initial filtering. Default: 0.10.
#' @param p_val_adj_cutoff Numeric, adjusted p-value cutoff for DEGs. Default: 0.05.
#' @param logfc_cutoff Numeric, log fold-change cutoff for DEGs (positive values for upregulation in ident1). Default: 0.25.
#' @param top_n_ligands Integer, number of top ligands to consider for detailed analysis and visualization. Default: 20.
#' @param top_n_targets_per_ligand Integer, number of top target genes to show per ligand in visualizations. Default: 200.
#' @param ligand_target_cutoff Numeric, cutoff for visualizing ligand-target links (e.g., based on regulatory potential). Default: 0.33.
#' @param nichenet_data_dir Character string, path to the directory for local caching of NicheNet's RDS data files.
#'        Used if data is not found in the global environment object specified by `nichenet_data_name`.
#'        If NULL, a species-specific default path within the working directory will be used (e.g., "./nichenet_data_human/").
#' @param nichenet_data_name Character string or NULL. The name of the R object in the Global Environment
#'        where NicheNet datasets are stored or will be stored. If NULL, data is not stored/retrieved globally by this function.
#'        Default: "NicheNetData".
#' @param output_dir Character string, path to a main directory where run-specific subfolders for outputs will be created. If NULL, plots are returned but not saved to files. Default: NULL.
#' @param run_circos Logical, whether to attempt to generate and return a circos plot of ligand-receptor interactions. Requires `circlize`, `RColorBrewer`, and `evaluate` packages. Default: TRUE.
#' @param run_signaling_path_inference Logical, whether to infer and visualize ligand-to-target signaling paths for the top 1 ligand. Requires `DiagrammeR`, `DiagrammeRsvg`, `rsvg`. Default: FALSE.
#' @param verbose Logical, whether to print progress messages and summary of warnings. Default: TRUE.
#'
#' @return A list containing:
#'  \itemize{
#'    \item `ligand_activities`: DataFrame of ligand activities.
#'    \item `best_upstream_ligands`: Character vector of top N ligands.
#'    \item `active_ligand_target_links_df`: DataFrame of active ligand-target links.
#'    \item `plot_ligand_target_network`: ggplot object of the ligand-target heatmap.
#'    \item `ligand_receptor_network_df`: DataFrame of prioritized ligand-receptor interactions.
#'    \item `plot_ligand_receptor_network`: ggplot object of the ligand-receptor heatmap.
#'    \item `plot_ligand_activity_hist`: ggplot object of ligand activity histogram.
#'    \item `plot_ligand_aupr_heatmap`: ggplot object of top ligand AUPR heatmap.
#'    \item `DE_table_receiver`: DataFrame of differentially expressed genes in the receiver.
#'    \item `plot_circos`: A recorded circos plot object (replay with `plot()`) or a status message.
#'    \item `circos_notes`: Character vector of "Note:" messages captured during circos plot generation.
#'    \item `signaling_path_graph`: A DiagrammeR graph object or NULL.
#'    \item `nichenet_data_loaded_info`: List describing how NicheNet data was loaded.
#'    \item `output_path_run`: Path to the run-specific output directory if `output_dir` was provided.
#'    \item `warnings_occurred`: A character vector of warning messages collected during execution, if any.
#'  }
#' @details
#' To visualize ligand expression (e.g., as a DotPlot or Heatmap), you can use the returned
#' `best_upstream_ligands` and your original `seurat_obj`. For example:
#' `Seurat::DotPlot(seurat_obj, features = results$best_upstream_ligands, group.by = "your_celltype_column")`
#' For a more integrated graphical legend with the Circos plot, consider using the `ComplexHeatmap` package's `Legend` function externally.
#'
#' @importFrom Seurat DefaultAssay Idents FindMarkers GetAssayData Cells
#' @importFrom dplyr %>% filter select distinct arrange desc top_n pull inner_join mutate group_by summarise across ends_with bind_rows rename
#' @importFrom tidyr spread drop_na
#' @importFrom tibble column_to_rownames rownames_to_column as_tibble tibble
#' @importFrom magrittr set_rownames
#' @importFrom nichenetr get_expressed_genes predict_ligand_activities get_weighted_ligand_target_links prepare_ligand_target_visualization make_heatmap_ggplot get_ligand_signaling_path diagrammer_format_signaling_graph
#' @importFrom ggplot2 ggplot aes geom_histogram geom_vline labs theme_classic theme element_text scale_fill_gradient2 ggsave
#' @importFrom utils download.file capture.output
#' @importFrom stats dist hclust
#' @importFrom grDevices recordPlot dev.off pdf png
#' @importFrom DiagrammeRsvg export_svg
#' @importFrom rsvg rsvg_png
#' @importFrom RColorBrewer brewer.pal
#' @importFrom circlize circos.clear chordDiagram circos.track circos.text uy mm_h CELL_META
#' @importFrom evaluate evaluate
#' @export
run_nichenet_analysis <- function(seurat_obj,
                                  species = c("human", "mouse"),
                                  sender_celltypes,
                                  receiver_celltype,
                                  assay_name = "SCT",
                                  cluster_col,
                                  receiver_DE_ident1,
                                  receiver_DE_ident2 = NULL,
                                  receiver_DE_group_by,
                                  min_pct_expressed = 0.10,
                                  p_val_adj_cutoff = 0.05,
                                  logfc_cutoff = 0.25,
                                  top_n_ligands = 20,
                                  top_n_targets_per_ligand = 200,
                                  ligand_target_cutoff = 0.33,
                                  nichenet_data_dir = NULL,
                                  nichenet_data_name = "NicheNetData",
                                  output_dir = NULL,
                                  run_circos = TRUE,
                                  ...,
                                  verbose = TRUE) {
  args_option=list(...)
  # --- 0. Initialize Warning Collection & Argument Setup ---
  warnings_collected <- character(0)
  circos_notes_collected <- character(0) # For circos specific notes
  
  analysis_results <- withCallingHandlers({
    call_obj <- match.call()
    species <- match.arg(species)
    
    required_pkgs <- c("nichenetr", "Seurat", "dplyr", "tidyr", "tibble", "ggplot2")
    missing_pkgs <- required_pkgs[!sapply(required_pkgs, requireNamespace, quietly = TRUE)]
    if (length(missing_pkgs) > 0) {
      stop("Required package(s) not found: ", paste(missing_pkgs, collapse=", "), ". Please install them.", call. = FALSE)
    }
    
    current_run_output_dir <- NULL
    if (!is.null(output_dir)) {
      if (!dir.exists(output_dir)) {
        if (verbose) message("Main output directory '", output_dir, "' does not exist. Creating it.")
        tryCatch(dir.create(output_dir, recursive = TRUE, showWarnings = FALSE),
                 error = function(e) stop("Failed to create main output directory: ", output_dir, ". Error: ", e$message))
      }
      existing_runs <- list.dirs(output_dir, full.names = FALSE, recursive = FALSE)
      run_numbers <- grep("^run[0-9]+$", existing_runs, value = TRUE) %>%
        sub("run", "", .) %>%
        as.numeric()
      next_run_number <- if (length(run_numbers) == 0 || all(is.na(run_numbers))) 1 else max(run_numbers, na.rm = TRUE) + 1
      run_folder_name <- paste0("run", next_run_number)
      current_run_output_dir <- file.path(output_dir, run_folder_name)
      if (!dir.exists(current_run_output_dir)) {
        if (verbose) message("Creating run-specific output directory: ", current_run_output_dir)
        tryCatch(dir.create(current_run_output_dir, recursive = TRUE, showWarnings = FALSE),
                 error = function(e) stop("Failed to create run-specific output directory: ", current_run_output_dir, ". Error: ", e$message))
      }
      args_file_path <- file.path(current_run_output_dir, paste0(run_folder_name, "_args.txt"))
      tryCatch({
        con_args <- file(args_file_path, "w")
        cat(paste(utils::capture.output(print(call_obj)), collapse = "\n"), file = con_args)
        close(con_args)
      }, error = function(e) warning("NN_Warning: Failed to save arguments to file: ", args_file_path, ". Error: ", e$message))
      if (verbose && file.exists(args_file_path)) message("Arguments saved to: ", args_file_path)
    } else {
      if (verbose) message("`output_dir` is NULL. Plots will be returned as objects but not saved to files.")
    }
    
    # --- I. NicheNet Data Loading ---
    if (verbose) message("Attempting to load NicheNet prior model data for ", species, "...")
    base_url <- "https://zenodo.org/records/7074291/files/"
    files_to_load_spec <- list(
      human = list(lr_network = "lr_network_human_21122021.rds", sig_network = "signaling_network_human_21122021.rds", gr_network = "gr_network_human_21122021.rds", weighted_networks = "weighted_networks_nsga2r_final.rds", ligand_target_matrix = "ligand_target_matrix_nsga2r_final.rds", ligand_tf_matrix = "ligand_tf_matrix_nsga2r_final.rds"),
      mouse = list(lr_network = "lr_network_mouse_21122021.rds", sig_network = "signaling_network_mouse_21122021.rds", gr_network = "gr_network_mouse_21122021.rds", weighted_networks = "weighted_networks_nsga2r_final_mouse.rds", ligand_target_matrix = "ligand_target_matrix_nsga2r_final_mouse.rds", ligand_tf_matrix = "ligand_tf_matrix_nsga2r_final_mouse.rds")
    )
    required_files_map <- files_to_load_spec[[species]]
    nichenet_data_loaded_from_global <- FALSE
    temp_data_env <- new.env()
    
    if (!is.null(nichenet_data_name) && nzchar(nichenet_data_name)) {
      if (exists(nichenet_data_name, envir = .GlobalEnv)) {
        if (verbose) message("Found '", nichenet_data_name, "' in global environment. Validating...")
        global_data_env <- get(nichenet_data_name, envir = .GlobalEnv)
        if (is.list(global_data_env) && all(names(required_files_map) %in% names(global_data_env))) {
          are_all_components_valid <- all(sapply(names(required_files_map), function(comp_name) !is.null(global_data_env[[comp_name]])))
          has_wn_lr <- ("weighted_networks_lr" %in% names(global_data_env) && !is.null(global_data_env[["weighted_networks_lr"]])) ||
            (!is.null(global_data_env[["weighted_networks"]]) && !is.null(global_data_env[["lr_network"]]))
          if (are_all_components_valid && has_wn_lr) {
            if (verbose) message("Global data '", nichenet_data_name, "' is valid and complete. Using it.")
            for (comp_name in names(required_files_map)) {
              assign(comp_name, global_data_env[[comp_name]], envir = temp_data_env)
            }
            if ("weighted_networks_lr" %in% names(global_data_env) && !is.null(global_data_env[["weighted_networks_lr"]])) {
              assign("weighted_networks_lr", global_data_env[["weighted_networks_lr"]], envir = temp_data_env)
            } else {
              temp_lr_network_global <- global_data_env[["lr_network"]] %>% dplyr::distinct(from, to)
              assign("weighted_networks_lr", global_data_env[["weighted_networks"]]$lr_sig %>%
                       dplyr::inner_join(temp_lr_network_global, by = c("from", "to")), envir = temp_data_env)
            }
            nichenet_data_loaded_from_global <- TRUE
          } else {
            if (verbose) message("Global data '", nichenet_data_name, "' is incomplete. Will load from files/download.")
          }
        } else {
          if (verbose) message("Global data '", nichenet_data_name, "' is not a valid list or missing key components. Will load from files/download.")
        }
      } else {
        if (verbose) message("'", nichenet_data_name, "' not found in global environment. Will load from files/download.")
      }
    } else {
      if (verbose) message("`nichenet_data_name` not provided or empty. Data will not be managed via global environment for loading.")
    }
    
    if (!nichenet_data_loaded_from_global) {
      data_dir_to_use <- nichenet_data_dir
      if (is.null(data_dir_to_use)) {
        data_dir_to_use <- file.path(getwd(), paste0("nichenet_data_", species))
        if (verbose) message("`nichenet_data_dir` is NULL, using default local cache: ", data_dir_to_use)
      }
      if (!dir.exists(data_dir_to_use)) {
        if (verbose) message("Creating NicheNet data directory: ", data_dir_to_use)
        tryCatch(dir.create(data_dir_to_use, recursive = TRUE, showWarnings = FALSE),
                 error = function(e) stop("Failed to create NicheNet data directory: ", data_dir_to_use, ". Error: ", e$message))
      }
      loaded_data_for_global_assignment <- list()
      for (simple_name in names(required_files_map)) {
        rds_filename <- required_files_map[[simple_name]]
        file_path <- file.path(data_dir_to_use, rds_filename)
        if (!file.exists(file_path)) {
          if (verbose) message("File ", rds_filename, " not found in '", data_dir_to_use, "'. Downloading from Zenodo...")
          download_url <- paste0(base_url, rds_filename, "?download=1")
          tryCatch({
            utils::download.file(url = download_url, destfile = file_path, mode = "wb", quiet = !verbose)
            if (verbose) message("Downloaded ", rds_filename, " successfully to ", data_dir_to_use)
          }, error = function(e) {
            stop("Failed to download ", rds_filename, ". Error: ", e$message, call. = FALSE)
          })
        }
        assign(simple_name, readRDS(file_path), envir = temp_data_env)
        loaded_data_for_global_assignment[[simple_name]] <- get(simple_name, envir = temp_data_env)
      }
      temp_data_env$lr_network <- temp_data_env$lr_network %>% dplyr::distinct(from, to)
      loaded_data_for_global_assignment[["lr_network"]] <- temp_data_env$lr_network
      temp_data_env$weighted_networks_lr <- temp_data_env$weighted_networks$lr_sig %>%
        dplyr::inner_join(temp_data_env$lr_network, by = c("from", "to"))
      loaded_data_for_global_assignment[["weighted_networks_lr"]] <- temp_data_env$weighted_networks_lr
      if (!is.null(nichenet_data_name) && nzchar(nichenet_data_name)) {
        assign(nichenet_data_name, loaded_data_for_global_assignment, envir = .GlobalEnv)
        if (verbose) message("NicheNet data loaded from files/download and assigned to '", nichenet_data_name, "' in global environment.")
      } else {
        if (verbose) message("NicheNet data loaded from files/download. Not assigned to global environment.")
      }
    }
    
    lr_network             <- get("lr_network", envir = temp_data_env)
    sig_network            <- get("sig_network", envir = temp_data_env)
    gr_network             <- get("gr_network", envir = temp_data_env)
    weighted_networks      <- get("weighted_networks", envir = temp_data_env)
    ligand_target_matrix   <- get("ligand_target_matrix", envir = temp_data_env)
    ligand_tf_matrix       <- get("ligand_tf_matrix", envir = temp_data_env)
    weighted_networks_lr   <- get("weighted_networks_lr", envir = temp_data_env)
    rm(temp_data_env)
    
    nichenet_data_loaded_info <- list(
      source = if(nichenet_data_loaded_from_global) paste("Global Env:", nichenet_data_name) else paste("Files/Download from:", data_dir_to_use %||% file.path(getwd(), paste0("nichenet_data_", species))), # ensure data_dir_to_use is defined
      species = species, files = names(required_files_map)
    )
    if (verbose) message("NicheNet data successfully prepared for analysis.")
    
    # --- II. Seurat Object Setup & Expressed Genes ---
    if (verbose) message("Setting up Seurat object and identifying expressed genes...")
    Seurat::DefaultAssay(seurat_obj) <- assay_name
    Seurat::Idents(seurat_obj) <- cluster_col
    if(!all(sender_celltypes %in% levels(Seurat::Idents(seurat_obj)))) stop("One or more sender_celltypes not found in Seurat Idents (column '", cluster_col, "').", call. = FALSE)
    if(!receiver_celltype %in% levels(Seurat::Idents(seurat_obj))) stop("Receiver_celltype '", receiver_celltype, "' not found in Seurat Idents (column '", cluster_col, "').", call. = FALSE)
    
    list_expressed_genes_sender <- lapply(sender_celltypes, nichenetr::get_expressed_genes, seurat_obj, min_pct_expressed)
    expressed_genes_sender <- unique(unlist(list_expressed_genes_sender))
    expressed_genes_receiver <- nichenetr::get_expressed_genes(receiver_celltype, seurat_obj, min_pct_expressed)
    background_expressed_genes <- expressed_genes_receiver[expressed_genes_receiver %in% rownames(ligand_target_matrix)]
    if(length(background_expressed_genes) < 20) warning("NN_Warning: Very few (<20) background expressed genes found in receiver (", length(background_expressed_genes), "). NicheNet might not perform well.")
    
    # --- III. Define Gene Set of Interest (DEGs in receiver) ---
    if (verbose) message("Performing DE analysis for receiver: ", receiver_celltype, " (", receiver_DE_ident1, " vs ", if(!is.null(receiver_DE_ident2)) receiver_DE_ident2 else "all others", " in group ", receiver_DE_group_by,")")
    if (!receiver_DE_group_by %in% colnames(seurat_obj@meta.data)) stop("`receiver_DE_group_by` column '", receiver_DE_group_by, "' not found in Seurat object metadata.", call. = FALSE)
    DE_table_receiver <- Seurat::FindMarkers(seurat_obj, ident.1 = receiver_DE_ident1, ident.2 = receiver_DE_ident2, group.by = receiver_DE_group_by, subset.ident = receiver_celltype, assay = assay_name, min.pct = min_pct_expressed, logfc.threshold = 0 ) %>%
      tibble::rownames_to_column("gene") %>%
      dplyr::filter(p_val_adj < p_val_adj_cutoff, avg_log2FC > logfc_cutoff)
    geneset_oi <- DE_table_receiver$gene[DE_table_receiver$gene %in% rownames(ligand_target_matrix)]
    if(length(geneset_oi) == 0) stop("No DEGs found in the receiver cell type that are also in the NicheNet ligand_target_matrix. Number of DEGs before NicheNet filter: ", nrow(DE_table_receiver), call. = FALSE)
    if (verbose) message(length(geneset_oi), " DEGs (upregulated in ident.1) from receiver '", receiver_celltype, "' identified for NicheNet analysis.")
    
    # --- IV. Define Potential Ligands ---
    if (verbose) message("Defining potential ligands...")
    ligands_db <- lr_network %>% dplyr::pull(from) %>% unique()
    receptors_db <- lr_network %>% dplyr::pull(to) %>% unique()
    expressed_ligands <- intersect(ligands_db, expressed_genes_sender)
    expressed_receptors <- intersect(receptors_db, expressed_genes_receiver)
    potential_ligands <- lr_network %>% dplyr::filter(from %in% expressed_ligands & to %in% expressed_receptors) %>% dplyr::pull(from) %>% unique()
    if(length(potential_ligands) == 0) stop("No potential ligands found based on expression in sender/receiver and L-R database.", call. = FALSE)
    if (verbose) message(length(potential_ligands), " potential ligands identified.")
    
    # --- V. Perform NicheNet Ligand Activity Analysis ---
    if (verbose) message("Predicting ligand activities...")
    ligand_activities <- nichenetr::predict_ligand_activities(geneset = geneset_oi, background_expressed_genes = background_expressed_genes, ligand_target_matrix = ligand_target_matrix, potential_ligands = potential_ligands) %>% dplyr::arrange(dplyr::desc(aupr_corrected))
    best_upstream_ligands <- ligand_activities %>% dplyr::top_n(min(top_n_ligands, nrow(ligand_activities)), aupr_corrected) %>% dplyr::pull(test_ligand) %>% unique()
    if (verbose) message("Top ", length(best_upstream_ligands), " ligands selected based on AUPR.")
    
    # --- VI. Infer Active Target Genes of Top Ligands ---
    if (verbose) message("Inferring active target genes for top ligands...")
    active_ligand_target_links_df <- best_upstream_ligands %>%
      lapply(nichenetr::get_weighted_ligand_target_links, geneset = geneset_oi, ligand_target_matrix = ligand_target_matrix, n = top_n_targets_per_ligand) %>%
      dplyr::bind_rows() %>% tidyr::drop_na()
    p_ligand_target_network <- NULL
    if(nrow(active_ligand_target_links_df) > 0){
      active_ligand_target_links_matrix <- nichenetr::prepare_ligand_target_visualization(ligand_target_df = active_ligand_target_links_df, ligand_target_matrix = ligand_target_matrix, cutoff = ligand_target_cutoff)
      if (is.null(active_ligand_target_links_matrix) || nrow(active_ligand_target_links_matrix) == 0 || ncol(active_ligand_target_links_matrix) == 0) {
        warning("NN_Warning: Ligand-target matrix is empty/small after preparation. Skipping L-T heatmap.")
        p_ligand_target_network <- ggplot2::ggplot() + ggplot2::labs(title="No L-T links for heatmap after preparation.")
      } else {
        ligands_for_ordering <- intersect(best_upstream_ligands, colnames(active_ligand_target_links_matrix)) %>% rev()
        targets_for_ordering <- active_ligand_target_links_df$target %>% unique() %>% intersect(rownames(active_ligand_target_links_matrix))
        rownames(active_ligand_target_links_matrix) <- make.names(rownames(active_ligand_target_links_matrix))
        colnames(active_ligand_target_links_matrix) <- make.names(colnames(active_ligand_target_links_matrix))
        order_ligands_final <- make.names(ligands_for_ordering)
        order_targets_final <- make.names(targets_for_ordering)
        order_ligands_final_intersect <- intersect(order_ligands_final, colnames(active_ligand_target_links_matrix))
        order_targets_final_intersect <- intersect(order_targets_final, rownames(active_ligand_target_links_matrix))
        if (length(order_targets_final_intersect) == 0 || length(order_ligands_final_intersect) == 0) {
          warning("NN_Warning: No common targets or ligands for L-T heatmap after make.names. Skipping.")
          p_ligand_target_network <- ggplot2::ggplot() + ggplot2::labs(title="No common targets/ligands for L-T heatmap.")
        } else {
          active_ligand_target_links_vis <- active_ligand_target_links_matrix[order_targets_final_intersect, order_ligands_final_intersect, drop = FALSE]
          p_ligand_target_network <- nichenetr::make_heatmap_ggplot(active_ligand_target_links_vis %>% t(), "Prioritized ligands", "Predicted target genes", color = "purple", legend_position = "top", x_axis_position = "top", legend_title = "Regulatory potential") + ggplot2::theme(axis.text.x = ggplot2::element_text(face = "italic"))
        }
      }
    } else {
      warning("NN_Warning: active_ligand_target_links_df is empty. Skipping L-T heatmap.")
      p_ligand_target_network <- ggplot2::ggplot() + ggplot2::labs(title="No active L-T links found.")
    }
    
    # --- VII. Infer Receptors of Top-Ranked Ligands ---
    if (verbose) message("Inferring receptors for top ligands...")
    p_ligand_receptor_network <- NULL
    lr_network_top_df_large <- dplyr::tibble()
    lr_network_top <- lr_network %>% dplyr::filter(from %in% best_upstream_ligands & to %in% expressed_receptors) %>% dplyr::distinct(from, to)
    best_upstream_receptors <- lr_network_top %>% dplyr::pull(to) %>% unique()
    if(length(best_upstream_ligands) > 0 && length(best_upstream_receptors) > 0){
      lr_network_top_df_large <- weighted_networks_lr %>% dplyr::filter(from %in% best_upstream_ligands & to %in% best_upstream_receptors)
      valid_ligands_in_df <- intersect(best_upstream_ligands, unique(lr_network_top_df_large$from))
      valid_receptors_in_df <- intersect(best_upstream_receptors, unique(lr_network_top_df_large$to))
      if(length(valid_ligands_in_df) > 0 && length(valid_receptors_in_df) > 0) {
        lr_network_top_df_filtered <- lr_network_top_df_large %>% dplyr::filter(from %in% valid_ligands_in_df, to %in% valid_receptors_in_df)
        if (nrow(lr_network_top_df_filtered) > 0) {
          lr_network_top_df <- lr_network_top_df_filtered %>% tidyr::spread(key = "from", value = "weight", fill = 0)
          lr_network_top_matrix <- lr_network_top_df %>% dplyr::select(-to) %>% as.matrix() %>% magrittr::set_rownames(lr_network_top_df$to)
          if(nrow(lr_network_top_matrix) > 1 && ncol(lr_network_top_matrix) > 1) {
            dist_receptors <- stats::dist(lr_network_top_matrix, method = "binary"); hclust_receptors <- stats::hclust(dist_receptors, method = "ward.D2"); order_receptors <- hclust_receptors$labels[hclust_receptors$order]
            dist_ligands <- stats::dist(t(lr_network_top_matrix), method = "binary"); hclust_ligands <- stats::hclust(dist_ligands, method = "ward.D2"); order_ligands_receptor <- hclust_ligands$labels[hclust_ligands$order]
          } else { order_receptors <- rownames(lr_network_top_matrix); order_ligands_receptor <- colnames(lr_network_top_matrix) }
          vis_ligand_receptor_network <- lr_network_top_matrix[order_receptors, order_ligands_receptor, drop=FALSE]
          rownames(vis_ligand_receptor_network) <- make.names(rownames(vis_ligand_receptor_network)); colnames(vis_ligand_receptor_network) <- make.names(colnames(vis_ligand_receptor_network))
          p_ligand_receptor_network <- nichenetr::make_heatmap_ggplot(vis_ligand_receptor_network %>% t(), "Prioritized Ligands", "Receptors", color = "mediumvioletred", x_axis_position = "top", legend_title = "Prior interaction potential")
        } else { warning("NN_Warning: Not enough valid L-R pairs for heatmap after filtering."); p_ligand_receptor_network <- ggplot2::ggplot() + ggplot2::labs(title="Not enough valid L-R pairs for heatmap.") }
      } else { warning("NN_Warning: Not enough valid L-R pairs for heatmap after initial filtering."); p_ligand_receptor_network <- ggplot2::ggplot() + ggplot2::labs(title="Not enough valid L-R pairs for heatmap.") }
    } else { warning("NN_Warning: No L-R interactions to display (no best ligands/receptors)."); p_ligand_receptor_network <- ggplot2::ggplot() + ggplot2::labs(title="No L-R interactions to display.") }
    
    # --- VIII. Additional Plots ---
    p_hist_lig_activity <- ggplot2::ggplot(ligand_activities, ggplot2::aes(x = aupr_corrected)) + ggplot2::geom_histogram(color = "black", fill = "darkorange", bins=30) + ggplot2::geom_vline(ggplot2::aes(xintercept = min(ligand_activities %>% dplyr::top_n(min(top_n_ligands, nrow(ligand_activities)), aupr_corrected) %>% dplyr::pull(aupr_corrected))), color = "red", linetype = "dashed", linewidth = 1) + ggplot2::labs(x = "Ligand Activity (AUPR corrected)", y = "# Ligands") + ggplot2::theme_classic()
    vis_ligand_aupr <- ligand_activities %>% dplyr::filter(test_ligand %in% best_upstream_ligands) %>% tibble::column_to_rownames("test_ligand") %>% dplyr::select(aupr_corrected) %>% dplyr::arrange(aupr_corrected) %>% as.matrix()
    p_ligand_aupr_heatmap <- nichenetr::make_heatmap_ggplot(vis_ligand_aupr, "Prioritized ligands", "Ligand activity", legend_title = "AUPR", color = "darkorange") + ggplot2::theme(axis.text.x.top = ggplot2::element_blank())
    
    # --- IX. (Optional) Signaling Path Inference ---
    # THIS ENTIRE SECTION IS REMOVED
    signaling_results <- NULL
    
    # --- X. (Optional) Circos Plot ---
    recorded_circos_plot <- NULL
    # temp_circos_notes <- character(0) # This will be handled by circos_notes_collected
    circos_status_message <- "Circos plot not generated: run_circos was FALSE or required packages missing."
    
    if(run_circos){
      # Ensure Seurat is available for GetAssayData, Idents, Cells
      if(requireNamespace("circlize", quietly = TRUE) &&
         requireNamespace("RColorBrewer", quietly = TRUE) &&
         requireNamespace("Seurat", quietly = TRUE)){ # Seurat needed for Cells, Idents, GetAssayData
        
        if (verbose) message("Generating Circos plot for ligand-receptor interactions with sender information...")
        
        if(exists("lr_network_top_df_large") && is.data.frame(lr_network_top_df_large) && nrow(lr_network_top_df_large) > 0 && all(c("from", "to", "weight") %in% colnames(lr_network_top_df_large)) ){
          circos_lr_data_raw <- lr_network_top_df_large %>% dplyr::filter(from %in% best_upstream_ligands)
          
          if(nrow(circos_lr_data_raw) > 0) {
            # Data Preparation for Circos (ensure all pkg calls are prefixed if not in @importFrom)
            unique_ligands_in_circos <- unique(circos_lr_data_raw$from)
            ligand_sender_map <- sapply(unique_ligands_in_circos, function(lig) {
              expressing_senders <- c()
              for (s_type in sender_celltypes) {
                cells_in_sender <- Seurat::Cells(seurat_obj)[Seurat::Idents(seurat_obj) == s_type]
                if (length(cells_in_sender) > 0) {
                  if (lig %in% rownames(Seurat::GetAssayData(seurat_obj, assay = assay_name, slot = "data"))) {
                    gene_expr_in_sender <- Seurat::GetAssayData(seurat_obj, assay = assay_name, slot = "data")[lig, cells_in_sender, drop=FALSE]
                    if (sum(gene_expr_in_sender > 0) / length(cells_in_sender) >= min_pct_expressed) {
                      expressing_senders <- c(expressing_senders, s_type)
                    }
                  }
                }
              }
              if (length(expressing_senders) > 0) return(expressing_senders[1])
              return("UnknownSender")
            }, USE.NAMES = TRUE)
            
            ligand_df_circos <- tibble::tibble(
              item = unique_ligands_in_circos,
              color_group = ligand_sender_map[item]
            )
            receptor_df_circos <- tibble::tibble(
              item = unique(circos_lr_data_raw$to),
              color_group = "Receptor"
            )
            links_df_circos <- circos_lr_data_raw %>%
              dplyr::select(from, to, weight) %>% # Use 'weight' for link value if desired by chordDiagram aesthetic
              dplyr::rename(origin = from, target = to)
            
            # Color palette generation
            unique_sender_color_groups <- unique(ligand_df_circos$color_group)
            n_actual_senders <- length(setdiff(unique_sender_color_groups, "UnknownSender"))
            sender_palette_values <- character(0)
            if (n_actual_senders > 0) {
              pal_name <- "Set1"
              max_cols_for_palette <- RColorBrewer::brewer.pal.info[pal_name, "maxcolors"]
              num_cols_to_request <- min(n_actual_senders, max_cols_for_palette)
              sender_palette_values <- RColorBrewer::brewer.pal(n = num_cols_to_request, name = pal_name)
              if (n_actual_senders > length(sender_palette_values)) {
                sender_palette_values <- rep(sender_palette_values, length.out = n_actual_senders)
              }
            }
            sender_palette <- stats::setNames(sender_palette_values, setdiff(unique_sender_color_groups, "UnknownSender"))
            if ("UnknownSender" %in% unique_sender_color_groups) {
              sender_palette["UnknownSender"] <- "grey50"
            }
            receptor_color <- RColorBrewer::brewer.pal(n = 3, name = "Set2")[1]
            
            # Sector order and color vector
            ordered_ligands <- ligand_df_circos %>% dplyr::arrange(color_group, item) %>% dplyr::pull(item)
            ordered_receptors <- receptor_df_circos %>% dplyr::arrange(item) %>% dplyr::pull(item)
            sector_order <- c(ordered_ligands, ordered_receptors)
            
            grid_cols_ordered <- stats::setNames(character(length(sector_order)), sector_order)
            for(lig in ordered_ligands) {
              sender_grp <- ligand_sender_map[lig] # Get the specific sender group for this ligand
              grid_cols_ordered[lig] <- sender_palette[sender_grp] %||% "grey70" # Fallback
            }
            for(rec in ordered_receptors) {
              grid_cols_ordered[rec] <- receptor_color
            }
            
            
            # Define defaults if not provided by the user
            circos_cex_text <- args_option$circos_cex_text %||% 0.4 # Default from your code
            circos_png_width <- args_option$circos_png_width %||% 1000
            circos_png_height <- args_option$circos_png_height %||% 1000
            circos_png_res <- args_option$circos_png_res %||% 100
            circos_pdf_width <- args_option$circos_pdf_width %||% 10
            circos_pdf_height <- args_option$circos_pdf_height %||% 10
            # Add any other parameters you want to control for circlize::chordDiagram, etc.
            # e.g., link_transparency <- args_option$link_transparency %||% 0.25
            
            # Define the plotting function
            do_circos_plotting <- function() {
              circlize::circos.clear()
              circlize::chordDiagram(links_df_circos,
                                     order = sector_order,
                                     grid.col = grid_cols_ordered,
                                     transparency = 0.25,
                                     annotationTrack = "grid",
                                     preAllocateTracks = list(track.height = circlize::mm_h(4)),
                                     directional = 1, direction.type = "arrows",
                                     link.arr.type = "big.arrow", link.arr.length = 0.05, link.arr.width = 0.05)
              circlize::circos.track(track.index = 1, panel.fun = function(x, y) {
                circlize::circos.text(circlize::CELL_META$xcenter, circlize::CELL_META$ylim[1] + circlize::uy(5, "mm"),
                                      circlize::CELL_META$sector.index,
                                      facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),
                                      cex=circos_cex_text)
              }, bg.border = NA)
            }
            
            # Capture messages (notes) from circlize
            # Plot to a dummy PDF to ensure full execution for message capture
            temp_pdf_for_capture_notes <- tempfile(fileext = ".pdf")
            grDevices::pdf(temp_pdf_for_capture_notes)
            # Note: The actual capture happens on the expression inside capture.output
            captured_circlize_messages <- utils::capture.output({
              do_circos_plotting() # This call's messages will be captured
            }, type = "message")
            grDevices::dev.off() # Close the dummy PDF device
            if(file.exists(temp_pdf_for_capture_notes)) unlink(temp_pdf_for_capture_notes) # Clean up
            
            # Filter for "Note:" lines
            temp_notes <- grep("^Note:", captured_circlize_messages, value = TRUE)
            if (length(temp_notes) > 0) {
              circos_notes_collected <<- c(circos_notes_collected, temp_notes)
            }
            
            
            tryCatch({
              if(!is.null(current_run_output_dir)){
                grDevices::pdf(file.path(current_run_output_dir, "NicheNet_Circos_LR.pdf"), width=circos_pdf_width, height=circos_pdf_height); do_circos_plotting(); grDevices::dev.off()
                grDevices::png(file.path(current_run_output_dir, "NicheNet_Circos_LR.png"), width=circos_png_width, height=circos_png_height, res=circos_png_res); do_circos_plotting(); grDevices::dev.off()
                
                legend_text <- "Circos Legend (Sender Cell Type for Ligands):\n"
                for(s_group in names(sender_palette)){ # Iterate over actual palette used
                  legend_text <- paste0(legend_text, s_group, " (Ligands): Color ", sender_palette[s_group], "\n")
                }
                legend_text <- paste0(legend_text, "Receptor: Color ", receptor_color, "\n")
                cat(legend_text, file=file.path(current_run_output_dir, "NicheNet_Circos_LR_legend.txt"))
                if(verbose) message("Circos plot & legend info saved to: ", current_run_output_dir)
              }
              
              circlize::circos.clear() # Clear before plotting for recordPlot
              do_circos_plotting()     # Plot again for recordPlot
              recorded_circos_plot <- grDevices::recordPlot()
              circlize::circos.clear() # Clear after recordPlot
              
              circos_status_message <- "Circos plot generated and recorded (sender-grouped)."
            }, error = function(e) {
              if (verbose) message("Could not generate or save Sender-grouped Circos plot: ", e$message)
              circos_status_message <- paste("Sender-grouped Circos plot failed:", e$message)
              try(circlize::circos.clear(), silent = TRUE) # Attempt to clean up circlize state
            })
          } else {
            if (verbose) message("No data for Circos plot after filtering (circos_lr_data_raw empty).");
            circos_status_message <- "No data for Circos plot after filtering."
          }
        } else {
          if (verbose) message("Skipping Circos plot: lr_network_top_df_large data unavailable/malformed.");
          circos_status_message <- "Circos plot skipped: lr_network_top_df_large data."
        }
      } else {
        circos_status_message <- "Circos plot skipped: 'circlize', 'RColorBrewer', or 'Seurat' package not fully available."
        if (verbose) message(circos_status_message)
      }
    }
    
    # --- XI. Collate and Return Results ---
    if (verbose) message("NicheNet analysis complete. Collating results...")
    results_list <- list(
      ligand_activities = ligand_activities, best_upstream_ligands = best_upstream_ligands,
      active_ligand_target_links_df = if(exists("active_ligand_target_links_df")) active_ligand_target_links_df else dplyr::tibble(),
      plot_ligand_target_network = p_ligand_target_network,
      ligand_receptor_network_df = lr_network_top_df_large,
      plot_ligand_receptor_network = p_ligand_receptor_network,
      plot_ligand_activity_hist = p_hist_lig_activity, plot_ligand_aupr_heatmap = p_ligand_aupr_heatmap,
      DE_table_receiver = DE_table_receiver,
      plot_circos = if(!is.null(recorded_circos_plot)) recorded_circos_plot else circos_status_message,
      circos_notes = if(length(circos_notes_collected) > 0) circos_notes_collected else "No notes from circos plot generation.", # ADDED
      # signaling_path_graph = signaling_results, # REMOVED
      nichenet_data_loaded_info = nichenet_data_loaded_info,
      output_path_run = if(!is.null(current_run_output_dir)) current_run_output_dir else "Output not saved to files."
    )
    
    if (!is.null(current_run_output_dir)) {
      plot_list_gg <- list(NicheNet_Ligand_Target_Heatmap = results_list$plot_ligand_target_network, NicheNet_Ligand_Receptor_Heatmap = results_list$plot_ligand_receptor_network, NicheNet_Ligand_Activity_Histogram = results_list$plot_ligand_activity_hist, NicheNet_Ligand_AUPR_Heatmap = results_list$plot_ligand_aupr_heatmap)
      plot_dims <- list(NicheNet_Ligand_Target_Heatmap = list(w=10,h=8), NicheNet_Ligand_Receptor_Heatmap = list(w=8,h=6), NicheNet_Ligand_Activity_Histogram = list(w=6,h=5), NicheNet_Ligand_AUPR_Heatmap = list(w=6,h=8))
      for(plot_name in names(plot_list_gg)){ p_obj <- plot_list_gg[[plot_name]]; if(!is.null(p_obj) && inherits(p_obj, "ggplot")){ tryCatch(ggplot2::ggsave(filename = file.path(current_run_output_dir, paste0(plot_name, ".png")), plot = p_obj, width = plot_dims[[plot_name]]$w, height = plot_dims[[plot_name]]$h), error = function(e) warning("NN_Warning: Failed to save plot ", plot_name, ": ", e$message))}}
    }
    return(results_list)
  },
  warning = function(w) {
    if (startsWith(conditionMessage(w), "NN_Warning:")) {
      msg <- sub("^NN_Warning: ", "", conditionMessage(w))
      warnings_collected <<- c(warnings_collected, paste("NicheNet Function:", msg))
    } else {
      warnings_collected <<- c(warnings_collected, paste("R Warning:", conditionMessage(w)))
    }
    invokeRestart("muffleWarning")
  })
  
  # Add collected warnings to the final results
  analysis_results$warnings_occurred <- if(length(warnings_collected) > 0) warnings_collected else "No warnings reported."
  
  # Ensure circos_notes is part of the final returned list, even if an error occurred before it was assigned in the main block
  if(!"circos_notes" %in% names(analysis_results) || is.null(analysis_results$circos_notes)){
    analysis_results$circos_notes <- if(length(circos_notes_collected) > 0) circos_notes_collected else "No notes from circos plot generation (or circos plot did not run)."
  }
  
  
  if (verbose && length(warnings_collected) > 0) {
    message("--------------------------------------------------------------------")
    message("NicheNet Analysis completed with ", length(warnings_collected), " warning(s). See 'warnings_occurred' in output list for details.")
    message("Summary of warnings:")
    for(i in seq_along(warnings_collected)){
      message(paste0(i, ". ", warnings_collected[i]))
      if(i >= 5 && length(warnings_collected) > 5) {
        message("... (and ", length(warnings_collected) - 5, " more warnings)")
        break
      }
    }
    message("--------------------------------------------------------------------")
  } else if (verbose) {
    message("NicheNet Analysis completed successfully with no warnings reported.")
  }
  # ADDED: Summary of circos_notes if verbose
  if (verbose && length(analysis_results$circos_notes) > 0 && !all(analysis_results$circos_notes %in% c("No notes from circos plot generation.", "No notes from circos plot generation (or circos plot did not run).")) ) {
    message("--------------------------------------------------------------------")
    message("Notes from Circos plot generation (see 'circos_notes' in output list):")
    for(i in seq_along(analysis_results$circos_notes)){
      note_to_print <- analysis_results$circos_notes[i]
      # Ensure it's a single string for message()
      if(is.list(note_to_print)) note_to_print <- paste(unlist(note_to_print), collapse=" ")
      message(paste0("- ", note_to_print)) # Make sure note_to_print is a single string
      if(i >= 3 && length(analysis_results$circos_notes) > 3) { # Print max 3 notes in summary
        message("... (and ", length(analysis_results$circos_notes) - 3, " more notes)")
        break
      }
    }
    message("--------------------------------------------------------------------")
  }
  
  
  return(analysis_results)
}

# Helper for path construction (from nichenetr utils, or base R `||` if appropriate)
"%||%" <- function(a, b) {
  if (!is.null(a) && !is.logical(a) && (is.character(a) || is.numeric(a)) && length(a) == 1 && !is.na(a) && nzchar(as.character(a)) ) a else b
}



#' Prepare Data for NicheNet Circos Plot
#'
#' @description
#' This function prepares the necessary data structures for generating a NicheNet
#' ligand-receptor circos plot. It identifies expressing sender cell types for
#' ligands and prepares link dataframes and color/order information.
#'
#' @param lr_network_top_df_large A data frame of ligand-receptor interactions,
#'        typically from NicheNet analysis (e.g., `results$ligand_receptor_network_df`).
#'        Must contain 'from' (ligand), 'to' (receptor), and 'weight' columns.
#' @param best_upstream_ligands A character vector of top N ligands to include.
#' @param seurat_obj A Seurat object (used if `ligand_sender_source` is "seurat_obj").
#' @param sender_celltypes Character vector of sender cell types (used if `ligand_sender_source` is "seurat_obj").
#' @param assay_name Name of the assay in Seurat object (used if `ligand_sender_source` is "seurat_obj").
#' @param min_pct_expressed Minimum percentage of cells in a sender type expressing a ligand
#'        for it to be attributed to that sender (used if `ligand_sender_source` is "seurat_obj").
#' @param ligand_sender_map Optional. A named character vector where names are ligands
#'        and values are their primary sender cell types. If provided, `seurat_obj`,
#'        `sender_celltypes`, etc., are ignored for sender mapping.
#' @param circos_args A list of additional arguments for customizing colors or palettes, e.g.,
#'        `list(sender_palette_name = "Set1", receptor_color_name = "Set2", receptor_color_index = 1)`.
#'
#' @return A list containing:
#'   \itemize{
#'     \item `links_df`: Data frame for `chordDiagram` (origin, target, weight).
#'     \item `sector_order`: Character vector defining the order of items in the circos plot.
#'     \item `grid_cols_ordered`: Named character vector of colors for each sector.
#'     \item `sender_palette_legend`: Named character vector for legend (sender type -> color).
#'     \item `receptor_color_legend`: Named character vector for legend (receptor group -> color).
#'   }
#' Returns NULL if essential input is missing or no valid links can be formed.
#'
#' @importFrom dplyr %>% filter select rename arrange pull distinct
#' @importFrom tibble tibble
#' @importFrom Seurat Cells Idents GetAssayData
#' @importFrom RColorBrewer brewer.pal brewer.pal.info
#' @importFrom stats setNames
#' @export
prepare_nichenet_circos_data <- function(lr_network_top_df_large,
                                         best_upstream_ligands,
                                         seurat_obj = NULL,
                                         sender_celltypes = NULL,
                                         assay_name = "RNA", # Default, ensure it matches your usage
                                         min_pct_expressed = 0.10,
                                         ligand_sender_map = NULL,
                                         circos_args = list()) {
  
  if (is.null(lr_network_top_df_large) || nrow(lr_network_top_df_large) == 0 ||
      !all(c("from", "to", "weight") %in% colnames(lr_network_top_df_large))) {
    warning("`lr_network_top_df_large` is missing, empty, or lacks required columns (from, to, weight).")
    return(NULL)
  }
  if (is.null(best_upstream_ligands) || length(best_upstream_ligands) == 0) {
    warning("`best_upstream_ligands` is empty.")
    return(NULL)
  }
  
  circos_lr_data_raw <- lr_network_top_df_large %>%
    dplyr::filter(from %in% best_upstream_ligands)
  
  if (nrow(circos_lr_data_raw) == 0) {
    warning("No ligand-receptor interactions found for the `best_upstream_ligands`.")
    return(NULL)
  }
  
  unique_ligands_in_circos <- unique(circos_lr_data_raw$from)
  
  if (is.null(ligand_sender_map)) {
    if (is.null(seurat_obj) || is.null(sender_celltypes)) {
      warning("If `ligand_sender_map` is not provided, `seurat_obj` and `sender_celltypes` must be supplied.")
      return(NULL)
    }
    # Determine ligand_sender_map from Seurat object
    ligand_sender_map <- sapply(unique_ligands_in_circos, function(lig) {
      expressing_senders <- c()
      for (s_type in sender_celltypes) {
        # Ensure Idents are set on the Seurat object if not already
        # current_idents <- Seurat::Idents(seurat_obj) # store current idents
        # Seurat::Idents(seurat_obj) <- seurat_obj@meta.data[[cluster_col_name]] # If cluster_col_name needed
        
        cells_in_sender <- Seurat::Cells(seurat_obj)[Seurat::Idents(seurat_obj) == s_type]
        if (length(cells_in_sender) > 0) {
          if (lig %in% rownames(Seurat::GetAssayData(seurat_obj, assay = assay_name, slot = "data"))) {
            gene_expr_in_sender <- Seurat::GetAssayData(seurat_obj, assay = assay_name, slot = "data")[lig, cells_in_sender, drop=FALSE]
            if (sum(gene_expr_in_sender > 0) / length(cells_in_sender) >= min_pct_expressed) {
              expressing_senders <- c(expressing_senders, s_type)
            }
          }
        }
        # Seurat::Idents(seurat_obj) <- current_idents # restore idents
      }
      if (length(expressing_senders) > 0) return(expressing_senders[1])
      return("UnknownSender")
    }, USE.NAMES = TRUE)
  }
  
  
  ligand_df_circos <- tibble::tibble(
    item = unique_ligands_in_circos,
    color_group = ligand_sender_map[item] # item is the ligand name
  )
  receptor_df_circos <- tibble::tibble(
    item = unique(circos_lr_data_raw$to),
    color_group = "Receptor"
  )
  links_df <- circos_lr_data_raw %>%
    dplyr::select(from, to, weight) %>%
    dplyr::rename(origin = from, target = to)
  
  # Color palette generation
  sender_palette_name <- circos_args$sender_palette_name %||% "Set1"
  receptor_color_name <- circos_args$receptor_color_name %||% "Set2"
  receptor_color_idx <- circos_args$receptor_color_idx %||% 1
  
  
  unique_sender_color_groups <- unique(ligand_df_circos$color_group)
  n_actual_senders <- length(setdiff(unique_sender_color_groups, "UnknownSender"))
  sender_palette_values <- character(0)
  
  if (n_actual_senders > 0) {
    max_cols_for_palette <- RColorBrewer::brewer.pal.info[sender_palette_name, "maxcolors"]
    num_cols_to_request <- min(n_actual_senders, max_cols_for_palette)
    sender_palette_values <- RColorBrewer::brewer.pal(n = num_cols_to_request, name = sender_palette_name)
    if (n_actual_senders > length(sender_palette_values)) {
      sender_palette_values <- rep(sender_palette_values, length.out = n_actual_senders)
    }
  }
  sender_palette_legend <- stats::setNames(sender_palette_values, setdiff(unique_sender_color_groups, "UnknownSender"))
  if ("UnknownSender" %in% unique_sender_color_groups) {
    sender_palette_legend["UnknownSender"] <- "grey50"
  }
  receptor_color_legend <- stats::setNames(
    RColorBrewer::brewer.pal(n = max(3, receptor_color_idx), name = receptor_color_name)[receptor_color_idx],
    "Receptor"
  )
  
  
  # Sector order and color vector
  ordered_ligands <- ligand_df_circos %>% dplyr::arrange(color_group, item) %>% dplyr::pull(item)
  ordered_receptors <- receptor_df_circos %>% dplyr::arrange(item) %>% dplyr::pull(item)
  sector_order <- c(ordered_ligands, ordered_receptors)
  
  grid_cols_ordered <- stats::setNames(character(length(sector_order)), sector_order)
  for(lig in ordered_ligands) {
    sender_grp_for_lig <- ligand_sender_map[lig]
    grid_cols_ordered[lig] <- sender_palette_legend[sender_grp_for_lig] %||% "grey70" # Fallback
  }
  for(rec in ordered_receptors) {
    grid_cols_ordered[rec] <- receptor_color_legend["Receptor"]
  }
  
  return(list(
    links_df = links_df,
    sector_order = sector_order,
    grid_cols_ordered = grid_cols_ordered,
    sender_palette_legend = sender_palette_legend,
    receptor_color_legend = receptor_color_legend
  ))
}


#' Draw NicheNet Ligand-Receptor Circos Plot
#'
#' @description
#' This function takes pre-formatted data and generates a circos plot
#' visualizing ligand-receptor interactions.
#'
#' @param circos_data A list containing `links_df`, `sector_order`, and
#'        `grid_cols_ordered`, typically the output of `prepare_nichenet_circos_data()`.
#' @param cex_text Numeric, expansion factor for text labels. Default: 0.4.
#' @param link_transparency Numeric, transparency for links (0-1). Default: 0.25.
#' @param plot_title Optional character string for the plot title.
#' @param show_legend Logical, whether to attempt to draw a legend on the plot (basic). Default: FALSE.
#' @param sender_palette_legend Named character vector (sender type -> color) for legend.
#' @param receptor_color_legend Named character vector (receptor group -> color) for legend.
#'
#' @return A recorded plot object if successful, otherwise NULL.
#'         The plot is also drawn to the current graphics device.
#'
#' @importFrom circlize circos.clear chordDiagram circos.track circos.text uy mm_h CELL_META
#' @importFrom graphics par legend title
#' @importFrom grDevices recordPlot
#' @export
draw_nichenet_circos_plot <- function(circos_data,
                                      cex_text = 0.4,
                                      link_transparency = 0.25,
                                      plot_title = NULL,
                                      show_legend = FALSE,
                                      sender_palette_legend = NULL, # From circos_data
                                      receptor_color_legend = NULL, # From circos_data
                                      legend_size=0.9,
                                      legend_inset=c(-0.15,0)
) {
  if (is.null(circos_data) ||
      !all(c("links_df", "sector_order", "grid_cols_ordered") %in% names(circos_data))) {
    warning("Invalid `circos_data` input.")
    return(NULL)
  }
  
  links_df <- circos_data$links_df
  sector_order <- circos_data$sector_order
  grid_cols_ordered <- circos_data$grid_cols_ordered
  
  # Use legend info from circos_data if not passed directly
  if(is.null(sender_palette_legend) && !is.null(circos_data$sender_palette_legend)){
    sender_palette_legend <- circos_data$sender_palette_legend
  }
  if(is.null(receptor_color_legend) && !is.null(circos_data$receptor_color_legend)){
    receptor_color_legend <- circos_data$receptor_color_legend
  }
  
  
  recorded_plot <- NULL
  captured_notes_list <- list() # To store notes if any
  
  tryCatch({
    # Capture notes
    temp_pdf_for_capture_notes <- tempfile(fileext = ".pdf")
    grDevices::pdf(temp_pdf_for_capture_notes)
    
    current_notes <- utils::capture.output({
      circlize::circos.clear()
      circlize::chordDiagram(links_df,
                             order = sector_order,
                             grid.col = grid_cols_ordered,
                             transparency = link_transparency,
                             annotationTrack = "grid",
                             preAllocateTracks = list(track.height = circlize::mm_h(4)),
                             directional = 1, direction.type = "arrows",
                             link.arr.type = "big.arrow", link.arr.length = 0.05, link.arr.width = 0.05)
      circlize::circos.track(track.index = 1, panel.fun = function(x, y) {
        circlize::circos.text(circlize::CELL_META$xcenter,
                              circlize::CELL_META$ylim[1] + circlize::uy(5, "mm"),
                              circlize::CELL_META$sector.index,
                              facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = cex_text)
      }, bg.border = NA)
    }, type = "message")
    grDevices::dev.off()
    if(file.exists(temp_pdf_for_capture_notes)) unlink(temp_pdf_for_capture_notes)
    
    captured_notes_list$notes <- grep("^Note:", current_notes, value = TRUE)
    
    
    # Actual plotting for recording
    circlize::circos.clear()
    circlize::chordDiagram(links_df,
                           order = sector_order,
                           grid.col = grid_cols_ordered,
                           transparency = link_transparency,
                           annotationTrack = "grid",
                           preAllocateTracks = list(track.height = circlize::mm_h(4)),
                           directional = 1, direction.type = "arrows",
                           link.arr.type = "big.arrow", link.arr.length = 0.05, link.arr.width = 0.05)
    circlize::circos.track(track.index = 1, panel.fun = function(x, y) {
      circlize::circos.text(circlize::CELL_META$xcenter,
                            circlize::CELL_META$ylim[1] + circlize::uy(5, "mm"),
                            circlize::CELL_META$sector.index,
                            facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5), cex = cex_text)
    }, bg.border = NA)
    
    if (!is.null(plot_title)) {
      graphics::title(main = plot_title)
    }
    
    if (show_legend && !is.null(sender_palette_legend) && !is.null(receptor_color_legend)) {
      # Combine legends
      all_legend_items <- c(sender_palette_legend, receptor_color_legend)
      if (length(all_legend_items) > 0) {
        # Need to plot legend outside the circos plot area, adjust plot margins
        # This is a basic legend, ComplexHeatmap::Legend is better for complex legends
        current_par <- graphics::par(no.readonly = TRUE)
        on.exit(graphics::par(current_par)) # Reset par on exit
        graphics::par(mar = c(1, 1, 1, 7) + 0.1, xpd=TRUE) # Adjust right margin for legend
        
        legend_names <- names(all_legend_items)
        legend_colors <- all_legend_items
        
        # Filter out "UnknownSender" if its color is grey50 to avoid redundant grey in legend
        # Or, make sure it's named distinctively if "grey50" is a general fallback.
        # For now, include all named entries.
        
        graphics::legend("topright",
                         inset = legend_inset, # Adjust inset to place it outside plot
                         legend = legend_names,
                         fill = legend_colors,
                         cex = legend_size, # Adjust legend text size
                         title = "Color Legend",
                         bty = "n") # No box
      }
    }
    
    recorded_plot <- grDevices::recordPlot()
    circlize::circos.clear()
    
  }, error = function(e) {
    warning("Error during circos plot generation: ", e$message)
    try(circlize::circos.clear(), silent = TRUE)
    return(NULL)
  })
  
  # Add notes to the recorded_plot object as an attribute if you want to carry them along
  if (!is.null(recorded_plot) && length(captured_notes_list$notes) > 0) {
    attr(recorded_plot, "circos_notes") <- captured_notes_list$notes
  }
  
  return(recorded_plot)
}