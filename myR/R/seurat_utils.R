# ==============================================================================
# Seurat Signature Utilities
# ==============================================================================

#' Add Module Scores for a List of Feature Sets
#'
#' This function takes a Seurat object and a list of feature (gene) sets.
#' For each feature set, it calculates a module score using Seurat's AddModuleScore.
#' The name of the resulting metadata column will be the name of the feature set if provided,
#' or a concatenation of gene names joined by "+" if the feature set is unnamed.
#'
#' @param seurat_object A Seurat object.
#' @param feature_sets A named or unnamed list of character vectors. Each character vector is a set of gene names.
#'                     If the list is named, the names will be used for the output module score columns.
#'                     If a list element is unnamed, its name will be generated by concatenating gene names with "+".
#' @param assay Name of the assay to use. Default is the current default assay.
#' @param layer layer to pull expression data from. Default is "data".
#' @param nbin Number of bins for AddModuleScore. Default is 24.
#' @param ctrl Number of control features for AddModuleScore. Default is 100.
#' @param seed Random seed for AddModuleScore. Default is 1.
#' @param search Passed to Seurat::`[.Assay`. Default is FALSE. Relevant if features are not present in the object.
#' @param ... Additional arguments passed to Seurat::AddModuleScore.
#'
#' @return A Seurat object with added module scores in the metadata.
#'
#' @examples
#' \dontrun{
#' # Assuming 'pbmc' is a Seurat object with an RNA assay
#' # Example feature sets
#' gene_sets <- list(
#'   Tcell_activation = c("CD69", "IFNG", "TNF"),
#'   Monocyte_markers = c("CD14", "LYZ"),
#'   c("CCR7", "SELL", "LEF1"), # Unnamed set
#'   Bcell_core = c("MS4A1", "CD19", "CD79A")
#' )
#'
#' pbmc <- AddMultipleModuleScores(seurat_object = pbmc, feature_sets = gene_sets)
#'
#' # Check the new metadata columns
#' head(pbmc@meta.data)
#'
#' # Visualize a score
#' FeaturePlot(pbmc, features = "Tcell_activation1") # Name is appended with a number
#' FeaturePlot(pbmc, features = "CCR7_SELL_LEF11")
#' }
AddMultipleModuleScores <- function(seurat_object,
                                    feature_sets,
                                    assay = NULL,
                                    layer = "data",
                                    nbin = 24,
                                    ctrl = 100,
                                    seed = 1,
                                    search = FALSE,
                                    ...) {
  if (!requireNamespace("Seurat", quietly = TRUE)) {
    stop("Package 'Seurat' is required but not installed.")
  }
  if (!is.list(feature_sets)) {
    stop("'feature_sets' must be a list of character vectors.")
  }

  if (is.null(assay)) {
    assay <- Seurat::DefaultAssay(seurat_object)
  }

  all_genes <- rownames(Seurat::GetAssayData(seurat_object, assay = assay, layer = layer))
  added_cols <- character(0) # <- 여기에 최종 컬럼명 모음

  for (i in seq_along(feature_sets)) {
    genes_raw <- feature_sets[[i]]
    genes_use <- base::intersect(genes_raw, all_genes)
    if (length(genes_use) == 0) {
      warning(sprintf("feature set %d: no genes found – skipped", i))
      next
    }

    set_name <- names(feature_sets)[i]
    if (is.null(set_name) || set_name == "") {
      set_name <- paste(gsub("-", "_", genes_use), collapse = "+")
    }

    # — 1) AddModuleScore 실행
    before_cols <- colnames(seurat_object[[]])
    seurat_object <- Seurat::AddModuleScore(
      object = seurat_object,
      features = list(genes_use),
      name = set_name, # AddModuleScore가 set_name1 을 만듦
      assay = assay,
      layer = layer,
      nbin = nbin,
      ctrl = ctrl,
      seed = seed,
      search = search,
      ...
    )
    after_cols <- colnames(seurat_object[[]])
    new_col <- base::setdiff(after_cols, before_cols) # 방금 생긴 컬럼

    # — 2) 뒤에 붙은 숫자 제거 & rename
    tidy_col <- sub("1$", "", new_col) # 끝의 1 지우기
    if (tidy_col != new_col) {
      colnames(seurat_object[[]])[match(new_col, after_cols)] <- tidy_col
      message(sprintf("renamed '%s' -> '%s'", new_col, tidy_col))
    }

    added_cols <- c(added_cols, tidy_col)
  }

  # — 3) FeaturePlot 에 바로 써먹을 수 있게 출력
  if (length(added_cols)) {
    msg1 <- "# Copy-&-paste for FeaturePlot:"
    msg2 <- sprintf(
      "FeaturePlot(obj, features = c(%s))",
      paste(sprintf("'%s'", added_cols), collapse = ", ")
    )
    message("\n", msg1, "\n", msg2, "\n")
    flush.console()
  } else {
    warning("No module scores were added.")
  }


  invisible(seurat_object)
}


#' Visualize Module Scores as Heatmap with Statistical Testing
#'
#' This function uses AddModuleScore results to create a heatmap visualization
#' with z-score normalization and statistical significance indicators
#'
#' @param sobj Seurat object
#' @param gene_sets Named list of gene sets
#' @param group Grouping variable (default: "seurat_clusters")
#' @param assay Assay to use (default: "SCT")
#' @param test_method Statistical test method ("wilcox" or "t")
#' @param p_adjust Method for p-value adjustment (default: "bonferroni")
#' @param show_pval Whether to show p-values on the heatmap
#' @param scale_method How to scale the data: "feature" (scale each feature across groups) or "group" (scale within each group)
#' @param color_limits Manual color scale limits (e.g., c(-2, 2)). If NULL, uses symmetric limits based on data
#' @param ... Additional arguments passed to AddModuleScore
#'
#' @return A list containing the heatmap plot and statistical results
#'
PlotModuleScoreHeatmap <- function(
  sobj,
  gene_sets,
  group = "seurat_clusters",
  assay = "SCT",
  test_method = "wilcox",
  p_adjust = "bonferroni",
  show_pval = TRUE,
  scale_method = "feature",
  color_limits = NULL,
  title = "Module Score Expression per Cluster",
  x_label = "Cluster",
  y_label = "Gene Set",
  ...
) {
  library(Seurat)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(patchwork)

  # Validate inputs
  if (is.null(gene_sets) || length(gene_sets) == 0) {
    stop("gene_sets must be provided")
  }

  # Ensure gene_sets is a named list
  if (!is.list(gene_sets)) {
    gene_sets <- list(GeneSet1 = gene_sets)
  }

  if (is.null(names(gene_sets)) || any(names(gene_sets) == "")) {
    for (i in seq_along(gene_sets)) {
      if (is.null(names(gene_sets)[i]) || names(gene_sets)[i] == "") {
        names(gene_sets)[i] <- paste0("GeneSet", i)
      }
    }
  }

  # Add module scores for each gene set
  module_names <- character()
  for (i in seq_along(gene_sets)) {
    set_name <- names(gene_sets)[i]

    # Check if genes exist in the dataset
    genes_present <- gene_sets[[i]][gene_sets[[i]] %in% rownames(sobj[[assay]])]
    if (length(genes_present) == 0) {
      warning(paste("No genes from", set_name, "found in the dataset."))
      next
    }

    # AddModuleScore adds a number suffix, we'll track it
    before_cols <- colnames(sobj@meta.data)
    sobj <- AddModuleScore(
      object = sobj,
      features = list(genes_present),
      name = set_name,
      assay = assay,
      ...
    )
    after_cols <- colnames(sobj@meta.data)
    new_col <- base::setdiff(after_cols, before_cols)

    # Remove the "1" suffix if desired
    if (length(new_col) > 0) {
      clean_name <- sub("1$", "", new_col[1])
      colnames(sobj@meta.data)[colnames(sobj@meta.data) == new_col[1]] <- clean_name
      module_names <- c(module_names, clean_name)
    }
  }

  if (length(module_names) == 0) {
    stop("No valid module scores could be calculated")
  }

  # Calculate average module scores per group
  Idents(sobj) <- group
  group_levels <- levels(Idents(sobj))
  if (is.null(group_levels)) {
    group_levels <- base::unique(Idents(sobj))
  }

  # Extract module score data
  module_data <- sobj@meta.data[, c(group, module_names), drop = FALSE]

  # Calculate mean scores per group
  mean_scores <- module_data %>%
    group_by(!!sym(group)) %>%
    summarise(across(all_of(module_names), mean, na.rm = TRUE)) %>%
    as.data.frame()

  # Z-score normalization based on scale_method
  z_scores <- mean_scores

  if (scale_method == "feature") {
    # Scale each module across all clusters (recommended)
    # 각 module에 대해 모든 cluster의 평균과 표준편차로 정규화
    for (module in module_names) {
      z_scores[[module]] <- scale(mean_scores[[module]])[, 1]
    }
  } else if (scale_method == "group") {
    # Scale all modules within each cluster (original behavior)
    # 각 cluster 내에서 모든 module을 정규화
    z_scores[, module_names] <- t(scale(t(mean_scores[, module_names])))
  } else {
    stop("scale_method must be either 'feature' or 'group'")
  }

  # Statistical testing between clusters
  p_values <- matrix(NA,
    nrow = length(module_names), ncol = length(group_levels),
    dimnames = list(module_names, group_levels)
  )

  for (module in module_names) {
    for (cluster in group_levels) {
      cluster_scores <- module_data[module_data[[group]] == cluster, module]
      other_scores <- module_data[module_data[[group]] != cluster, module]

      if (length(cluster_scores) > 2 && length(other_scores) > 2) {
        if (test_method == "wilcox") {
          test_result <- wilcox.test(cluster_scores, other_scores)
        } else if (test_method == "t") {
          test_result <- t.test(cluster_scores, other_scores)
        }
        p_values[module, as.character(cluster)] <- test_result$p.value
      }
    }
  }

  # Adjust p-values
  p_adj <- matrix(p.adjust(as.vector(p_values), method = p_adjust),
    nrow = nrow(p_values), ncol = ncol(p_values),
    dimnames = dimnames(p_values)
  )

  # Prepare data for plotting
  plot_data <- z_scores %>%
    pivot_longer(
      cols = all_of(module_names),
      names_to = "Module",
      values_to = "ZScore"
    )

  # Add significance indicators
  sig_data <- as.data.frame(p_adj) %>%
    mutate(Module = rownames(.)) %>%
    pivot_longer(
      cols = -Module,
      names_to = group,
      values_to = "p_adj"
    )

  plot_data <- plot_data %>%
    left_join(sig_data, by = c("Module", group))

  # Add significance symbols
  plot_data <- plot_data %>%
    mutate(sig_symbol = case_when(
      p_adj < 0.001 ~ "***",
      p_adj < 0.01 ~ "**",
      p_adj < 0.05 ~ "*",
      TRUE ~ ""
    ))

  # Sort clusters numerically if possible
  numeric_test <- suppressWarnings(as.numeric(as.character(plot_data[[group]])))
  if (!all(is.na(numeric_test))) {
    plot_data[[group]] <- factor(plot_data[[group]],
      levels = as.character(sort(base::unique(numeric_test)))
    )
  }

  # Create heatmap with adjusted color scale
  if (is.null(color_limits)) {
    # Use symmetric limits based on max absolute value
    max_abs <- max(abs(plot_data$ZScore), na.rm = TRUE)
    color_limits <- c(-max_abs, max_abs)
  }

  p <- ggplot(plot_data, aes_string(x = group, y = "Module", fill = "ZScore")) +
    geom_tile() +
    scale_fill_gradient2(
      low = "blue", mid = "white", high = "red",
      midpoint = 0, limits = color_limits, name = "Z-Score"
    ) +
    theme_minimal() +
    labs(title = title, x = x_label, y = y_label) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 12),
      axis.text.y = element_text(size = 12),
      axis.title = element_text(size = 14, face = "bold"),
      plot.title = element_text(size = 16, face = "bold", hjust = 0.5)
    )

  # Add significance indicators if requested
  if (show_pval) {
    p <- p + geom_text(aes(label = sig_symbol),
      color = "black", size = 4, vjust = 0.5
    )
  }

  # Create a summary plot showing raw module scores
  summary_data <- module_data %>%
    pivot_longer(
      cols = all_of(module_names),
      names_to = "Module",
      values_to = "Score"
    )

  p_violin <- ggplot(summary_data, aes_string(x = group, y = "Score", fill = group)) +
    geom_violin(trim = FALSE, alpha = 0.8) +
    geom_boxplot(width = 0.1, outlier.size = 0.5) +
    facet_wrap(~Module, scales = "free_y", ncol = 2) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none"
    ) +
    labs(
      title = "Raw Module Score Distribution",
      x = x_label, y = "Module Score"
    )

  # Combine plots
  combined_plot <- p / p_violin + plot_layout(heights = c(1, 2))

  print(combined_plot)

  # Return results
  return(list(
    plot = combined_plot,
    z_scores = z_scores,
    p_values = p_adj,
    raw_means = mean_scores,
    module_names = module_names
  ))
}

#' Compare Module Scoring Methods
#'
#' This function compares the simple averaging method with AddModuleScore
#'
#' @export
CompareModuleScoringMethods <- function(
  sobj,
  gene_sets,
  group = "seurat_clusters",
  assay = "SCT"
) {
  library(ggplot2)
  library(patchwork)

  # Method 1: Simple averaging (original method)
  simple_results <- myhm_genesets4(sobj, group, "average", assay, gene_sets,
    title = "Simple Averaging Method"
  )

  # Method 2: AddModuleScore-based
  module_results <- PlotModuleScoreHeatmap(sobj, gene_sets, group, assay,
    title = "AddModuleScore Method"
  )

  # Create comparison plot
  comparison_data <- data.frame(
    Cluster = simple_results$Cluster,
    Method = "Simple"
  )

  for (gset in names(gene_sets)) {
    if (gset %in% colnames(simple_results)) {
      comparison_data[[gset]] <- simple_results[[gset]]
    }
  }

  module_z <- module_results$z_scores
  module_comparison <- data.frame(
    Cluster = module_z[[group]],
    Method = "AddModuleScore"
  )

  for (module in module_results$module_names) {
    if (module %in% colnames(module_z)) {
      module_comparison[[module]] <- module_z[[module]]
    }
  }

  # Combine data
  all_data <- bind_rows(comparison_data, module_comparison)

  # Create faceted comparison plot
  all_data_long <- all_data %>%
    pivot_longer(
      cols = -c(Cluster, Method),
      names_to = "GeneSet",
      values_to = "ZScore"
    )

  p_compare <- ggplot(all_data_long, aes(x = Cluster, y = ZScore, fill = Method)) +
    geom_bar(stat = "identity", position = "dodge") +
    facet_wrap(~GeneSet, scales = "free_y") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(
      title = "Comparison of Scoring Methods",
      x = "Cluster", y = "Z-Score"
    )

  print(p_compare)

  return(list(
    simple = simple_results,
    module = module_results,
    comparison_plot = p_compare
  ))
}

# Example usage:
# gene_sets <- list(
#   Tcell = c("CD3D", "CD3E", "CD3G"),
#   Bcell = c("MS4A1", "CD79A", "CD79B"),
#   Monocyte = c("CD14", "LYZ", "S100A8", "S100A9")
# )
#
# results <- PlotModuleScoreHeatmap(pbmc, gene_sets, show_pval = TRUE)
# comparison <- CompareModuleScoringMethods(pbmc, gene_sets)

#' @title Add Gene Signature Score using enrichIt (Improved Version)
#' @description Calculates a gene signature score using escape::enrichIt and adds it to the Seurat object's metadata.
#' This version flexibly accepts different gene ID types (e.g., ENSEMBL, SYMBOL, ENTREZID).
#'
#' @param seurat_obj A Seurat object.
#' @param gene_source A character string specifying the path to a file OR an R object (data.frame, vector) containing gene IDs.
#' @param signature_name A character string for the name of the new metadata column.
#' @param input_keytype The type of the input gene IDs. Must be a valid keytype for org.Hs.eg.db.
#'                      Common values are "ENSEMBL", "SYMBOL", "ENTREZID". Defaults to "ENSEMBL".
#' @param gene_col If `gene_source` is a file path or a data.frame, specify the column index or name. Defaults to 1.
#' @param sheet_name If `gene_source` is an xlsx file, specify the sheet name or index. Defaults to 1.
#' @param assay The assay to use from the Seurat object. Defaults to "RNA".
#' @param layer The layer (slot) to use from the assay. Defaults to "data".
#' @param ... Additional arguments to be passed to `escape::enrichIt`.
#'
#' @return A Seurat object with the new signature score added to its metadata.
#'
#' @examples
#' \dontrun{
#' # Excel 파일에서 ENSEMBL ID를 읽어서 InflammatoryScore 시그니처 점수를 추가하는 예시
#' data_seurat <- add_signature_enrichit(
#'   seurat_obj = data_seurat,
#'   gene_source = "/data/kjc1/mylit/projects/mIBD/41590_2024_1994_MOESM6_ESM.xlsx",
#'   signature_name = "InflammatoryScore",
#'   input_keytype = "ENSEMBL",
#'   gene_col = 1,
#'   sheet_name = "Inflammation_score",
#'   assay = "RNA",
#'   layer = "data"
#' )
#' }
#' @export
add_signature_enrichit <- function(seurat_obj,
                                   gene_source,
                                   signature_name,
                                   input_keytype = "ENSEMBL", # <--- 이 파라미터 추가!
                                   gene_col = 1,
                                   sheet_name = 1,
                                   assay = "RNA",
                                   layer = "data",
                                   ...) {
  # ... (이전 버전과 동일한 유전자 목록 로드 부분) ...
  if (is.character(gene_source) && length(gene_source) == 1 && file.exists(gene_source)) {
    # 파일 경로일 때만 이 분기
    ext <- tools::file_ext(gene_source)
    gene_list_raw <- switch(ext,
      xlsx = read_xlsx(gene_source, sheet = sheet_name) %>% pull(gene_col),
      csv = read.csv(gene_source, stringsAsFactors = FALSE) %>% pull(gene_col),
      txt = read.table(gene_source, stringsAsFactors = FALSE) %>% pull(gene_col),
      stop("Unsupported file type.")
    )
  } else if (is.data.frame(gene_source)) {
    gene_list_raw <- gene_source %>% pull(gene_col)
  } else if (is.vector(gene_source)) {
    gene_list_raw <- gene_source
  } else {
    stop("`gene_source` must be a valid file path, data.frame, or vector.")
  }

  # 입력된 keytype을 사용하여 항상 SYMBOL로 변환
  # 자동 감지는 권하지 않는다. 왜냐면 오류의 원인이 되기 쉽다. 데이터 정제는 따로 수행하는 것이 좋다.

  message(paste("Input keytype is", input_keytype, ". Converting to Gene Symbols..."))
  gene_symbols <- mapIds(
    org.Hs.eg.db,
    keys = base::unique(na.omit(as.character(gene_list_raw))),
    keytype = input_keytype, # 사용자가 지정한 ID 타입을 사용
    column = "SYMBOL", # 최종 목표는 항상 SYMBOL
    multiVals = "first"
  )
  gene_symbols <- na.omit(gene_symbols)
  # ---

  if (length(gene_symbols) == 0) {
    stop(paste("No valid gene symbols could be mapped using keytype:", input_keytype))
  }
  message(paste(length(gene_symbols), "gene symbols were successfully mapped."))

  gene_set <- GeneSet(gene_symbols, setName = signature_name)
  gene_sets_collection <- GeneSetCollection(gene_set)

  message("Running enrichIt...")
  expr_matrix <- GetAssayData(seurat_obj, assay = assay, layer = layer)
  enrichment_scores <- enrichIt(
    obj = expr_matrix,
    gene.sets = gene_sets_collection,
    ...
  )

  message("Adding scores to Seurat metadata...")
  seurat_obj <- AddMetaData(
    object = seurat_obj,
    metadata = as.data.frame(enrichment_scores)
  )

  return(seurat_obj)
}

#' @title Add Pathway Activity Scores using progeny
#' @description Infers pathway activities using progeny and adds them to the Seurat object's metadata.
#'
#' @param seurat_obj A Seurat object.
#' @param organism A character string specifying the organism. Can be "Human" or "Mouse". Defaults to "Human".
#' @param topn An integer specifying the number of top genes to use for each pathway. Defaults to 100.
#' @param ... Additional arguments to be passed to `progeny::progeny`.
#'
#' @return A Seurat object with pathway activity scores added to its metadata.
#' @export
#'
#' @examples
#' \dontrun{
#' # 예시 데이터 생성
#' pbmc_small <- SeuratObject::pbmc_small
#' pbmc_with_progeny <- add_progeny_scores(pbmc_small, organism = "Human")
#'
#' # 추가된 메타데이터 확인 (14개 경로)
#' head(pbmc_with_progeny@meta.data)
#'
#' # DimPlot으로 특정 경로 활성도 시각화
#' DimPlot(pbmc_with_progeny, reduction = "umap", group.by = "seurat_clusters", label = TRUE)
#' FeaturePlot(pbmc_with_progeny, features = "NFkB")
#' }
add_progeny_scores <- function(seurat_obj, organism = "Human", topn = 100, ...) {
  # 1. Progeny를 실행하여 새로운 assay 추가
  message("Running progeny...")
  seurat_obj <- progeny(
    seurat_obj,
    scale = FALSE, # Scaling은 ScaleData에서 별도 수행
    organism = organism,
    topn = topn,
    return_assay = TRUE,
    ...
  )

  # 2. Progeny assay를 스케일링
  message("Scaling progeny assay...")
  seurat_obj <- ScaleData(seurat_obj, assay = "progeny")

  # 3. 스케일링된 데이터를 메타데이터로 변환하여 추가
  message("Adding scores to Seurat metadata...")
  progeny_scores <- as.data.frame(t(GetAssayData(seurat_obj, assay = "progeny", layer = "scale.data")))

  seurat_obj <- AddMetaData(
    object = seurat_obj,
    metadata = progeny_scores
  )

  return(seurat_obj)
}


# # Helper function to score new data with signature
# #' @export
# score_signature1 <- function(expr_data, signature, normalize=TRUE) {
#   genes <- signature$genes
#   weights <- signature$weights

#   # Extract expression matrix
#   if (inherits(expr_data, "Seurat")) {
#     expr_mat <- as.matrix(Seurat::GetAssayData(expr_data, layer="data"))
#   } else {
#     expr_mat <- as.matrix(expr_data)
#   }

#   # Check gene availability
#   available_genes <- base::intersect(genes, rownames(expr_mat))
#   if (length(available_genes) == 0) {
#     stop("None of the signature genes found in data")
#   }
#   if (length(available_genes) < length(genes)) {
#     warning(sprintf("%d/%d signature genes not found in data",
#                     length(genes) - length(available_genes), length(genes)))
#   }

#   # Calculate scores
#   weights <- weights[available_genes]
#   scores <- colSums(expr_mat[available_genes, , drop=FALSE] * weights)

#   if (normalize) {
#     scores <- scale(scores)[,1]
#   }

#   return(scores)
# }


#' Print Method for Gene Signature Objects
#'
#' @param x A gene_signature object
#' @param ... Additional arguments (not used)
#'
#' @export
print.gene_signature <- function(x, n, ...) {
  cat("Gene Signature Object\n")
  cat("====================\n")
  cat(sprintf("Method: %s\n", x$method))
  cat(sprintf("Target variable: %s (%d groups)\n", x$target_var, x$n_groups))
  cat(sprintf("Number of cells: %d\n", x$n_cells))
  cat(sprintf("Number of genes in signature: %d\n", length(x$genes)))
  cat(sprintf("\nTop 10 genes:\n"))
  print(head(data.frame(gene = x$genes, weight = x$weights[x$genes]), n))

  if (!is.null(x$performance)) {
    cat("\nPerformance:\n")
    print(x$performance)
  }
}


#' Preprocess expression data for FGS v5.x
#' @keywords internal
